; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25017.0 

	TITLE	d:\programming\mathter\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp___Query_perf_counter:PROC
EXTRN	__imp____std_terminate:PROC
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp__rand:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp___Query_perf_frequency:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
$SG4294967241 DB '{', 00H
$SG4294967240 DB 00H
$SG4294967212 DB 00H
$SG4294967239 DB 09H, 00H
$SG4294967208 DB 00H
$SG4294967204 DB 00H
$SG4294967238 DB '}', 0aH, 00H
	ORG $+1
$SG4294967237 DB ' us', 00H
$SG4294967236 DB 'elapsed = ', 00H
	ORG $+1
$SG4294967213 DB '{', 00H
	ORG $+2
$SG4294967211 DB 09H, 00H
	ORG $+2
$SG4294967210 DB '}', 00H
	ORG $+2
$SG4294967209 DB '{', 00H
	ORG $+2
$SG4294967207 DB 09H, 00H
	ORG $+2
$SG4294967206 DB '}', 0aH, 00H
	ORG $+1
$SG4294967205 DB '{', 00H
	ORG $+2
$SG4294967203 DB 09H, 00H
	ORG $+2
$SG4294967202 DB '}', 0aH, 00H
CONST	ENDS
PUBLIC	??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@AAV2@@Z ; std::allocator<Matrix<float,3,3,0,1> >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> &>
PUBLIC	??0?$MatrixData@M$02$02$0A@$00@@QAE@ABV0@@Z	; MatrixData<float,3,3,0,1>::MatrixData<float,3,3,0,1>
PUBLIC	??0?$Matrix@M$02$02$0A@$00@@QAE@ABV0@@Z		; Matrix<float,3,3,0,1>::Matrix<float,3,3,0,1>
PUBLIC	??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@AAV3@@Z ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> &>
PUBLIC	??$forward@AAV?$Matrix@M$02$02$0A@$00@@@std@@YAAAV?$Matrix@M$02$02$0A@$00@@AAV1@@Z ; std::forward<Matrix<float,3,3,0,1> &>
PUBLIC	??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@ABV2@@Z ; std::allocator<Matrix<float,3,3,0,1> >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> const &>
PUBLIC	??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@AAV2@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> &>
PUBLIC	??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@ABV3@@Z ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> const &>
PUBLIC	??$forward@ABV?$Matrix@M$02$02$0A@$00@@@std@@YAABV?$Matrix@M$02$02$0A@$00@@ABV1@@Z ; std::forward<Matrix<float,3,3,0,1> const &>
PUBLIC	??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@@Z ; std::allocator<Matrix<float,3,3,0,1> >::construct<Matrix<float,3,3,0,1> >
PUBLIC	??$_Advance1@PAV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPAV?$Matrix@M$02$02$0A@$00@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance1<Matrix<float,3,3,0,1> *,int>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
PUBLIC	??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@ABV2@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> const &>
PUBLIC	??$Assign@$03@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@@Z ; Vector<float,4>::AssignHelper<4>::Assign<4>
PUBLIC	??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@@Z ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1> >
PUBLIC	??$_Copy_unchecked1@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *>
PUBLIC	??$_Ptr_copy_cat@V?$Matrix@M$02$02$0A@$00@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$Matrix@M$02$02$0A@$00@@0@Z ; std::_Ptr_copy_cat<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> >
PUBLIC	??$advance@PAV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPAV?$Matrix@M$02$02$0A@$00@@H@Z ; std::advance<Matrix<float,3,3,0,1> *,int>
PUBLIC	??$_Uninitialized_copy@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z ; std::_Uninitialized_copy<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
PUBLIC	??$_Distance1@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAHPAV?$Matrix@M$02$02$0A@$00@@0Urandom_access_iterator_tag@0@@Z ; std::_Distance1<Matrix<float,3,3,0,1> *>
PUBLIC	??$_Advance1@PBV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPBV?$Matrix@M$02$02$0A@$00@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance1<Matrix<float,3,3,0,1> const *,int>
PUBLIC	??$_Rechecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAAAPAV?$Matrix@M$02$02$0A@$00@@AAPAV1@PAV1@@Z ; std::_Rechecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *>
PUBLIC	??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
PUBLIC	??$_Uninitialized_copy_al_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
PUBLIC	??$_Unchecked@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAPBV?$Matrix@M$02$02$0A@$00@@PBV1@@Z ; std::_Unchecked<Matrix<float,3,3,0,1> const *>
PUBLIC	??$Assign@$00V?$Vector@M$02@@$$V@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABV?$Vector@M$02@@@Z ; Vector<float,4>::AssignHelper<4>::Assign<1,Vector<float,3> >
PUBLIC	??$Assign@$02M$$V@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABM@Z ; Vector<float,4>::AssignHelper<4>::Assign<3,float>
PUBLIC	??0?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@ABV01@@Z ; std::allocator<Matrix<float,3,3,0,1> >::allocator<Matrix<float,3,3,0,1> >
PUBLIC	?Get@?$GetVectorElement@V?$Vector@M$02@@@?$Vector@M$03@@SAMABV?$Vector@M$02@@H@Z ; Vector<float,4>::GetVectorElement<Vector<float,3> >::Get
PUBLIC	?Get@?$GetVectorElement@M@?$Vector@M$03@@SAMABMH@Z ; Vector<float,4>::GetVectorElement<float>::Get
PUBLIC	??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1> >
PUBLIC	??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > ><std::allocator<Matrix<float,3,3,0,1> > const &>
PUBLIC	??$_Copy_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00@Z ; std::_Copy_unchecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *>
PUBLIC	??$next@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@H@Z ; std::next<Matrix<float,3,3,0,1> *>
PUBLIC	??$_Ucopy@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PAV2@00@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Ucopy<Matrix<float,3,3,0,1> *>
PUBLIC	??$distance@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAHPAV?$Matrix@M$02$02$0A@$00@@0@Z ; std::distance<Matrix<float,3,3,0,1> *>
PUBLIC	??$_Copy_unchecked1@PBV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *>
PUBLIC	??$_Ptr_copy_cat@$$CBV?$Matrix@M$02$02$0A@$00@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBV?$Matrix@M$02$02$0A@$00@@ABQAV2@@Z ; std::_Ptr_copy_cat<Matrix<float,3,3,0,1> const ,Matrix<float,3,3,0,1> >
PUBLIC	??$advance@PBV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPBV?$Matrix@M$02$02$0A@$00@@H@Z ; std::advance<Matrix<float,3,3,0,1> const *,int>
PUBLIC	??$_Uninitialized_copy@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z ; std::_Uninitialized_copy<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
PUBLIC	??$_Distance1@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAHPBV?$Matrix@M$02$02$0A@$00@@0Urandom_access_iterator_tag@0@@Z ; std::_Distance1<Matrix<float,3,3,0,1> const *>
PUBLIC	??$Assign@$0A@MV?$Vector@M$02@@@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABMABV?$Vector@M$02@@@Z ; Vector<float,4>::AssignHelper<4>::Assign<0,float,Vector<float,3> >
PUBLIC	??$Assign@$0A@V?$Vector@M$02@@M@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABV?$Vector@M$02@@ABM@Z ; Vector<float,4>::AssignHelper<4>::Assign<0,Vector<float,3>,float>
PUBLIC	??$_Unfancy@V?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@@Z ; std::_Unfancy<Matrix<float,3,3,0,1> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAXPAV?$Matrix@M$02$02$0A@$00@@0AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Matrix<float,3,3,0,1> >,Matrix<float,3,3,0,1> *>
PUBLIC	??$_Uninitialized_default_fill_n1@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,0,1> *,unsigned int,std::allocator<Matrix<float,3,3,0,1> > >
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > > >
PUBLIC	??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1><std::allocator<Matrix<float,3,3,0,1> > const &>
PUBLIC	??$forward@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@0@ABV10@@Z ; std::forward<std::allocator<Matrix<float,3,3,0,1> > const &>
PUBLIC	??$_Assign_range@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> *>
PUBLIC	??$_Unchecked@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@@Z ; std::_Unchecked<Matrix<float,3,3,0,1> *>
PUBLIC	??$_Copy_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@@Z ; std::_Copy_unchecked<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *>
PUBLIC	??$next@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAPBV?$Matrix@M$02$02$0A@$00@@PBV1@H@Z ; std::next<Matrix<float,3,3,0,1> const *>
PUBLIC	??$_Ucopy@PBV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PBV2@0PAV2@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Ucopy<Matrix<float,3,3,0,1> const *>
PUBLIC	??$distance@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAHPBV?$Matrix@M$02$02$0A@$00@@0@Z ; std::distance<Matrix<float,3,3,0,1> const *>
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$Assign@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@IAEXABMABV?$Vector@M$02@@@Z ; Vector<float,4>::Assign<float,Vector<float,3>,0>
PUBLIC	??$Assign@V?$Vector@M$02@@M$0A@@?$Vector@M$03@@IAEXABV?$Vector@M$02@@ABM@Z ; Vector<float,4>::Assign<Vector<float,3>,float,0>
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myend
PUBLIC	??X?$Vector@M$02@@QAEAAV0@ABV0@@Z		; Vector<float,3>::operator*=
PUBLIC	??X?$Vector@M$02@@QAEAAV0@M@Z			; Vector<float,3>::operator*=
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??R?$Vector@M$03@@QBEMH@Z			; Vector<float,4>::operator()
PUBLIC	??X?$Vector@M$03@@QAEAAV0@ABV0@@Z		; Vector<float,4>::operator*=
PUBLIC	??X?$Vector@M$03@@QAEAAV0@M@Z			; Vector<float,4>::operator*=
PUBLIC	?Width@?$MatrixData@M$03$03$0A@$00@@QBEHXZ	; MatrixData<float,4,4,0,1>::Width
PUBLIC	?Height@?$MatrixData@M$03$03$0A@$00@@QBEHXZ	; MatrixData<float,4,4,0,1>::Height
PUBLIC	?Width@?$MatrixData@M$02$02$0A@$00@@QBEHXZ	; MatrixData<float,3,3,0,1>::Width
PUBLIC	?Height@?$MatrixData@M$02$02$0A@$00@@QBEHXZ	; MatrixData<float,3,3,0,1>::Height
PUBLIC	?size@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::size
PUBLIC	?capacity@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::capacity
PUBLIC	?_Calculate_growth@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@ABEII@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Calculate_growth
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAXPAV?$Matrix@M$02$02$0A@$00@@0AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Matrix<float,3,3,0,1> >,Matrix<float,3,3,0,1> *>
PUBLIC	??$_Uninitialized_default_fill_n@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Matrix<float,3,3,0,1> *,unsigned int,std::allocator<Matrix<float,3,3,0,1> > >
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABU10@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > > >
PUBLIC	??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > ><std::allocator<Matrix<float,3,3,0,1> > const &,void>
PUBLIC	??$assign@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@0@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::assign<Matrix<float,3,3,0,1> *>
PUBLIC	??$addressof@$$CBV?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAPBV?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABV10@@Z ; std::addressof<std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > const >
PUBLIC	??$_Assign_range@PBV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPBV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> const *>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?6M$02$02$0A@$00@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Matrix@M$02$02$0A@$00@@@Z ; operator<<<float,3,3,0,1>
PUBLIC	??$?DM$02@@YA?AV?$Vector@M$02@@MABV0@@Z		; operator*<float,3>
PUBLIC	??$?DM$02@@YA?AV?$Vector@M$02@@ABV0@0@Z		; operator*<float,3>
PUBLIC	??$?6M$03$03$0A@$00@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Matrix@M$03$03$0A@$00@@@Z ; operator<<<float,4,4,0,1>
PUBLIC	??$?DM$03@@YA?AV?$Vector@M$03@@MABV0@@Z		; operator*<float,4>
PUBLIC	??$Set@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@QAEAAV0@ABMABV?$Vector@M$02@@@Z ; Vector<float,4>::Set<float,Vector<float,3>,0>
PUBLIC	??$Set@HHH$0A@@?$Vector@M$02@@QAEAAV0@HHH@Z	; Vector<float,3>::Set<int,int,int,0>
PUBLIC	??$?0V?$Vector@M$02@@M$0A@@?$Vector@M$03@@QAE@ABV?$Vector@M$02@@ABM@Z ; Vector<float,4>::Vector<float,4><Vector<float,3>,float,0>
PUBLIC	??$?6M$03@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Vector@M$03@@@Z ; operator<<<float,4>
PUBLIC	??$?DM$03@@YA?AV?$Vector@M$03@@ABV0@0@Z		; operator*<float,4>
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	?max_size@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QBEIXZ ; std::allocator<Matrix<float,3,3,0,1> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAIABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@2@@Z ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::max_size
PUBLIC	??A?$Vector@M$02@@QBEMH@Z			; Vector<float,3>::operator[]
PUBLIC	??A?$Vector@M$02@@QAEAAMH@Z			; Vector<float,3>::operator[]
PUBLIC	??A?$Vector@M$03@@QBEMH@Z			; Vector<float,4>::operator[]
PUBLIC	??A?$Vector@M$03@@QAEAAMH@Z			; Vector<float,4>::operator[]
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::allocator<Matrix<float,3,3,0,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::allocator<Matrix<float,3,3,0,1> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_second
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?GetElement@?$MatrixData@M$03$03$0A@$00@@QAEAAMHHU?$integral_constant@_N$00@std@@@Z ; MatrixData<float,4,4,0,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$03$03$0A@$00@@QBEMHHU?$integral_constant@_N$00@std@@@Z ; MatrixData<float,4,4,0,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$02$0A@$00@@QAEAAMHHU?$integral_constant@_N$00@std@@@Z ; MatrixData<float,3,3,0,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$02$0A@$00@@QBEMHHU?$integral_constant@_N$00@std@@@Z ; MatrixData<float,3,3,0,1>::GetElement
PUBLIC	?max_size@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Destroy
PUBLIC	?_Xlength@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@CAXXZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Xlength
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_first
PUBLIC	?zero@?$duration_values@_J@chrono@std@@SA_JXZ	; std::chrono::duration_values<__int64>::zero
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?Assign@?$Vector@M$02@@IAEXABV1@@Z		; Vector<float,3>::Assign
PUBLIC	?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero
PUBLIC	?Assign@?$Vector@M$03@@IAEXABV1@@Z		; Vector<float,4>::Assign
PUBLIC	?GetElement@?$MatrixData@M$03$03$0A@$00@@QAEAAMHH@Z ; MatrixData<float,4,4,0,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$03$03$0A@$00@@QBEMHH@Z ; MatrixData<float,4,4,0,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$02$0A@$00@@QAEAAMHH@Z ; MatrixData<float,3,3,0,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$02$0A@$00@@QBEMHH@Z ; MatrixData<float,3,3,0,1>::GetElement
PUBLIC	?_Udefault@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PAV3@I@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Udefault
PUBLIC	?_Buy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAE_NI@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXXZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Tidy
PUBLIC	?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@@Z ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Copy_alloc
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Mylast
PUBLIC	?begin@?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QBEPBV?$Matrix@M$02$02$0A@$00@@XZ ; std::initializer_list<Matrix<float,3,3,0,1> >::begin
PUBLIC	?end@?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QBEPBV?$Matrix@M$02$02$0A@$00@@XZ ; std::initializer_list<Matrix<float,3,3,0,1> >::end
PUBLIC	??0?$Vector@M$02@@QAE@XZ			; Vector<float,3>::Vector<float,3>
PUBLIC	??0?$Vector@M$02@@QAE@M@Z			; Vector<float,3>::Vector<float,3>
PUBLIC	??0?$Vector@M$02@@QAE@ABV0@@Z			; Vector<float,3>::Vector<float,3>
PUBLIC	?Spread@?$Vector@M$02@@QAEAAV1@M@Z		; Vector<float,3>::Spread
PUBLIC	??Y?$Vector@M$02@@QAEAAV0@ABV0@@Z		; Vector<float,3>::operator+=
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??0?$Vector@M$03@@QAE@XZ			; Vector<float,4>::Vector<float,4>
PUBLIC	??0?$Vector@M$03@@QAE@ABV0@@Z			; Vector<float,4>::Vector<float,4>
PUBLIC	?Spread@?$Vector@M$03@@QAEAAV1@M@Z		; Vector<float,4>::Spread
PUBLIC	??Y?$Vector@M$03@@QAEAAV0@ABV0@@Z		; Vector<float,4>::operator+=
PUBLIC	??R?$Matrix@M$02$02$0A@$00@@QAEAAMHH@Z		; Matrix<float,3,3,0,1>::operator()
PUBLIC	??R?$Matrix@M$02$02$0A@$00@@QBEMHH@Z		; Matrix<float,3,3,0,1>::operator()
PUBLIC	??R?$Matrix@M$03$03$0A@$00@@QAEAAMHH@Z		; Matrix<float,4,4,0,1>::operator()
PUBLIC	??R?$Matrix@M$03$03$0A@$00@@QBEMHH@Z		; Matrix<float,4,4,0,1>::operator()
PUBLIC	??0?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@XZ ; std::allocator<Matrix<float,3,3,0,1> >::allocator<Matrix<float,3,3,0,1> >
PUBLIC	??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::~vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >
PUBLIC	??4?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::operator=
PUBLIC	??4?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV01@V?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::operator=
PUBLIC	??A?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::operator[]
PUBLIC	??0?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@XZ ; std::initializer_list<Matrix<float,3,3,0,1> >::initializer_list<Matrix<float,3,3,0,1> >
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0?$MatrixData@M$02$02$0A@$00@@QAE@$$QAV0@@Z	; MatrixData<float,3,3,0,1>::MatrixData<float,3,3,0,1>
PUBLIC	??0?$Matrix@M$02$02$0A@$00@@QAE@$$QAV0@@Z	; Matrix<float,3,3,0,1>::Matrix<float,3,3,0,1>
PUBLIC	??0?$MatrixData@M$02$02$0A@$00@@QAE@XZ		; MatrixData<float,3,3,0,1>::MatrixData<float,3,3,0,1>
PUBLIC	??0?$Matrix@M$02$02$0A@$00@@QAE@XZ		; Matrix<float,3,3,0,1>::Matrix<float,3,3,0,1>
PUBLIC	??0?$MatrixData@M$03$03$0A@$00@@QAE@$$QAV0@@Z	; MatrixData<float,4,4,0,1>::MatrixData<float,4,4,0,1>
PUBLIC	??0?$Matrix@M$03$03$0A@$00@@QAE@$$QAV0@@Z	; Matrix<float,4,4,0,1>::Matrix<float,4,4,0,1>
PUBLIC	??0?$MatrixData@M$03$03$0A@$00@@QAE@XZ		; MatrixData<float,4,4,0,1>::MatrixData<float,4,4,0,1>
PUBLIC	??0?$Matrix@M$03$03$0A@$00@@QAE@XZ		; Matrix<float,4,4,0,1>::Matrix<float,4,4,0,1>
PUBLIC	??0?$Vector@M$03@@QAE@MMMM@Z			; Vector<float,4>::Vector<float,4>
PUBLIC	??$?DMM$02$02$02$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$02$02$0A@$00@@ABV0@0@Z ; operator*<float,float,3,3,3,0,0,1,1,0>
PUBLIC	??$?DMM$03$03$03$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$03$03$0A@$00@@ABV0@0@Z ; operator*<float,float,4,4,4,0,0,1,1,0>
PUBLIC	_main
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	??0?$Vector@M$02@@QAE@MMM@Z			; Vector<float,3>::Vector<float,3>
PUBLIC	?Cross@?$VectorSpec@M$02@@SA?AV?$Vector@M$02@@ABV2@0@Z ; VectorSpec<float,3>::Cross
PUBLIC	?mul@?$VectorSpec@M$03@@IAEXM@Z			; VectorSpec<float,4>::mul
PUBLIC	?add@?$VectorSpec@M$03@@IAEXABV1@@Z		; VectorSpec<float,4>::add
PUBLIC	?mul@?$VectorSpec@M$03@@IAEXABV1@@Z		; VectorSpec<float,4>::mul
PUBLIC	?spread@?$VectorSpec@M$03@@IAEXM@Z		; VectorSpec<float,4>::spread
PUBLIC	?Assign@?$VectorSpec@M$03@@IAEXMMMM@Z		; VectorSpec<float,4>::Assign
PUBLIC	??0?$VectorSpec@M$03@@QAE@MMMM@Z		; VectorSpec<float,4>::VectorSpec<float,4>
PUBLIC	?mul@?$VectorSpec@M$02@@IAEXM@Z			; VectorSpec<float,3>::mul
PUBLIC	?add@?$VectorSpec@M$02@@IAEXABV1@@Z		; VectorSpec<float,3>::add
PUBLIC	?mul@?$VectorSpec@M$02@@IAEXABV1@@Z		; VectorSpec<float,3>::mul
PUBLIC	?spread@?$VectorSpec@M$02@@IAEXM@Z		; VectorSpec<float,3>::spread
PUBLIC	?Assign@?$VectorSpec@M$02@@IAEXMMM@Z		; VectorSpec<float,3>::Assign
PUBLIC	??0?$VectorSpec@M$02@@QAE@MMM@Z			; VectorSpec<float,3>::VectorSpec<float,3>
PUBLIC	?set@Simd4f@@SA?AT1@MMMM@Z			; Simd4f::set
PUBLIC	?spread@Simd4f@@SA?AT1@M@Z			; Simd4f::spread
PUBLIC	?mul@Simd4f@@SA?AT1@ABT1@M@Z			; Simd4f::mul
PUBLIC	?add@Simd4f@@SA?AT1@ABT1@0@Z			; Simd4f::add
PUBLIC	?mul@Simd4f@@SA?AT1@ABT1@0@Z			; Simd4f::mul
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	__xmm@0000000040400000400000003f800000
PUBLIC	__xmm@4040000040400000400000003f800000
PUBLIC	__xmm@40400000404000004080000040a00000
PUBLIC	__xmm@408000004080000040a0000040c00000
PUBLIC	__xmm@40a0000040a0000040c0000040e00000
PUBLIC	__xmm@40c0000040c0000040a0000040800000
PUBLIC	__xmm@41100000411000004100000040e00000
PUBLIC	__xmm@41a000004140000040c0000040000000
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	__alldiv:PROC
EXTRN	__alldvrm:PROC
EXTRN	__allmul:PROC
EXTRN	__ltod3:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41a000004140000040c0000040000000
CONST	SEGMENT
__xmm@41a000004140000040c0000040000000 DB 00H, 00H, 00H, '@', 00H, 00H, 0c0H
	DB	'@', 00H, 00H, '@A', 00H, 00H, 0a0H, 'A'
CONST	ENDS
;	COMDAT __xmm@41100000411000004100000040e00000
CONST	SEGMENT
__xmm@41100000411000004100000040e00000 DB 00H, 00H, 0e0H, '@', 00H, 00H, 00H
	DB	'A', 00H, 00H, 010H, 'A', 00H, 00H, 010H, 'A'
CONST	ENDS
;	COMDAT __xmm@40c0000040c0000040a0000040800000
CONST	SEGMENT
__xmm@40c0000040c0000040a0000040800000 DB 00H, 00H, 080H, '@', 00H, 00H, 0a0H
	DB	'@', 00H, 00H, 0c0H, '@', 00H, 00H, 0c0H, '@'
CONST	ENDS
;	COMDAT __xmm@40a0000040a0000040c0000040e00000
CONST	SEGMENT
__xmm@40a0000040a0000040c0000040e00000 DB 00H, 00H, 0e0H, '@', 00H, 00H, 0c0H
	DB	'@', 00H, 00H, 0a0H, '@', 00H, 00H, 0a0H, '@'
CONST	ENDS
;	COMDAT __xmm@408000004080000040a0000040c00000
CONST	SEGMENT
__xmm@408000004080000040a0000040c00000 DB 00H, 00H, 0c0H, '@', 00H, 00H, 0a0H
	DB	'@', 00H, 00H, 080H, '@', 00H, 00H, 080H, '@'
CONST	ENDS
;	COMDAT __xmm@40400000404000004080000040a00000
CONST	SEGMENT
__xmm@40400000404000004080000040a00000 DB 00H, 00H, 0a0H, '@', 00H, 00H, 080H
	DB	'@', 00H, 00H, '@@', 00H, 00H, '@@'
CONST	ENDS
;	COMDAT __xmm@4040000040400000400000003f800000
CONST	SEGMENT
__xmm@4040000040400000400000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	'@', 00H, 00H, '@@', 00H, 00H, '@@'
CONST	ENDS
;	COMDAT __xmm@0000000040400000400000003f800000
CONST	SEGMENT
__xmm@0000000040400000400000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	'@', 00H, 00H, '@@', 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-06
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	01H
	DD	FLAT:__unwindfunclet$_main$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z$44
__catchsym$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z$44 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$11
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Size$dead$ = ecx
; __Where$ = edx

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, edx

; 94   :     }

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC					; operator delete, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 98   :         return;
; 99   :     }

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT
; __First$ = ecx

; 480  : 		return (_CSTD strlen(_First));

	lea	edx, DWORD PTR [ecx+1]
$LL3@length:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL3@length
	sub	ecx, edx
	mov	eax, ecx

; 481  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 541  : 		{	// test for metacharacter equality

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sete	al

; 542  : 		return (_Left == _Right);
; 543  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 552  : 		return (EOF);

	or	eax, -1

; 553  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Try_aligned_allocation$dead$ = 8			; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT
; __Count$ = ecx
; __Sz$dead$ = edx

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax

; 91   : 	}

	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	ecx, 89478485				; 05555555H
	jbe	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 4

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 89   : 		}
; 90   : 	return (_Ptr);

	mov	eax, ecx

; 91   : 	}

	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 91   : 	}

	ret	0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Sz$dead$ = 8						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT
; __Ptr$ = ecx
; __Count$ = edx

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	edx, 89478485				; 05555555H
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 4

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN3@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN7@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 	}

	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
;	COMDAT ?mul@Simd4f@@SA?AT1@ABT1@0@Z
_TEXT	SEGMENT
$T2 = 8							; size = 4
?mul@Simd4f@@SA?AT1@ABT1@0@Z PROC			; Simd4f::mul, COMDAT
; _lhs$ = ecx
; _rhs$ = edx

; 11   : 	static inline Simd4f mul(const Simd4f& lhs, const Simd4f& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]

; 12   : 		Simd4f res;
; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [ecx]
	mulps	xmm0, XMMWORD PTR [edx]
	mov	eax, DWORD PTR $T2[ebx]
	mov	DWORD PTR [esp+4], ebp
	movups	XMMWORD PTR [eax], xmm0

; 14   : 		return res;
; 15   : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?mul@Simd4f@@SA?AT1@ABT1@0@Z ENDP			; Simd4f::mul
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
;	COMDAT ?add@Simd4f@@SA?AT1@ABT1@0@Z
_TEXT	SEGMENT
$T2 = 8							; size = 4
?add@Simd4f@@SA?AT1@ABT1@0@Z PROC			; Simd4f::add, COMDAT
; _lhs$ = ecx
; _rhs$ = edx

; 23   : 	static inline Simd4f add(const Simd4f& lhs, const Simd4f& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]

; 24   : 		Simd4f res;
; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [ecx]
	addps	xmm0, XMMWORD PTR [edx]
	mov	eax, DWORD PTR $T2[ebx]
	mov	DWORD PTR [esp+4], ebp
	movups	XMMWORD PTR [eax], xmm0

; 26   : 		return res;
; 27   : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?add@Simd4f@@SA?AT1@ABT1@0@Z ENDP			; Simd4f::add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
;	COMDAT ?mul@Simd4f@@SA?AT1@ABT1@M@Z
_TEXT	SEGMENT
$T3 = 8							; size = 4
?mul@Simd4f@@SA?AT1@ABT1@M@Z PROC			; Simd4f::mul, COMDAT
; _lhs$ = ecx
; _rhs$ = xmm2s

; 35   : 	static inline Simd4f mul(const Simd4f& lhs, float rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]

; 36   : 		Simd4f res;
; 37   : 		__m128 tmp = _mm_set1_ps(rhs);
; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mov	eax, DWORD PTR $T3[ebx]
	movaps	xmm0, xmm2
	shufps	xmm0, xmm0, 0
	mulps	xmm0, XMMWORD PTR [ecx]
	mov	DWORD PTR [esp+4], ebp
	movups	XMMWORD PTR [eax], xmm0

; 39   : 		return res;
; 40   : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?mul@Simd4f@@SA?AT1@ABT1@M@Z ENDP			; Simd4f::mul
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
;	COMDAT ?spread@Simd4f@@SA?AT1@M@Z
_TEXT	SEGMENT
$T2 = 8							; size = 4
?spread@Simd4f@@SA?AT1@M@Z PROC				; Simd4f::spread, COMDAT
; _value$ = xmm1s

; 67   : 	static inline Simd4f spread(float value) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]

; 68   : 		Simd4f res;
; 69   : 		res.reg = _mm_set1_ps(value);

	mov	eax, DWORD PTR $T2[ebx]
	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 0
	mov	DWORD PTR [esp+4], ebp
	movups	XMMWORD PTR [eax], xmm0

; 70   : 		return res;
; 71   : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?spread@Simd4f@@SA?AT1@M@Z ENDP				; Simd4f::spread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
;	COMDAT ?set@Simd4f@@SA?AT1@MMMM@Z
_TEXT	SEGMENT
$T2 = 8							; size = 4
_w$ = 12						; size = 4
?set@Simd4f@@SA?AT1@MMMM@Z PROC				; Simd4f::set, COMDAT
; _x$ = xmm1s
; _y$ = xmm2s
; _z$ = xmm3s

; 73   : 	static inline Simd4f set(float x, float y, float z, float w) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]

; 74   : 		Simd4f res;
; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	mov	eax, DWORD PTR $T2[ebx]
	movaps	xmm4, xmm1
	movss	xmm1, DWORD PTR _w$[ebx]
	movaps	xmm0, xmm3
	unpcklps xmm4, xmm0
	unpcklps xmm2, xmm1
	unpcklps xmm4, xmm2
	mov	DWORD PTR [esp+4], ebp
	movups	XMMWORD PTR [eax], xmm4

; 76   : 		return res;
; 77   : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?set@Simd4f@@SA?AT1@MMMM@Z ENDP				; Simd4f::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$VectorSpec@M$02@@QAE@MMM@Z
_TEXT	SEGMENT
??0?$VectorSpec@M$02@@QAE@MMM@Z PROC			; VectorSpec<float,3>::VectorSpec<float,3>, COMDAT
; _this$ = ecx
; _x$ = xmm1s
; _y$ = xmm2s
; _z$ = xmm3s
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	movaps	xmm4, xmm1
	movaps	xmm0, xmm3
	xorps	xmm1, xmm1
	unpcklps xmm4, xmm0
	unpcklps xmm2, xmm1
; File d:\programming\mathter\mathter\vector.hpp

; 312  : 	}

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	unpcklps xmm4, xmm2
; File d:\programming\mathter\mathter\vector.hpp

; 311  : 		simd = Simd4f::set(x, y, z, 0);

	movups	XMMWORD PTR [ecx], xmm4

; 312  : 	}

	ret	0
??0?$VectorSpec@M$02@@QAE@MMM@Z ENDP			; VectorSpec<float,3>::VectorSpec<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?Assign@?$VectorSpec@M$02@@IAEXMMM@Z
_TEXT	SEGMENT
?Assign@?$VectorSpec@M$02@@IAEXMMM@Z PROC		; VectorSpec<float,3>::Assign, COMDAT
; _this$ = ecx
; _x$ = xmm1s
; _y$ = xmm2s
; _z$ = xmm3s
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	movaps	xmm4, xmm1
	movaps	xmm0, xmm3
	xorps	xmm1, xmm1
	unpcklps xmm4, xmm0
	unpcklps xmm2, xmm1
	unpcklps xmm4, xmm2
; File d:\programming\mathter\mathter\vector.hpp

; 326  : 		simd = Simd4f::set(x, y, z, 0);

	movups	XMMWORD PTR [ecx], xmm4

; 327  : 	}

	ret	0
?Assign@?$VectorSpec@M$02@@IAEXMMM@Z ENDP		; VectorSpec<float,3>::Assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?spread@?$VectorSpec@M$02@@IAEXM@Z
_TEXT	SEGMENT
?spread@?$VectorSpec@M$02@@IAEXM@Z PROC			; VectorSpec<float,3>::spread, COMDAT
; _this$ = ecx
; _all$ = xmm1s

; 328  : 	inline void spread(float all) {

	movaps	xmm0, xmm1
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	shufps	xmm0, xmm0, 0
; File d:\programming\mathter\mathter\vector.hpp

; 329  : 		simd = Simd4f::spread(all);

	movups	XMMWORD PTR [ecx], xmm0

; 330  : 	}

	ret	0
?spread@?$VectorSpec@M$02@@IAEXM@Z ENDP			; VectorSpec<float,3>::spread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?mul@?$VectorSpec@M$02@@IAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?mul@?$VectorSpec@M$02@@IAEXABV1@@Z PROC		; VectorSpec<float,3>::mul, COMDAT
; _this$ = ecx

; 333  : 	inline void mul(const VectorSpec<float, 3>& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mov	eax, DWORD PTR _rhs$[ebx]
; File d:\programming\mathter\mathter\vector.hpp

; 333  : 	inline void mul(const VectorSpec<float, 3>& rhs) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [eax]
	mulps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 334  : 		simd = Simd4f::mul(simd, rhs.simd);

	movups	XMMWORD PTR [ecx], xmm0

; 335  : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
?mul@?$VectorSpec@M$02@@IAEXABV1@@Z ENDP		; VectorSpec<float,3>::mul
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?add@?$VectorSpec@M$02@@IAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?add@?$VectorSpec@M$02@@IAEXABV1@@Z PROC		; VectorSpec<float,3>::add, COMDAT
; _this$ = ecx

; 339  : 	inline void add(const VectorSpec<float, 3>& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	mov	eax, DWORD PTR _rhs$[ebx]
; File d:\programming\mathter\mathter\vector.hpp

; 339  : 	inline void add(const VectorSpec<float, 3>& rhs) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [eax]
	addps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 340  : 		simd = Simd4f::add(simd, rhs.simd);

	movups	XMMWORD PTR [ecx], xmm0

; 341  : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
?add@?$VectorSpec@M$02@@IAEXABV1@@Z ENDP		; VectorSpec<float,3>::add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?mul@?$VectorSpec@M$02@@IAEXM@Z
_TEXT	SEGMENT
?mul@?$VectorSpec@M$02@@IAEXM@Z PROC			; VectorSpec<float,3>::mul, COMDAT
; _this$ = ecx
; _rhs$ = xmm1s

; 347  : 	inline void mul(float rhs) {

	movaps	xmm0, xmm1
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 348  : 		simd = Simd4f::mul(simd, rhs);

	movups	XMMWORD PTR [ecx], xmm0

; 349  : 	}

	ret	0
?mul@?$VectorSpec@M$02@@IAEXM@Z ENDP			; VectorSpec<float,3>::mul
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$VectorSpec@M$03@@QAE@MMMM@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
??0?$VectorSpec@M$03@@QAE@MMMM@Z PROC			; VectorSpec<float,4>::VectorSpec<float,4>, COMDAT
; _this$ = ecx
; _x$ = xmm1s
; _y$ = xmm2s
; _z$ = xmm3s

; 376  : 	VectorSpec(float x, float y, float z = 0, float w = 0) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	movaps	xmm4, xmm1
; File d:\programming\mathter\mathter\vector.hpp

; 376  : 	VectorSpec(float x, float y, float z = 0, float w = 0) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	movss	xmm1, DWORD PTR _w$[ebx]
	movaps	xmm0, xmm3
	unpcklps xmm4, xmm0
; File d:\programming\mathter\mathter\vector.hpp

; 378  : 	}

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	unpcklps xmm2, xmm1
	unpcklps xmm4, xmm2
; File d:\programming\mathter\mathter\vector.hpp

; 390  : 		simd = Simd4f::set(x, y, z, w);

	movups	XMMWORD PTR [ecx], xmm4

; 378  : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
??0?$VectorSpec@M$03@@QAE@MMMM@Z ENDP			; VectorSpec<float,4>::VectorSpec<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?Assign@?$VectorSpec@M$03@@IAEXMMMM@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
?Assign@?$VectorSpec@M$03@@IAEXMMMM@Z PROC		; VectorSpec<float,4>::Assign, COMDAT
; _this$ = ecx
; _x$ = xmm1s
; _y$ = xmm2s
; _z$ = xmm3s

; 389  : 	inline void Assign(float x, float y, float z = 0, float w = 0) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	movaps	xmm4, xmm1
; File d:\programming\mathter\mathter\vector.hpp

; 389  : 	inline void Assign(float x, float y, float z = 0, float w = 0) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	movss	xmm1, DWORD PTR _w$[ebx]
	movaps	xmm0, xmm3
	unpcklps xmm4, xmm0
	unpcklps xmm2, xmm1
	unpcklps xmm4, xmm2
; File d:\programming\mathter\mathter\vector.hpp

; 390  : 		simd = Simd4f::set(x, y, z, w);

	movups	XMMWORD PTR [ecx], xmm4

; 391  : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
?Assign@?$VectorSpec@M$03@@IAEXMMMM@Z ENDP		; VectorSpec<float,4>::Assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?spread@?$VectorSpec@M$03@@IAEXM@Z
_TEXT	SEGMENT
?spread@?$VectorSpec@M$03@@IAEXM@Z PROC			; VectorSpec<float,4>::spread, COMDAT
; _this$ = ecx
; _all$ = xmm1s

; 392  : 	inline void spread(float all) {

	movaps	xmm0, xmm1
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	shufps	xmm0, xmm0, 0
; File d:\programming\mathter\mathter\vector.hpp

; 393  : 		simd = Simd4f::spread(all);

	movups	XMMWORD PTR [ecx], xmm0

; 394  : 	}

	ret	0
?spread@?$VectorSpec@M$03@@IAEXM@Z ENDP			; VectorSpec<float,4>::spread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?mul@?$VectorSpec@M$03@@IAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?mul@?$VectorSpec@M$03@@IAEXABV1@@Z PROC		; VectorSpec<float,4>::mul, COMDAT
; _this$ = ecx

; 397  : 	inline void mul(const VectorSpec<float, 4>& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mov	eax, DWORD PTR _rhs$[ebx]
; File d:\programming\mathter\mathter\vector.hpp

; 397  : 	inline void mul(const VectorSpec<float, 4>& rhs) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [eax]
	mulps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 398  : 		simd = Simd4f::mul(simd, rhs.simd);

	movups	XMMWORD PTR [ecx], xmm0

; 399  : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
?mul@?$VectorSpec@M$03@@IAEXABV1@@Z ENDP		; VectorSpec<float,4>::mul
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?add@?$VectorSpec@M$03@@IAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?add@?$VectorSpec@M$03@@IAEXABV1@@Z PROC		; VectorSpec<float,4>::add, COMDAT
; _this$ = ecx

; 403  : 	inline void add(const VectorSpec<float, 4>& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	mov	eax, DWORD PTR _rhs$[ebx]
; File d:\programming\mathter\mathter\vector.hpp

; 403  : 	inline void add(const VectorSpec<float, 4>& rhs) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [eax]
	addps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 404  : 		simd = Simd4f::add(simd, rhs.simd);

	movups	XMMWORD PTR [ecx], xmm0

; 405  : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
?add@?$VectorSpec@M$03@@IAEXABV1@@Z ENDP		; VectorSpec<float,4>::add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?mul@?$VectorSpec@M$03@@IAEXM@Z
_TEXT	SEGMENT
?mul@?$VectorSpec@M$03@@IAEXM@Z PROC			; VectorSpec<float,4>::mul, COMDAT
; _this$ = ecx
; _rhs$ = xmm1s

; 411  : 	inline void mul(float rhs) {

	movaps	xmm0, xmm1
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 412  : 		simd = Simd4f::mul(simd, rhs);

	movups	XMMWORD PTR [ecx], xmm0

; 413  : 	}

	ret	0
?mul@?$VectorSpec@M$03@@IAEXM@Z ENDP			; VectorSpec<float,4>::mul
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?Cross@?$VectorSpec@M$02@@SA?AV?$Vector@M$02@@ABV2@0@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?Cross@?$VectorSpec@M$02@@SA?AV?$Vector@M$02@@ABV2@0@Z PROC ; VectorSpec<float,3>::Cross, COMDAT
; ___$ReturnUdt$ = ecx
; _lhs$ = edx

; 908  : inline Vector<float, 3> VectorSpec<float, 3>::Cross(const Vector<float, 3>& lhs, const Vector<float, 3>& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]

; 909  : 	return Vector<float, 3>(lhs.y * rhs.z - lhs.z * rhs.y,

	mov	eax, DWORD PTR _rhs$[ebx]
	movss	xmm1, DWORD PTR [edx]
	mov	DWORD PTR [esp+4], ebp
	movss	xmm7, DWORD PTR [eax+8]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [edx+8]
	mulss	xmm7, DWORD PTR [edx+4]
	movss	xmm6, DWORD PTR [eax]
	movaps	xmm2, xmm6
	mulss	xmm6, DWORD PTR [edx+4]
	mulss	xmm2, DWORD PTR [edx+8]
	subss	xmm7, xmm0
	movaps	xmm0, xmm1
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [eax+8]
	mov	eax, ecx
	subss	xmm1, xmm6
	subss	xmm2, xmm0
	xorps	xmm0, xmm0
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	unpcklps xmm7, xmm1
	unpcklps xmm2, xmm0
	unpcklps xmm7, xmm2
; File d:\programming\mathter\mathter\vector.hpp

; 311  : 		simd = Simd4f::set(x, y, z, 0);

	movups	XMMWORD PTR [ecx], xmm7

; 910  : 		lhs.z * rhs.x - lhs.x * rhs.z,
; 911  : 		lhs.x * rhs.y - lhs.y * rhs.x);
; 912  : }

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?Cross@?$VectorSpec@M$02@@SA?AV?$Vector@M$02@@ABV2@0@Z ENDP ; VectorSpec<float,3>::Cross
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$Vector@M$02@@QAE@MMM@Z
_TEXT	SEGMENT
??0?$Vector@M$02@@QAE@MMM@Z PROC			; Vector<float,3>::Vector<float,3>, COMDAT
; _this$ = ecx
; ___param0$ = xmm1s
; ___param1$ = xmm2s
; ___param2$ = xmm3s
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	movaps	xmm4, xmm1
	movaps	xmm0, xmm3
	xorps	xmm1, xmm1
	unpcklps xmm4, xmm0
	unpcklps xmm2, xmm1
	mov	eax, ecx
	unpcklps xmm4, xmm2
; File d:\programming\mathter\mathter\vector.hpp

; 311  : 		simd = Simd4f::set(x, y, z, 0);

	movups	XMMWORD PTR [ecx], xmm4
	ret	0
??0?$Vector@M$02@@QAE@MMM@Z ENDP			; Vector<float,3>::Vector<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$1$ = -12					; size = 4
tv212 = -8						; size = 4
__Freq$2$ = -4						; size = 4
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT
; ___$ReturnUdt$ = ecx

; 1002 : 		{	// get current time

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR ___$ReturnUdt$1$[ebp], ecx

; 1003 : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	ebx, eax
	mov	edi, edx
	mov	DWORD PTR __Freq$2$[ebp], ebx

; 1004 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1005 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1006 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1007 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	edi
	push	ebx
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv212[ebp], eax
	mov	ebx, edx
	call	__allmul
	push	edi
	push	DWORD PTR __Freq$2$[ebp]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	ebx
	push	DWORD PTR tv212[ebp]
	mov	esi, eax
	mov	edi, edx
	call	__allmul

; 1008 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax

; 239  : 		: _MyDur(_Other)

	mov	eax, DWORD PTR ___$ReturnUdt$1$[ebp]

; 1008 : 		return (time_point(duration(_Whole + _Part)));

	adc	edi, edx

; 239  : 		: _MyDur(_Other)

	mov	DWORD PTR [eax+4], edi

; 1009 : 		}

	pop	edi

; 239  : 		: _MyDur(_Other)

	mov	DWORD PTR [eax], esi

; 1009 : 		}

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\main.cpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\main.cpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\main.cpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
; File d:\programming\mathter\main.cpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
; File d:\programming\mathter\main.cpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
; File d:\programming\mathter\main.cpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\programming\mathter\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_mats4$ = -288						; size = 12
$T263 = -276						; size = 4
_v3$ = -272						; size = 16
_mats6$ = -268						; size = 12
_mats5$ = -256						; size = 12
_mats5$1$ = -244					; size = 4
tv2944 = -244						; size = 4
$T264 = -240						; size = 4
tv2927 = -240						; size = 4
__Freq$2$ = -236					; size = 4
__Freq$2$ = -236					; size = 4
tv2947 = -236						; size = 4
tv2945 = -236						; size = 4
tv2938 = -232						; size = 4
tv2924 = -232						; size = 4
tv2900 = -232						; size = 4
tv2870 = -232						; size = 4
$T265 = -228						; size = 4
__Freq$1$ = -228					; size = 4
__Freq$1$ = -228					; size = 4
$T145 = -228						; size = 1
$T105 = -228						; size = 1
$T63 = -228						; size = 1
tv2932 = -228						; size = 4
_mat2$ = -224						; size = 64
$T57 = -208						; size = 48
$T27 = -208						; size = 48
$T26 = -160						; size = 64
_mat4$ = -144						; size = 48
_mat1$ = -96						; size = 64
_mat3$ = -80						; size = 48
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 86   : int main() {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_main
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR __xmm@41a000004140000040c0000040000000
; File d:\programming\mathter\main.cpp

; 91   : 	cout << v3 << endl << endl;

	lea	edx, DWORD PTR _v3$[ebp]
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File d:\programming\mathter\mathter\vector.hpp

; 398  : 		simd = Simd4f::mul(simd, rhs.simd);

	movaps	XMMWORD PTR _v3$[ebp], xmm0
; File d:\programming\mathter\main.cpp

; 91   : 	cout << v3 << endl << endl;

	call	??$?6M$03@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Vector@M$03@@@Z ; operator<<<float,4>
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	movaps	xmm0, XMMWORD PTR __xmm@4040000040400000400000003f800000

; 92   : 
; 93   : 	Vector<float, 3> v(1.0f, 2.0f, 3.0f);
; 94   : 	Vector<float, 3> u(1);
; 95   : 	Vector<float, 4> w(v, 1.2f);
; 96   : 	Vector<float, 3> c(v);
; 97   : 	v.Set(1, 2, 3);
; 98   : 	w.Set(2.5f, v);
; 99   : 
; 100  : 	auto d = Vector<float, 3>::Cross(v, u);
; 101  : 
; 102  : 	using Matrix3x3 = typename std::conditional<false, PlainMat3, Matrix<float, 3, 3, eMatrixLayout::ROW_MAJOR>>::type;
; 103  : 	using Matrix4x4 = Matrix<float, 4, 4, eMatrixLayout::ROW_MAJOR>;
; 104  : 
; 105  : 
; 106  : 	// correct test mat4x4
; 107  : 	Matrix4x4 mat1;
; 108  : 	Matrix4x4 mat2;
; 109  : 
; 110  : 	mat1(0, 0) = 1;		mat1(1, 0) = 2;		mat1(2, 0) = 3;		mat1(3, 0) = 3;
; 111  : 	mat1(0, 1) = 4;		mat1(1, 1) = 5;		mat1(2, 1) = 6;		mat1(3, 1) = 6;
; 112  : 	mat1(0, 2) = 7;		mat1(1, 2) = 8;		mat1(2, 2) = 9;		mat1(3, 2) = 9;
; 113  : 	mat1(0, 3) = 7;		mat1(1, 3) = 8;		mat1(2, 3) = 9;		mat1(3, 3) = 9;
; 114  : 
; 115  : 	mat2(0, 0) = 5;		mat2(1, 0) = 4;		mat2(2, 0) = 3;		mat2(3, 0) = 3;
; 116  : 	mat2(0, 1) = 6;		mat2(1, 1) = 5;		mat2(2, 1) = 4;		mat2(3, 1) = 4;
; 117  : 	mat2(0, 2) = 7;		mat2(1, 2) = 6;		mat2(2, 2) = 5;		mat2(3, 2) = 5;
; 118  : 	mat2(0, 3) = 7;		mat2(1, 3) = 6;		mat2(2, 3) = 5;		mat2(3, 3) = 5;
; 119  : 
; 120  : 	cout << mat1 * mat2 << endl;

	lea	eax, DWORD PTR _mat2$[ebp]
	movaps	XMMWORD PTR _mat1$[ebp], xmm0
	lea	edx, DWORD PTR _mat1$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@40c0000040c0000040a0000040800000
	movaps	XMMWORD PTR _mat1$[ebp+16], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@41100000411000004100000040e00000
	movaps	XMMWORD PTR _mat1$[ebp+32], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@41100000411000004100000040e00000
	movaps	XMMWORD PTR _mat1$[ebp+48], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@40400000404000004080000040a00000
	movaps	XMMWORD PTR _mat2$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@408000004080000040a0000040c00000
	movaps	XMMWORD PTR _mat2$[ebp+16], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@40a0000040a0000040c0000040e00000
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	movaps	XMMWORD PTR _mat2$[ebp+32], xmm0
	lea	ecx, DWORD PTR $T26[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@40a0000040a0000040c0000040e00000
	push	eax
	movaps	XMMWORD PTR _mat2$[ebp+48], xmm0
	call	??$?DMM$03$03$03$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$03$03$0A@$00@@ABV0@0@Z ; operator*<float,float,4,4,4,0,0,1,1,0>
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	add	esp, 4
	mov	edx, eax
	call	??$?6M$03$03$0A@$00@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Matrix@M$03$03$0A@$00@@@Z ; operator<<<float,4,4,0,1>
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 121  : 
; 122  : 
; 123  : 	// correct test mat3x3
; 124  : 	Matrix3x3 mat3;
; 125  : 	Matrix3x3 mat4;
; 126  : 
; 127  : 	mat3(0, 0) = 1;		mat3(1, 0) = 2;		mat3(2, 0) = 3;
; 128  : 	mat3(0, 1) = 4;		mat3(1, 1) = 5;		mat3(2, 1) = 6;
; 129  : 	mat3(0, 2) = 7;		mat3(1, 2) = 8;		mat3(2, 2) = 9;
; 130  : 
; 131  : 	mat4(0, 0) = 5;		mat4(1, 0) = 4;		mat4(2, 0) = 3;
; 132  : 	mat4(0, 1) = 6;		mat4(1, 1) = 5;		mat4(2, 1) = 4;
; 133  : 	mat4(0, 2) = 7;		mat4(1, 2) = 6;		mat4(2, 2) = 5;
; 134  : 
; 135  : 	cout << mat3 * mat4 << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ecx
	lea	eax, DWORD PTR _mat4$[ebp]
	mov	DWORD PTR _mat3$[ebp], 1065353216	; 3f800000H
	push	eax
	lea	edx, DWORD PTR _mat3$[ebp]
	mov	DWORD PTR _mat3$[ebp+4], 1073741824	; 40000000H
	lea	ecx, DWORD PTR $T27[ebp]
	mov	DWORD PTR _mat3$[ebp+8], 1077936128	; 40400000H
	mov	DWORD PTR _mat3$[ebp+16], 1082130432	; 40800000H
	mov	DWORD PTR _mat3$[ebp+20], 1084227584	; 40a00000H
	mov	DWORD PTR _mat3$[ebp+24], 1086324736	; 40c00000H
	mov	DWORD PTR _mat3$[ebp+32], 1088421888	; 40e00000H
	mov	DWORD PTR _mat3$[ebp+36], 1090519040	; 41000000H
	mov	DWORD PTR _mat3$[ebp+40], 1091567616	; 41100000H
	mov	DWORD PTR _mat4$[ebp], 1084227584	; 40a00000H
	mov	DWORD PTR _mat4$[ebp+4], 1082130432	; 40800000H
	mov	DWORD PTR _mat4$[ebp+8], 1077936128	; 40400000H
	mov	DWORD PTR _mat4$[ebp+16], 1086324736	; 40c00000H
	mov	DWORD PTR _mat4$[ebp+20], 1084227584	; 40a00000H
	mov	DWORD PTR _mat4$[ebp+24], 1082130432	; 40800000H
	mov	DWORD PTR _mat4$[ebp+32], 1088421888	; 40e00000H
	mov	DWORD PTR _mat4$[ebp+36], 1086324736	; 40c00000H
	mov	DWORD PTR _mat4$[ebp+40], 1084227584	; 40a00000H
	call	??$?DMM$02$02$02$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$02$02$0A@$00@@ABV0@0@Z ; operator*<float,float,3,3,3,0,0,1,1,0>
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	add	esp, 4
	mov	edx, eax
	call	??$?6M$02$02$0A@$00@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Matrix@M$02$02$0A@$00@@@Z ; operator<<<float,3,3,0,1>
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 136  : 
; 137  : 
; 138  : 	// speed test mat4x4
; 139  : 	constexpr int count = 1000000;
; 140  : 	std::chrono::high_resolution_clock::time_point startTime;
; 141  : 	std::chrono::high_resolution_clock::time_point endTime;
; 142  : 
; 143  : 	//std::vector<Matrix4x4> mats1(count);
; 144  : 	//std::vector<Matrix4x4> mats2(count);
; 145  : 	//std::vector<Matrix4x4> mats3(count);
; 146  : 
; 147  : 	//srand(chrono::high_resolution_clock::now().time_since_epoch().count());
; 148  : 	//for (int k = 0; k < count; ++k) {
; 149  : 	//	for (int i = 0; i < 4; ++i) {
; 150  : 	//		for (int j = 0; j < 4; ++j) {
; 151  : 	//			mats1[k](i, j) = rand() % 100; 
; 152  : 	//			mats2[k](i, j) = rand() % 100;
; 153  : 	//		}
; 154  : 	//	}
; 155  : 	//}
; 156  : 
; 157  : 	//startTime = std::chrono::high_resolution_clock::now();
; 158  : 	//for (int i = 0; i < 10; ++i) {
; 159  : 	//	for (int i = 0; i < count; ++i) {
; 160  : 	//		mats3[i] = mats1[1] * mats2[i];
; 161  : 	//	}
; 162  : 	//}
; 163  : 	//endTime = std::chrono::high_resolution_clock::now();
; 164  : 
; 165  : 	//mats1 = mats2 = mats3 = {};
; 166  : 
; 167  : 	//cout << "elapsed = " << chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-6 << " us" << endl;
; 168  : 
; 169  : 
; 170  : 	// speed test mat3x3
; 171  : 	std::vector<Matrix3x3> mats4(count);

	sub	esp, 8
	lea	ecx, DWORD PTR _mats4$[ebp]
	call	??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >

; 172  : 	std::vector<Matrix3x3> mats5(count);

	sub	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _mats5$[ebp]
	call	??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >

; 173  : 	std::vector<Matrix3x3> mats6(count);

	sub	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _mats6$[ebp]
	call	??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _mats4$[ebp]
	sub	eax, DWORD PTR _mats5$[ebp]
	mov	DWORD PTR tv2932[ebp], eax
	mov	eax, DWORD PTR _mats5$[ebp]
	mov	DWORD PTR tv2924[ebp], eax
	mov	DWORD PTR tv2945[ebp], 1000000		; 000f4240H
	npad	14
$LL4@main:

; 176  : 		for (int i = 0; i < 3; ++i) {

	mov	DWORD PTR tv2927[ebp], eax
	mov	DWORD PTR tv2944[ebp], 3
$LL7@main:

; 177  : 			for (int j = 0; j < 3; ++j) {

	mov	esi, eax
	mov	edi, 3
$LL10@main:

; 178  : 				mats4[k](i, j) = rand() % 100;

	call	DWORD PTR __imp__rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	eax, DWORD PTR tv2932[ebp]
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [eax+esi], xmm0

; 179  : 				mats5[k](i, j) = rand() % 100;

	call	DWORD PTR __imp__rand
	cdq
	lea	esi, DWORD PTR [esi+16]
	mov	ecx, 100				; 00000064H
	idiv	ecx
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esi-16], xmm0
	sub	edi, 1
	jne	SHORT $LL10@main

; 176  : 		for (int i = 0; i < 3; ++i) {

	mov	eax, DWORD PTR tv2927[ebp]
	add	eax, 4
	sub	DWORD PTR tv2944[ebp], 1
	mov	DWORD PTR tv2927[ebp], eax
	jne	SHORT $LL7@main

; 174  : 
; 175  : 	for (int k = 0; k < count; ++k) {

	mov	eax, DWORD PTR tv2924[ebp]
	add	eax, 48					; 00000030H
	sub	DWORD PTR tv2945[ebp], 1
	mov	DWORD PTR tv2924[ebp], eax
	jne	$LL4@main
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono

; 1003 : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[ebp], edi
	mov	DWORD PTR __Freq$1$[ebp], esi

; 1004 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1005 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1006 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1007 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv2870[ebp], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[ebp]
	push	DWORD PTR __Freq$2$[ebp]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv2870[ebp]
	mov	esi, eax
	mov	DWORD PTR $T264[ebp], edx
	call	__allmul
	mov	ecx, DWORD PTR _mats4$[ebp]

; 1008 : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax
	mov	eax, DWORD PTR _mats5$[ebp]
	adc	DWORD PTR $T264[ebp], edx
	add	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _mats6$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T263[ebp], esi
	mov	DWORD PTR tv2938[ebp], ecx
	mov	DWORD PTR _mats5$1$[ebp], eax

; 1003 : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	DWORD PTR tv2947[ebp], 10		; 0000000aH
$LL13@main:
	mov	esi, edx
	mov	edi, 1000000				; 000f4240H
	npad	4
$LL16@main:
; File d:\programming\mathter\main.cpp

; 187  : 			mats6[i] = mats4[1] * mats5[i];

	add	eax, esi
	mov	edx, ecx
	push	eax
	lea	ecx, DWORD PTR $T57[ebp]
	call	??$?DMM$02$02$02$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$02$02$0A@$00@@ABV0@0@Z ; operator*<float,float,3,3,3,0,0,1,1,0>
	mov	ecx, DWORD PTR tv2938[ebp]
	add	esp, 4
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [esi+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	mov	eax, DWORD PTR _mats5$1$[ebp]
	movups	XMMWORD PTR [esi+32], xmm0
	add	esi, 48					; 00000030H
	sub	edi, 1
	jne	SHORT $LL16@main

; 180  : 			}
; 181  : 		}
; 182  : 	}
; 183  : 
; 184  : 	startTime = std::chrono::high_resolution_clock::now();
; 185  : 	for (int i = 0; i < 10; ++i) {

	sub	DWORD PTR tv2947[ebp], 1
	mov	edx, DWORD PTR _mats6$[ebp]
	jne	SHORT $LL13@main
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono

; 1003 : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	edi, eax
	mov	esi, edx
	mov	DWORD PTR __Freq$2$[ebp], edi
	mov	DWORD PTR __Freq$1$[ebp], esi

; 1004 : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter
	push	ebx

; 1005 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1006 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1007 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv2900[ebp], eax
	mov	edi, edx
	call	__allmul
	push	DWORD PTR __Freq$1$[ebp]
	push	DWORD PTR __Freq$2$[ebp]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edi
	push	DWORD PTR tv2900[ebp]
	mov	DWORD PTR $T265[ebp], eax
	mov	esi, edx
	call	__allmul

; 1008 : 		return (time_point(duration(_Whole + _Part)));

	mov	edi, DWORD PTR $T265[ebp]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1435 : 		_Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

	lea	ecx, DWORD PTR _mats6$[ebp]
	mov	BYTE PTR $T63[ebp], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono

; 1008 : 		return (time_point(duration(_Whole + _Part)));

	add	edi, eax
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1435 : 		_Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

	push	DWORD PTR $T63[ebp]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono

; 1008 : 		return (time_point(duration(_Whole + _Part)));

	adc	esi, edx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1435 : 		_Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

	push	0
	push	0
	call	??$_Assign_range@PBV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPBV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> const *>

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T105[ebp], 0
	lea	ecx, DWORD PTR _mats5$[ebp]
	push	DWORD PTR $T105[ebp]
	push	DWORD PTR _mats6$[ebp+4]
	push	DWORD PTR _mats6$[ebp]
	call	??$_Assign_range@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> *>
	mov	BYTE PTR $T145[ebp], 0
	lea	ecx, DWORD PTR _mats4$[ebp]
	push	DWORD PTR $T145[ebp]
	push	DWORD PTR _mats5$[ebp+4]
	push	DWORD PTR _mats5$[ebp]
	call	??$_Assign_range@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> *>
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono

; 349  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	edi, DWORD PTR $T263[ebp]
; File d:\programming\mathter\main.cpp

; 194  : 	cout << "elapsed = " << chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-6 << " us" << endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono

; 349  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sbb	esi, DWORD PTR $T264[ebp]
	push	ecx
; File d:\programming\mathter\main.cpp

; 194  : 	cout << "elapsed = " << chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-6 << " us" << endl;

	mov	edx, esi
	mov	ecx, edi
	call	__ltod3
	mulsd	xmm0, QWORD PTR __real@3eb0c6f7a0b5ed8d
	sub	esp, 8
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET $SG4294967236
	movsd	QWORD PTR [esp], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	edx, OFFSET $SG4294967237
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	esi, DWORD PTR _mats6$[ebp]
	test	esi, esi
	je	SHORT $LN944@main

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _mats6$[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, esi
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	esi
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::deallocate
$LN944@main:

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	esi, DWORD PTR _mats5$[ebp]
	test	esi, esi
	je	SHORT $LN1037@main

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _mats5$[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, esi
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	esi
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::deallocate
$LN1037@main:

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	esi, DWORD PTR _mats4$[ebp]
	test	esi, esi
	je	SHORT $LN1278@main

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _mats4$[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, esi
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	esi
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::deallocate
$LN1278@main:
; File d:\programming\mathter\main.cpp

; 196  : 	return 0;

	xor	eax, eax

; 197  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
	lea	ecx, DWORD PTR _mats4$[ebp]
	jmp	??1?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::~vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >
__unwindfunclet$_main$1:
	lea	ecx, DWORD PTR _mats5$[ebp]
	jmp	??1?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::~vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >
__unwindfunclet$_main$2:
	lea	ecx, DWORD PTR _mats6$[ebp]
	jmp	??1?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::~vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >
__ehhandler$_main:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?DMM$03$03$03$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$03$03$0A@$00@@ABV0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$1$ = -8					; size = 4
tv833 = -4						; size = 4
_lhs$1$ = -4						; size = 4
_rhs$ = 8						; size = 4
??$?DMM$03$03$03$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$03$03$0A@$00@@ABV0@0@Z PROC ; operator*<float,float,4,4,4,0,0,1,1,0>, COMDAT
; ___$ReturnUdt$ = ecx
; _lhs$ = edx

; 153  : auto operator*(const Matrix<T, Match, Rows1, Layout1, Order1>& lhs, const Matrix<U, Columns2, Match, Layout2, Order2>& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 163  : 		for (int y = 0; y < Rows1; ++y) {

	mov	esi, edx
	mov	DWORD PTR _lhs$1$[ebp], edx
	mov	edx, DWORD PTR _rhs$[ebx]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR ___$ReturnUdt$1$[ebp], ecx
	sub	esi, ecx
	mov	edi, 4
	npad	1
$LL4@operator:
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	movss	xmm1, DWORD PTR [esi+eax]
; File d:\programming\mathter\mathter\matrix.hpp

; 163  : 		for (int y = 0; y < Rows1; ++y) {

	lea	eax, DWORD PTR [eax+16]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [edx]

; 69   : 		res.reg = _mm_set1_ps(value);

	shufps	xmm1, xmm1, 0

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm0, xmm1
; File d:\programming\mathter\mathter\matrix.hpp

; 165  : 			result.stripes[y] = scalarMultiplier * rhs.stripes[0];

	movups	XMMWORD PTR [eax-16], xmm0
	sub	edi, 1
	jne	SHORT $LL4@operator

; 166  : 		}
; 167  : 		for (int x = 1; x < Columns2; ++x) {

	mov	edi, DWORD PTR _lhs$1$[ebp]
	add	edi, 4
	mov	DWORD PTR tv833[ebp], 3
	add	edx, 16					; 00000010H
	npad	5
$LL7@operator:

; 168  : 			for (int y = 0; y < Rows1; ++y) {

	mov	eax, ecx
	mov	esi, 4
	mov	ecx, edi
	npad	7
$LL10@operator:
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	movss	xmm1, DWORD PTR [ecx]
; File d:\programming\mathter\mathter\matrix.hpp

; 168  : 			for (int y = 0; y < Rows1; ++y) {

	add	ecx, 16					; 00000010H
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [edx]

; 69   : 		res.reg = _mm_set1_ps(value);

	shufps	xmm1, xmm1, 0

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm0, xmm1

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm0, XMMWORD PTR [eax]
; File d:\programming\mathter\mathter\vector.hpp

; 404  : 		simd = Simd4f::add(simd, rhs.simd);

	movups	XMMWORD PTR [eax], xmm0
; File d:\programming\mathter\mathter\matrix.hpp

; 168  : 			for (int y = 0; y < Rows1; ++y) {

	add	eax, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL10@operator

; 166  : 		}
; 167  : 		for (int x = 1; x < Columns2; ++x) {

	mov	ecx, DWORD PTR ___$ReturnUdt$1$[ebp]
	add	edx, 16					; 00000010H
	add	edi, 4
	sub	DWORD PTR tv833[ebp], 1
	jne	SHORT $LL7@operator

; 169  : 				scalarMultiplier.Spread(lhs(x, y));
; 170  : 				result.stripes[y] += scalarMultiplier * rhs.stripes[x];
; 171  : 			}
; 172  : 		}
; 173  : 	}
; 174  : 	// With more than 4 sized vector ops, SSE spread will be used by vectors internally.
; 175  : 	else {
; 176  : 		ElemT scalarMultiplier;
; 177  : 		for (int y = 0; y < Rows1; ++y) {
; 178  : 			scalarMultiplier = lhs(0, y);
; 179  : 			result.stripes[y] = scalarMultiplier * rhs.stripes[y];
; 180  : 		}
; 181  : 		for (int x = 1; x < Columns2; ++x) {
; 182  : 			for (int y = 0; y < Rows1; ++y) {
; 183  : 				scalarMultiplier = lhs(x, y);
; 184  : 				result.stripes[y] += scalarMultiplier * rhs.stripes[y];
; 185  : 			}
; 186  : 		}
; 187  : 	}
; 188  : 	return result;
; 189  : }

	pop	edi
	mov	eax, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
??$?DMM$03$03$03$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$03$03$0A@$00@@ABV0@0@Z ENDP ; operator*<float,float,4,4,4,0,0,1,1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?DMM$02$02$02$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$02$02$0A@$00@@ABV0@0@Z
_TEXT	SEGMENT
$T13 = -32						; size = 16
$T5 = -32						; size = 16
___$ReturnUdt$1$ = -8					; size = 4
tv812 = -4						; size = 4
_lhs$1$ = -4						; size = 4
_rhs$ = 8						; size = 4
??$?DMM$02$02$02$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$02$02$0A@$00@@ABV0@0@Z PROC ; operator*<float,float,3,3,3,0,0,1,1,0>, COMDAT
; ___$ReturnUdt$ = ecx
; _lhs$ = edx

; 153  : auto operator*(const Matrix<T, Match, Rows1, Layout1, Order1>& lhs, const Matrix<U, Columns2, Match, Layout2, Order2>& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 163  : 		for (int y = 0; y < Rows1; ++y) {

	mov	esi, edx
	mov	DWORD PTR _lhs$1$[ebp], edx
	mov	edx, DWORD PTR _rhs$[ebx]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR ___$ReturnUdt$1$[ebp], ecx
	sub	esi, ecx
	mov	edi, 3
	npad	1
$LL4@operator:
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	movss	xmm1, DWORD PTR [esi+eax]
; File d:\programming\mathter\mathter\matrix.hpp

; 163  : 		for (int y = 0; y < Rows1; ++y) {

	lea	eax, DWORD PTR [eax+16]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	shufps	xmm1, xmm1, 0
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	movss	DWORD PTR $T5[ebp], xmm1
	movaps	xmm0, xmm1
	shufps	xmm0, xmm1, 85				; 00000055H
	movss	DWORD PTR $T5[ebp+4], xmm0
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [edx]
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	movss	DWORD PTR $T5[ebp+8], xmm1
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm0, XMMWORD PTR $T5[ebp]
; File d:\programming\mathter\mathter\vector.hpp

; 334  : 		simd = Simd4f::mul(simd, rhs.simd);

	movaps	XMMWORD PTR $T5[ebp], xmm0
; File d:\programming\mathter\mathter\matrix.hpp

; 165  : 			result.stripes[y] = scalarMultiplier * rhs.stripes[0];

	movups	XMMWORD PTR [eax-16], xmm0
	sub	edi, 1
	jne	SHORT $LL4@operator

; 166  : 		}
; 167  : 		for (int x = 1; x < Columns2; ++x) {

	mov	edi, DWORD PTR _lhs$1$[ebp]
	add	edi, 4
	mov	DWORD PTR tv812[ebp], 2
	add	edx, 16					; 00000010H
$LL7@operator:

; 168  : 			for (int y = 0; y < Rows1; ++y) {

	mov	eax, ecx
	mov	esi, 3
	mov	ecx, edi
	npad	1
$LL10@operator:
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	movss	xmm1, DWORD PTR [ecx]
; File d:\programming\mathter\mathter\matrix.hpp

; 168  : 			for (int y = 0; y < Rows1; ++y) {

	add	ecx, 16					; 00000010H
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	shufps	xmm1, xmm1, 0
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	movaps	xmm0, xmm1
	movss	DWORD PTR $T13[ebp], xmm1
	shufps	xmm0, xmm1, 85				; 00000055H
	movss	DWORD PTR $T13[ebp+8], xmm1
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movups	xmm1, XMMWORD PTR [edx]
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	movss	DWORD PTR $T13[ebp+4], xmm0
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm1, XMMWORD PTR $T13[ebp]

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [eax]
	addps	xmm0, xmm1
; File d:\programming\mathter\mathter\vector.hpp

; 334  : 		simd = Simd4f::mul(simd, rhs.simd);

	movaps	XMMWORD PTR $T13[ebp], xmm1

; 340  : 		simd = Simd4f::add(simd, rhs.simd);

	movups	XMMWORD PTR [eax], xmm0
; File d:\programming\mathter\mathter\matrix.hpp

; 168  : 			for (int y = 0; y < Rows1; ++y) {

	add	eax, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL10@operator

; 166  : 		}
; 167  : 		for (int x = 1; x < Columns2; ++x) {

	mov	ecx, DWORD PTR ___$ReturnUdt$1$[ebp]
	add	edx, 16					; 00000010H
	add	edi, 4
	sub	DWORD PTR tv812[ebp], 1
	jne	SHORT $LL7@operator

; 169  : 				scalarMultiplier.Spread(lhs(x, y));
; 170  : 				result.stripes[y] += scalarMultiplier * rhs.stripes[x];
; 171  : 			}
; 172  : 		}
; 173  : 	}
; 174  : 	// With more than 4 sized vector ops, SSE spread will be used by vectors internally.
; 175  : 	else {
; 176  : 		ElemT scalarMultiplier;
; 177  : 		for (int y = 0; y < Rows1; ++y) {
; 178  : 			scalarMultiplier = lhs(0, y);
; 179  : 			result.stripes[y] = scalarMultiplier * rhs.stripes[y];
; 180  : 		}
; 181  : 		for (int x = 1; x < Columns2; ++x) {
; 182  : 			for (int y = 0; y < Rows1; ++y) {
; 183  : 				scalarMultiplier = lhs(x, y);
; 184  : 				result.stripes[y] += scalarMultiplier * rhs.stripes[y];
; 185  : 			}
; 186  : 		}
; 187  : 	}
; 188  : 	return result;
; 189  : }

	pop	edi
	mov	eax, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
??$?DMM$02$02$02$0A@$0A@$00$00$0A@@@YA?AV?$Matrix@M$02$02$0A@$00@@ABV0@0@Z ENDP ; operator*<float,float,3,3,3,0,0,1,1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$Vector@M$03@@QAE@MMMM@Z
_TEXT	SEGMENT
___param3$ = 8						; size = 4
??0?$Vector@M$03@@QAE@MMMM@Z PROC			; Vector<float,4>::Vector<float,4>, COMDAT
; _this$ = ecx
; ___param0$ = xmm1s
; ___param1$ = xmm2s
; ___param2$ = xmm3s
	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	movaps	xmm4, xmm1
	mov	DWORD PTR [esp+4], ebp
	movss	xmm1, DWORD PTR ___param3$[ebx]
	movaps	xmm0, xmm3
	unpcklps xmm4, xmm0
	mov	eax, ecx
	unpcklps xmm2, xmm1
	unpcklps xmm4, xmm2
; File d:\programming\mathter\mathter\vector.hpp

; 390  : 		simd = Simd4f::set(x, y, z, w);

	movups	XMMWORD PTR [ecx], xmm4
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
??0?$Vector@M$03@@QAE@MMMM@Z ENDP			; Vector<float,4>::Vector<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0?$Matrix@M$03$03$0A@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$Matrix@M$03$03$0A@$00@@QAE@XZ PROC			; Matrix<float,4,4,0,1>::Matrix<float,4,4,0,1>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	0
??0?$Matrix@M$03$03$0A@$00@@QAE@XZ ENDP			; Matrix<float,4,4,0,1>::Matrix<float,4,4,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0?$MatrixData@M$03$03$0A@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$MatrixData@M$03$03$0A@$00@@QAE@XZ PROC		; MatrixData<float,4,4,0,1>::MatrixData<float,4,4,0,1>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	0
??0?$MatrixData@M$03$03$0A@$00@@QAE@XZ ENDP		; MatrixData<float,4,4,0,1>::MatrixData<float,4,4,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0?$Matrix@M$03$03$0A@$00@@QAE@$$QAV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$Matrix@M$03$03$0A@$00@@QAE@$$QAV0@@Z PROC		; Matrix<float,4,4,0,1>::Matrix<float,4,4,0,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR ___that$[ebp]
	mov	esi, ecx
	call	??0?$MatrixData@M$03$03$0A@$00@@QAE@$$QAV0@@Z
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$Matrix@M$03$03$0A@$00@@QAE@$$QAV0@@Z ENDP		; Matrix<float,4,4,0,1>::Matrix<float,4,4,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$MatrixData@M$03$03$0A@$00@@QAE@$$QAV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$MatrixData@M$03$03$0A@$00@@QAE@$$QAV0@@Z PROC	; MatrixData<float,4,4,0,1>::MatrixData<float,4,4,0,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx
	mov	ecx, DWORD PTR ___that$[ebp]
	push	esi
	push	edi
	mov	edi, 4
	lea	esi, DWORD PTR [ecx+12]
	sub	ecx, ebx
	lea	edx, DWORD PTR [ebx+8]
	npad	8
$LL4@MatrixData:

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [esi-12]
	lea	esi, DWORD PTR [esi+16]
	mov	DWORD PTR [edx-8], eax
	lea	edx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [esi-24]
	mov	DWORD PTR [edx-20], eax
	mov	eax, DWORD PTR [ecx+edx-16]
	mov	DWORD PTR [edx-16], eax
	mov	eax, DWORD PTR [esi-16]
	mov	DWORD PTR [edx-12], eax
	sub	edi, 1
	jne	SHORT $LL4@MatrixData
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
??0?$MatrixData@M$03$03$0A@$00@@QAE@$$QAV0@@Z ENDP	; MatrixData<float,4,4,0,1>::MatrixData<float,4,4,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0?$Matrix@M$02$02$0A@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$Matrix@M$02$02$0A@$00@@QAE@XZ PROC			; Matrix<float,3,3,0,1>::Matrix<float,3,3,0,1>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	0
??0?$Matrix@M$02$02$0A@$00@@QAE@XZ ENDP			; Matrix<float,3,3,0,1>::Matrix<float,3,3,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0?$MatrixData@M$02$02$0A@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$MatrixData@M$02$02$0A@$00@@QAE@XZ PROC		; MatrixData<float,3,3,0,1>::MatrixData<float,3,3,0,1>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	0
??0?$MatrixData@M$02$02$0A@$00@@QAE@XZ ENDP		; MatrixData<float,3,3,0,1>::MatrixData<float,3,3,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$Matrix@M$02$02$0A@$00@@QAE@$$QAV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$Matrix@M$02$02$0A@$00@@QAE@$$QAV0@@Z PROC		; Matrix<float,3,3,0,1>::Matrix<float,3,3,0,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, esi
	push	edi
	mov	edi, 3
	lea	edx, DWORD PTR [ebx+8]
	sub	ecx, ebx
$LL6@Matrix:

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+16]
	mov	DWORD PTR [edx-8], eax
	lea	edx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [esi-12]
	mov	DWORD PTR [edx-20], eax
	mov	eax, DWORD PTR [ecx+edx-16]
	mov	DWORD PTR [edx-16], eax
	sub	edi, 1
	jne	SHORT $LL6@Matrix
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
??0?$Matrix@M$02$02$0A@$00@@QAE@$$QAV0@@Z ENDP		; Matrix<float,3,3,0,1>::Matrix<float,3,3,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$MatrixData@M$02$02$0A@$00@@QAE@$$QAV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$MatrixData@M$02$02$0A@$00@@QAE@$$QAV0@@Z PROC	; MatrixData<float,3,3,0,1>::MatrixData<float,3,3,0,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, esi
	push	edi
	mov	edi, 3
	lea	edx, DWORD PTR [ebx+8]
	sub	ecx, ebx
$LL4@MatrixData:

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+16]
	mov	DWORD PTR [edx-8], eax
	lea	edx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [esi-12]
	mov	DWORD PTR [edx-20], eax
	mov	eax, DWORD PTR [ecx+edx-16]
	mov	DWORD PTR [edx-16], eax
	sub	edi, 1
	jne	SHORT $LL4@MatrixData
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
??0?$MatrixData@M$02$02$0A@$00@@QAE@$$QAV0@@Z ENDP	; MatrixData<float,3,3,0,1>::MatrixData<float,3,3,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___n$ = 8						; size = 4
___f$ = 12						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
; ___t$ = ecx
; ___s$dead$ = edx
	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	push	edi
	mov	edi, ecx
	npad	2
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	8
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
___s$dead$ = 8						; size = 4
___n$ = 12						; size = 4
___f$ = 16						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
; ___t$ = ecx
; ___u$ = edx
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, edx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR ___n$[ebp]
	sub	ebx, esi
	npad	1
$LL2@vector:
	push	esi
	lea	ecx, DWORD PTR [ebx+esi]
	call	DWORD PTR ___f$[ebp]
	add	esi, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	12					; 0000000cH
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\initializer_list
;	COMDAT ??0?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@XZ PROC ; std::initializer_list<Matrix<float,3,3,0,1> >::initializer_list<Matrix<float,3,3,0,1> >, COMDAT
; _this$ = ecx

; 29   : 		: _First(0), _Last(0)

	mov	DWORD PTR [ecx], 0

; 31   : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@XZ ENDP ; std::initializer_list<Matrix<float,3,3,0,1> >::initializer_list<Matrix<float,3,3,0,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV?$Matrix@M$02$02$0A@$00@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV?$Matrix@M$02$02$0A@$00@@I@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::operator[], COMDAT
; _this$ = ecx

; 1736 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 1737 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1738 : 		if (size() <= _Pos)
; 1739 : 			{	// report error
; 1740 : 			_DEBUG_ERROR("vector subscript out of range");
; 1741 : 			}
; 1742 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1743 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1744 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1745 : 
; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 1747 : 		}

	pop	ebp
	ret	4
??A?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV?$Matrix@M$02$02$0A@$00@@I@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??4?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV01@V?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@1@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Ilist$ = 8						; size = 8
??4?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV01@V?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@1@@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::operator=, COMDAT
; _this$ = ecx

; 1434 : 		{	// assign initializer_list

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 1435 : 		_Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

	mov	BYTE PTR $T1[ebp], 0
	mov	esi, ecx
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Ilist$[ebp+4]
	push	DWORD PTR __Ilist$[ebp]
	call	??$_Assign_range@PBV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPBV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> const *>

; 1436 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1437 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??4?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV01@V?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@1@@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??4?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T39 = 8						; size = 1
__Right$ = 8						; size = 4
??4?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::operator=, COMDAT
; _this$ = ecx

; 1414 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp

; 1415 : 		if (this != _STD addressof(_Right))

	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, ecx
	cmp	esi, eax
	je	SHORT $LN128@operator

; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T39[ebp], 0
	push	DWORD PTR $T39[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$_Assign_range@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> *>
$LN128@operator:

; 1416 : 			{	// different, assign it
; 1417 : #pragma warning(push)
; 1418 : #pragma warning(disable: 4127)	// conditional expression is constant
; 1419 : 			if (_Alty::propagate_on_container_copy_assignment::value && this->_Getal() != _Right._Getal())
; 1420 : 				{	// reload array
; 1421 : 				_Tidy();
; 1422 : 				}
; 1423 : #pragma warning(pop)
; 1424 : 
; 1425 : 			this->_Copy_alloc(_Right._Getal());
; 1426 : 
; 1427 : 			assign(_Right._Myfirst(), _Right._Mylast());
; 1428 : 			}
; 1429 : 
; 1430 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1431 : 		}

	pop	ebp
	ret	4
??4?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::~vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >, COMDAT
; _this$ = ecx

; 891  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ecx
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	ecx
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::deallocate

; 1953 : 
; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 892  : 		_Tidy();
; 893  : 		}

	ret	0
??1?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::~vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z
_TEXT	SEGMENT
$T41 = -20						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >, COMDAT
; _this$ = ecx

; 732  : 		{	// construct from _Count * _Ty(), optional allocator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	push	1000000					; 000f4240H
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	call	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::allocate
	mov	DWORD PTR [esi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [esi]

; 733  : 		if (_Buy(_Count))
; 734  : 			{	// nonzero, fill it
; 735  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	add	eax, 48000000				; 02dc6c00H
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T41[ebp]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	DWORD PTR [esi+8], eax
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	??$_Uninitialized_default_fill_n1@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,0,1> *,unsigned int,std::allocator<Matrix<float,3,3,0,1> > >
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 736  : 			this->_Mylast() = _Udefault(this->_Myfirst(), _Count);

	mov	DWORD PTR [esi+4], eax
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 8
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 742  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z$0:

; 737  : 			_CATCH_ALL
; 738  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXXZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Tidy

; 739  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN153@vector:
$LN152@vector:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@IABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@XZ PROC ; std::allocator<Matrix<float,3,3,0,1> >::allocator<Matrix<float,3,3,0,1> >, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@XZ ENDP ; std::allocator<Matrix<float,3,3,0,1> >::allocator<Matrix<float,3,3,0,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$03$03$0A@$00@@QBEMHH@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
??R?$Matrix@M$03$03$0A@$00@@QBEMHH@Z PROC		; Matrix<float,4,4,0,1>::operator(), COMDAT
; _this$ = ecx

; 81   : 	T operator()(int col, int row) const {

	push	ebp
	mov	ebp, esp

; 82   : 		return GetElement(col, row);

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	movss	xmm0, DWORD PTR [ecx+eax*4]

; 83   : 	}

	pop	ebp
	ret	8
??R?$Matrix@M$03$03$0A@$00@@QBEMHH@Z ENDP		; Matrix<float,4,4,0,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$03$03$0A@$00@@QAEAAMHH@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
??R?$Matrix@M$03$03$0A@$00@@QAEAAMHH@Z PROC		; Matrix<float,4,4,0,1>::operator(), COMDAT
; _this$ = ecx

; 78   : 	T& operator()(int col, int row) {

	push	ebp
	mov	ebp, esp

; 79   : 		return GetElement(col, row);

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
; File d:\programming\mathter\mathter\vector.hpp

; 578  : 		return data[idx];

	lea	eax, DWORD PTR [ecx+eax*4]
; File d:\programming\mathter\mathter\matrix.hpp

; 80   : 	}

	pop	ebp
	ret	8
??R?$Matrix@M$03$03$0A@$00@@QAEAAMHH@Z ENDP		; Matrix<float,4,4,0,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$02$02$0A@$00@@QBEMHH@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
??R?$Matrix@M$02$02$0A@$00@@QBEMHH@Z PROC		; Matrix<float,3,3,0,1>::operator(), COMDAT
; _this$ = ecx

; 81   : 	T operator()(int col, int row) const {

	push	ebp
	mov	ebp, esp

; 82   : 		return GetElement(col, row);

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	movss	xmm0, DWORD PTR [ecx+eax*4]

; 83   : 	}

	pop	ebp
	ret	8
??R?$Matrix@M$02$02$0A@$00@@QBEMHH@Z ENDP		; Matrix<float,3,3,0,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$02$02$0A@$00@@QAEAAMHH@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
??R?$Matrix@M$02$02$0A@$00@@QAEAAMHH@Z PROC		; Matrix<float,3,3,0,1>::operator(), COMDAT
; _this$ = ecx

; 78   : 	T& operator()(int col, int row) {

	push	ebp
	mov	ebp, esp

; 79   : 		return GetElement(col, row);

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
; File d:\programming\mathter\mathter\vector.hpp

; 578  : 		return data[idx];

	lea	eax, DWORD PTR [ecx+eax*4]
; File d:\programming\mathter\mathter\matrix.hpp

; 80   : 	}

	pop	ebp
	ret	8
??R?$Matrix@M$02$02$0A@$00@@QAEAAMHH@Z ENDP		; Matrix<float,3,3,0,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??Y?$Vector@M$03@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??Y?$Vector@M$03@@QAEAAV0@ABV0@@Z PROC			; Vector<float,4>::operator+=, COMDAT
; _this$ = ecx

; 649  : 	inline Vector& operator+=(const Vector& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	mov	eax, DWORD PTR _rhs$[ebx]
; File d:\programming\mathter\mathter\vector.hpp

; 649  : 	inline Vector& operator+=(const Vector& rhs) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [eax]
; File d:\programming\mathter\mathter\vector.hpp

; 651  : 		return *this;

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 404  : 		simd = Simd4f::add(simd, rhs.simd);

	movups	XMMWORD PTR [ecx], xmm0

; 652  : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
??Y?$Vector@M$03@@QAEAAV0@ABV0@@Z ENDP			; Vector<float,4>::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?Spread@?$Vector@M$03@@QAEAAV1@M@Z
_TEXT	SEGMENT
?Spread@?$Vector@M$03@@QAEAAV1@M@Z PROC			; Vector<float,4>::Spread, COMDAT
; _this$ = ecx
; _all$ = xmm1s

; 564  : 	Vector& Spread(T all) {

	movaps	xmm0, xmm1

; 565  : 		VectorSpec<T, D>::spread(all);
; 566  : 		return *this;

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	shufps	xmm0, xmm0, 0
; File d:\programming\mathter\mathter\vector.hpp

; 393  : 		simd = Simd4f::spread(all);

	movups	XMMWORD PTR [ecx], xmm0

; 567  : 	}

	ret	0
?Spread@?$Vector@M$03@@QAEAAV1@M@Z ENDP			; Vector<float,4>::Spread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$Vector@M$03@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0?$Vector@M$03@@QAE@ABV0@@Z PROC			; Vector<float,4>::Vector<float,4>, COMDAT
; _this$ = ecx

; 526  : 	Vector(const Vector& rhs) {

	push	ebp
	mov	ebp, esp

; 778  : 			data[i] = rhs.data[i];

	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 527  : 		// message("Vector(copy)");
; 528  : 		Assign(rhs);
; 529  : 	}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$Vector@M$03@@QAE@ABV0@@Z ENDP			; Vector<float,4>::Vector<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$Vector@M$03@@QAE@XZ
_TEXT	SEGMENT
??0?$Vector@M$03@@QAE@XZ PROC				; Vector<float,4>::Vector<float,4>, COMDAT
; _this$ = ecx

; 500  : 		// message("Vector = default");
; 501  : 	};

	mov	eax, ecx
	ret	0
??0?$Vector@M$03@@QAE@XZ ENDP				; Vector<float,4>::Vector<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; _this$ = ecx

; 240  : 		{	// construct from a duration

	push	ebp
	mov	ebp, esp

; 239  : 		: _MyDur(_Other)

	mov	edx, DWORD PTR __Other$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 241  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@XZ
_TEXT	SEGMENT
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; _this$ = ecx

; 112  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx], 0

; 236  : 		}

	mov	eax, ecx

; 112  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx+4], 0

; 236  : 		}

	ret	0
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 131  : 		return (_MyRep);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 132  : 		}

	ret	0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??Y?$Vector@M$02@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??Y?$Vector@M$02@@QAEAAV0@ABV0@@Z PROC			; Vector<float,3>::operator+=, COMDAT
; _this$ = ecx

; 649  : 	inline Vector& operator+=(const Vector& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	mov	eax, DWORD PTR _rhs$[ebx]
; File d:\programming\mathter\mathter\vector.hpp

; 649  : 	inline Vector& operator+=(const Vector& rhs) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [eax]
; File d:\programming\mathter\mathter\vector.hpp

; 651  : 		return *this;

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 340  : 		simd = Simd4f::add(simd, rhs.simd);

	movups	XMMWORD PTR [ecx], xmm0

; 652  : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
??Y?$Vector@M$02@@QAEAAV0@ABV0@@Z ENDP			; Vector<float,3>::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?Spread@?$Vector@M$02@@QAEAAV1@M@Z
_TEXT	SEGMENT
?Spread@?$Vector@M$02@@QAEAAV1@M@Z PROC			; Vector<float,3>::Spread, COMDAT
; _this$ = ecx
; _all$ = xmm1s

; 564  : 	Vector& Spread(T all) {

	movaps	xmm0, xmm1

; 565  : 		VectorSpec<T, D>::spread(all);
; 566  : 		return *this;

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	shufps	xmm0, xmm0, 0
; File d:\programming\mathter\mathter\vector.hpp

; 329  : 		simd = Simd4f::spread(all);

	movups	XMMWORD PTR [ecx], xmm0

; 567  : 	}

	ret	0
?Spread@?$Vector@M$02@@QAEAAV1@M@Z ENDP			; Vector<float,3>::Spread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$Vector@M$02@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0?$Vector@M$02@@QAE@ABV0@@Z PROC			; Vector<float,3>::Vector<float,3>, COMDAT
; _this$ = ecx

; 526  : 	Vector(const Vector& rhs) {

	push	ebp
	mov	ebp, esp

; 778  : 			data[i] = rhs.data[i];

	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 527  : 		// message("Vector(copy)");
; 528  : 		Assign(rhs);
; 529  : 	}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$Vector@M$02@@QAE@ABV0@@Z ENDP			; Vector<float,3>::Vector<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$Vector@M$02@@QAE@M@Z
_TEXT	SEGMENT
??0?$Vector@M$02@@QAE@M@Z PROC				; Vector<float,3>::Vector<float,3>, COMDAT
; _this$ = ecx
; _all$ = xmm1s

; 507  : 	explicit Vector(T all) {

	movaps	xmm0, xmm1

; 508  : 		// message("Vector(all)");
; 509  : 		VectorSpec<T, D>::spread(all);
; 510  : 	}

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 69   : 		res.reg = _mm_set1_ps(value);

	shufps	xmm0, xmm0, 0
; File d:\programming\mathter\mathter\vector.hpp

; 329  : 		simd = Simd4f::spread(all);

	movups	XMMWORD PTR [ecx], xmm0

; 508  : 		// message("Vector(all)");
; 509  : 		VectorSpec<T, D>::spread(all);
; 510  : 	}

	ret	0
??0?$Vector@M$02@@QAE@M@Z ENDP				; Vector<float,3>::Vector<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$Vector@M$02@@QAE@XZ
_TEXT	SEGMENT
??0?$Vector@M$02@@QAE@XZ PROC				; Vector<float,3>::Vector<float,3>, COMDAT
; _this$ = ecx

; 500  : 		// message("Vector = default");
; 501  : 	};

	mov	eax, ecx
	ret	0
??0?$Vector@M$02@@QAE@XZ ENDP				; Vector<float,3>::Vector<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\initializer_list
;	COMDAT ?end@?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QBEPBV?$Matrix@M$02$02$0A@$00@@XZ
_TEXT	SEGMENT
?end@?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QBEPBV?$Matrix@M$02$02$0A@$00@@XZ PROC ; std::initializer_list<Matrix<float,3,3,0,1> >::end, COMDAT
; _this$ = ecx

; 46   : 		return (_Last);

	mov	eax, DWORD PTR [ecx+4]

; 47   : 		}

	ret	0
?end@?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QBEPBV?$Matrix@M$02$02$0A@$00@@XZ ENDP ; std::initializer_list<Matrix<float,3,3,0,1> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\initializer_list
;	COMDAT ?begin@?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QBEPBV?$Matrix@M$02$02$0A@$00@@XZ
_TEXT	SEGMENT
?begin@?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QBEPBV?$Matrix@M$02$02$0A@$00@@XZ PROC ; std::initializer_list<Matrix<float,3,3,0,1> >::begin, COMDAT
; _this$ = ecx

; 41   : 		return (_First);

	mov	eax, DWORD PTR [ecx]

; 42   : 		}

	ret	0
?begin@?$initializer_list@V?$Matrix@M$02$02$0A@$00@@@std@@QBEPBV?$Matrix@M$02$02$0A@$00@@XZ ENDP ; std::initializer_list<Matrix<float,3,3,0,1> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Copy_alloc, COMDAT
; _this$dead$ = ecx

; 521  : 		_Pocca(_Getal(), _Al);
; 522  : 		}

	ret	4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Tidy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXXZ PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Tidy, COMDAT
; _this$ = ecx

; 1946 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1947 : 		this->_Orphan_all();
; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1950 : 			{	// destroy and deallocate old array
; 1951 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ecx
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	ecx
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::deallocate

; 1953 : 
; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1957 : 			}
; 1958 : 		}

	ret	0
?_Tidy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXXZ ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Buy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAE_NI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAE_NI@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Buy, COMDAT
; _this$ = ecx

; 1908 : 		{	// allocate array with _Newcapacity elements

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1909 : 		this->_Myfirst() = pointer();
; 1910 : 		this->_Mylast() = pointer();
; 1911 : 		this->_Myend() = pointer();
; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	mov	edi, DWORD PTR __Newcapacity$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1914 : 			{
; 1915 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN2@Buy:

; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	edi, 89478485				; 05555555H
	ja	SHORT $LN102@Buy

; 1921 : 			}
; 1922 : 
; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	push	edi
	call	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::allocate
	mov	DWORD PTR [esi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+8], eax

; 1926 : 
; 1927 : 		return (true);

	mov	al, 1
	pop	edi
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN102@Buy:

; 1919 : 			{
; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@CAXXZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Xlength
$LN104@Buy:
$LN101@Buy:
	int	3
?_Buy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAE_NI@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Udefault@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PAV3@I@Z
_TEXT	SEGMENT
$T3 = 8							; size = 1
__Dest$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?_Udefault@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PAV3@I@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Udefault, COMDAT
; _this$dead$ = ecx

; 1847 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

	push	ebp
	mov	ebp, esp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,0,1> *,unsigned int,std::allocator<Matrix<float,3,3,0,1> > >
	add	esp, 8
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1849 : 		}

	pop	ebp
	ret	8
?_Udefault@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PAV3@I@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$02$02$0A@$00@@QBEMHH@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?GetElement@?$MatrixData@M$02$02$0A@$00@@QBEMHH@Z PROC	; MatrixData<float,3,3,0,1>::GetElement, COMDAT
; _this$ = ecx

; 62   : 	inline T GetElement(int col, int row) const {

	push	ebp
	mov	ebp, esp

; 63   : 		return GetElement(col, row, std::integral_constant<bool, Layout == eMatrixLayout::ROW_MAJOR>());

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	movss	xmm0, DWORD PTR [ecx+eax*4]

; 64   : 	}

	pop	ebp
	ret	8
?GetElement@?$MatrixData@M$02$02$0A@$00@@QBEMHH@Z ENDP	; MatrixData<float,3,3,0,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$02$02$0A@$00@@QAEAAMHH@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?GetElement@?$MatrixData@M$02$02$0A@$00@@QAEAAMHH@Z PROC ; MatrixData<float,3,3,0,1>::GetElement, COMDAT
; _this$ = ecx

; 59   : 	inline T& GetElement(int col, int row) {

	push	ebp
	mov	ebp, esp

; 60   : 		return GetElement(col, row, std::integral_constant<bool, Layout == eMatrixLayout::ROW_MAJOR>());

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
; File d:\programming\mathter\mathter\vector.hpp

; 578  : 		return data[idx];

	lea	eax, DWORD PTR [ecx+eax*4]
; File d:\programming\mathter\mathter\matrix.hpp

; 61   : 	}

	pop	ebp
	ret	8
?GetElement@?$MatrixData@M$02$02$0A@$00@@QAEAAMHH@Z ENDP ; MatrixData<float,3,3,0,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$03$03$0A@$00@@QBEMHH@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?GetElement@?$MatrixData@M$03$03$0A@$00@@QBEMHH@Z PROC	; MatrixData<float,4,4,0,1>::GetElement, COMDAT
; _this$ = ecx

; 62   : 	inline T GetElement(int col, int row) const {

	push	ebp
	mov	ebp, esp

; 63   : 		return GetElement(col, row, std::integral_constant<bool, Layout == eMatrixLayout::ROW_MAJOR>());

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	movss	xmm0, DWORD PTR [ecx+eax*4]

; 64   : 	}

	pop	ebp
	ret	8
?GetElement@?$MatrixData@M$03$03$0A@$00@@QBEMHH@Z ENDP	; MatrixData<float,4,4,0,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$03$03$0A@$00@@QAEAAMHH@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?GetElement@?$MatrixData@M$03$03$0A@$00@@QAEAAMHH@Z PROC ; MatrixData<float,4,4,0,1>::GetElement, COMDAT
; _this$ = ecx

; 59   : 	inline T& GetElement(int col, int row) {

	push	ebp
	mov	ebp, esp

; 60   : 		return GetElement(col, row, std::integral_constant<bool, Layout == eMatrixLayout::ROW_MAJOR>());

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
; File d:\programming\mathter\mathter\vector.hpp

; 578  : 		return data[idx];

	lea	eax, DWORD PTR [ecx+eax*4]
; File d:\programming\mathter\mathter\matrix.hpp

; 61   : 	}

	pop	ebp
	ret	8
?GetElement@?$MatrixData@M$03$03$0A@$00@@QAEAAMHH@Z ENDP ; MatrixData<float,4,4,0,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?Assign@?$Vector@M$03@@IAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?Assign@?$Vector@M$03@@IAEXABV1@@Z PROC			; Vector<float,4>::Assign, COMDAT
; _this$ = ecx

; 775  : 	void Assign(const Vector& rhs) {

	push	ebp
	mov	ebp, esp

; 776  : 		// message("Assign(copy)");
; 777  : 		for (int i = 0; i < D; ++i) {
; 778  : 			data[i] = rhs.data[i];

	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 779  : 		}
; 780  : 	}

	pop	ebp
	ret	4
?Assign@?$Vector@M$03@@IAEXABV1@@Z ENDP			; Vector<float,4>::Assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ
_TEXT	SEGMENT
?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero, COMDAT
; ___$ReturnUdt$ = ecx

; 112  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx], 0

; 204  : 		return (_Myt(duration_values<_Rep>::zero()));

	mov	eax, ecx

; 112  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx+4], 0

; 205  : 		}

	ret	0
?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?Assign@?$Vector@M$02@@IAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?Assign@?$Vector@M$02@@IAEXABV1@@Z PROC			; Vector<float,3>::Assign, COMDAT
; _this$ = ecx

; 775  : 	void Assign(const Vector& rhs) {

	push	ebp
	mov	ebp, esp

; 776  : 		// message("Assign(copy)");
; 777  : 		for (int i = 0; i < D; ++i) {
; 778  : 			data[i] = rhs.data[i];

	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 779  : 		}
; 780  : 	}

	pop	ebp
	ret	4
?Assign@?$Vector@M$02@@IAEXABV1@@Z ENDP			; Vector<float,3>::Assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 141  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 142  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 129  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 130  :  #if _HAS_EXCEPTIONS
; 131  : 			if (!_STD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN2@sentry

; 132  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 105  : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 133  : 
; 134  :  #else /* _HAS_EXCEPTIONS */
; 135  : 			this->_Myostr._Osfx();
; 136  :  #endif /* _HAS_EXCEPTIONS */
; 137  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 122  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 98   : 			: _Myostr(_Ostr)

	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [edi], esi
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN6@sentry

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN6@sentry:

; 102  : 			}
; 103  : 
; 104  : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 105  : 			{	// destroy after unlocking
; 106  : 			if (_Myostr.rdbuf() != 0)
; 107  : 				_Myostr.rdbuf()->_Unlock();
; 108  : 			}
; 109  : 
; 110  : 		_Myt& _Myostr;	// the output stream, for _Unlock call at destruction
; 111  : 
; 112  : 	private:
; 113  : 		_Sentry_base& operator=(const _Sentry_base&);
; 114  : 		};
; 115  : 
; 116  : 	class sentry
; 117  : 		: public _Sentry_base
; 118  : 		{	// stores thread lock and state of stream
; 119  : 	public:
; 120  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Ostr)
; 121  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase

; 314  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]

; 338  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+esi+12], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN2@sentry
	mov	ecx, DWORD PTR [eax+esi+60]
	test	ecx, ecx
	je	SHORT $LN2@sentry
	cmp	ecx, esi
	je	SHORT $LN2@sentry

; 124  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN2@sentry:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+12], 0
	sete	al
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR [edi+4], al

; 126  : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ?zero@?$duration_values@_J@chrono@std@@SA_JXZ
_TEXT	SEGMENT
?zero@?$duration_values@_J@chrono@std@@SA_JXZ PROC	; std::chrono::duration_values<__int64>::zero, COMDAT

; 36   : 		return (_Rep(0));

	xor	eax, eax
	xor	edx, edx

; 37   : 		}

	ret	0
?zero@?$duration_values@_J@chrono@std@@SA_JXZ ENDP	; std::chrono::duration_values<__int64>::zero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	eax, DWORD PTR __Count$[ebp]

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[ebp]

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 89478485				; 05555555H
	jbe	SHORT $LN6@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@deallocate:
$LN6@deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN7@deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN8@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN8@deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN9@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN9@deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN10@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN10@deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN11@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN11@deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN7@deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEPAV?$Matrix@M$02$02$0A@$00@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEPAV?$Matrix@M$02$02$0A@$00@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::allocate, COMDAT
; _this$dead$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate

; 54   : 		return (_Ptr);

	xor	ecx, ecx

; 1077 : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 1078 : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 89478485				; 05555555H
	jbe	SHORT $LN7@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN7@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN19@allocate:
$LN10@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 1077 : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 1078 : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 1078 : 		}

	pop	ebp
	ret	4
$LN17@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEPAV?$Matrix@M$02$02$0A@$00@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAPAV?$Matrix@M$02$02$0A@$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@CAXXZ PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@CAXXZ ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 89478485				; 05555555H

; 1716 : 		}

	ret	0
?max_size@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$02$02$0A@$00@@QBEMHHU?$integral_constant@_N$00@std@@@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
___formal$ = 16						; size = 1
?GetElement@?$MatrixData@M$02$02$0A@$00@@QBEMHHU?$integral_constant@_N$00@std@@@Z PROC ; MatrixData<float,3,3,0,1>::GetElement, COMDAT
; _this$ = ecx

; 53   : 	inline T GetElement(int col, int row, std::true_type) const {

	push	ebp
	mov	ebp, esp

; 54   : 		return stripes[row][col];

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	movss	xmm0, DWORD PTR [ecx+eax*4]

; 55   : 	}

	pop	ebp
	ret	12					; 0000000cH
?GetElement@?$MatrixData@M$02$02$0A@$00@@QBEMHHU?$integral_constant@_N$00@std@@@Z ENDP ; MatrixData<float,3,3,0,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$02$02$0A@$00@@QAEAAMHHU?$integral_constant@_N$00@std@@@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
___formal$ = 16						; size = 1
?GetElement@?$MatrixData@M$02$02$0A@$00@@QAEAAMHHU?$integral_constant@_N$00@std@@@Z PROC ; MatrixData<float,3,3,0,1>::GetElement, COMDAT
; _this$ = ecx

; 47   : 	inline T& GetElement(int col, int row, std::true_type) {

	push	ebp
	mov	ebp, esp

; 48   : 		return stripes[row][col];

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
; File d:\programming\mathter\mathter\vector.hpp

; 578  : 		return data[idx];

	lea	eax, DWORD PTR [ecx+eax*4]
; File d:\programming\mathter\mathter\matrix.hpp

; 49   : 	}

	pop	ebp
	ret	12					; 0000000cH
?GetElement@?$MatrixData@M$02$02$0A@$00@@QAEAAMHHU?$integral_constant@_N$00@std@@@Z ENDP ; MatrixData<float,3,3,0,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$03$03$0A@$00@@QBEMHHU?$integral_constant@_N$00@std@@@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
___formal$ = 16						; size = 1
?GetElement@?$MatrixData@M$03$03$0A@$00@@QBEMHHU?$integral_constant@_N$00@std@@@Z PROC ; MatrixData<float,4,4,0,1>::GetElement, COMDAT
; _this$ = ecx

; 53   : 	inline T GetElement(int col, int row, std::true_type) const {

	push	ebp
	mov	ebp, esp

; 54   : 		return stripes[row][col];

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	movss	xmm0, DWORD PTR [ecx+eax*4]

; 55   : 	}

	pop	ebp
	ret	12					; 0000000cH
?GetElement@?$MatrixData@M$03$03$0A@$00@@QBEMHHU?$integral_constant@_N$00@std@@@Z ENDP ; MatrixData<float,4,4,0,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$03$03$0A@$00@@QAEAAMHHU?$integral_constant@_N$00@std@@@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_row$ = 12						; size = 4
___formal$ = 16						; size = 1
?GetElement@?$MatrixData@M$03$03$0A@$00@@QAEAAMHHU?$integral_constant@_N$00@std@@@Z PROC ; MatrixData<float,4,4,0,1>::GetElement, COMDAT
; _this$ = ecx

; 47   : 	inline T& GetElement(int col, int row, std::true_type) {

	push	ebp
	mov	ebp, esp

; 48   : 		return stripes[row][col];

	mov	edx, DWORD PTR _row$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
; File d:\programming\mathter\mathter\vector.hpp

; 578  : 		return data[idx];

	lea	eax, DWORD PTR [ecx+eax*4]
; File d:\programming\mathter\mathter\matrix.hpp

; 49   : 	}

	pop	ebp
	ret	12					; 0000000cH
?GetElement@?$MatrixData@M$03$03$0A@$00@@QAEAAMHHU?$integral_constant@_N$00@std@@@Z ENDP ; MatrixData<float,4,4,0,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 105  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 108  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 98   : 			: _Myostr(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	esi

; 99   : 			{	// lock the stream buffer, if there

	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 100  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 102  : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 89478485				; 05555555H

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEPAV?$Matrix@M$02$02$0A@$00@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEPAV?$Matrix@M$02$02$0A@$00@@I@Z PROC ; std::allocator<Matrix<float,3,3,0,1> >::allocate, COMDAT
; _this$dead$ = ecx

; 827  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 54   : 		return (_Ptr);

	xor	ecx, ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 89478485				; 05555555H
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 829  : 		}

	pop	ebp
	ret	4
$LN14@allocate:
?allocate@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEPAV?$Matrix@M$02$02$0A@$00@@I@Z ENDP ; std::allocator<Matrix<float,3,3,0,1> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z PROC ; std::allocator<Matrix<float,3,3,0,1> >::deallocate, COMDAT
; _this$dead$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	eax, DWORD PTR __Count$[ebp]

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[ebp]

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 89478485				; 05555555H
	jbe	SHORT $LN4@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN14@deallocate:
$LN4@deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN6@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN15@deallocate:
$LN6@deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN7@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@deallocate:
$LN7@deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN8@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@deallocate:
$LN8@deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN9@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN9@deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN5@deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 824  : 		}

	pop	ebp
	ret	8
$LN13@deallocate:
?deallocate@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ENDP ; std::allocator<Matrix<float,3,3,0,1> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??A?$Vector@M$03@@QAEAAMH@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
??A?$Vector@M$03@@QAEAAMH@Z PROC			; Vector<float,4>::operator[], COMDAT
; _this$ = ecx

; 577  : 	T& operator[](int idx) {

	push	ebp
	mov	ebp, esp

; 578  : 		return data[idx];

	mov	eax, DWORD PTR _idx$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 579  : 	}

	pop	ebp
	ret	4
??A?$Vector@M$03@@QAEAAMH@Z ENDP			; Vector<float,4>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??A?$Vector@M$03@@QBEMH@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
??A?$Vector@M$03@@QBEMH@Z PROC				; Vector<float,4>::operator[], COMDAT
; _this$ = ecx

; 573  : 	T operator[](int idx) const {

	push	ebp
	mov	ebp, esp

; 574  : 		return data[idx];

	mov	eax, DWORD PTR _idx$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]

; 575  : 	}

	pop	ebp
	ret	4
??A?$Vector@M$03@@QBEMH@Z ENDP				; Vector<float,4>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??A?$Vector@M$02@@QAEAAMH@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
??A?$Vector@M$02@@QAEAAMH@Z PROC			; Vector<float,3>::operator[], COMDAT
; _this$ = ecx

; 577  : 	T& operator[](int idx) {

	push	ebp
	mov	ebp, esp

; 578  : 		return data[idx];

	mov	eax, DWORD PTR _idx$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 579  : 	}

	pop	ebp
	ret	4
??A?$Vector@M$02@@QAEAAMH@Z ENDP			; Vector<float,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??A?$Vector@M$02@@QBEMH@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
??A?$Vector@M$02@@QBEMH@Z PROC				; Vector<float,3>::operator[], COMDAT
; _this$ = ecx

; 573  : 	T operator[](int idx) const {

	push	ebp
	mov	ebp, esp

; 574  : 		return data[idx];

	mov	eax, DWORD PTR _idx$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]

; 575  : 	}

	pop	ebp
	ret	4
??A?$Vector@M$02@@QBEMH@Z ENDP				; Vector<float,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAIABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAIABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@2@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 970  : 		return (_Al.max_size());

	mov	eax, 89478485				; 05555555H

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAIABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QBEIXZ PROC ; std::allocator<Matrix<float,3,3,0,1> >::max_size, COMDAT
; _this$dead$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 89478485				; 05555555H

; 852  : 		}

	ret	0
?max_size@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QBEIXZ ENDP ; std::allocator<Matrix<float,3,3,0,1> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
__Pad$ = -48						; size = 8
__State$ = -36						; size = 4
__Val$1$ = -32						; size = 4
$T20 = -32						; size = 1
$T14 = -28						; size = 1
__Ostr$ = -24						; size = 4
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 772  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, edx
	mov	DWORD PTR __Val$1$[ebp], eax
	mov	ebx, ecx
	mov	DWORD PTR __Ostr$[ebp], ebx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	ecx, eax
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 775  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	esi, DWORD PTR [ecx+1]
$LL107@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL107@operator
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase

; 422  : 		return (_Wide);

	mov	eax, DWORD PTR [ebx]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	sub	ecx, esi
	mov	DWORD PTR __Count$2$[ebp], ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase

; 422  : 		return (_Wide);

	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+ebx+36]
	mov	esi, DWORD PTR [eax+ebx+32]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 777  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN109@operator
	test	esi, esi
	je	SHORT $LN17@operator
	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN109@operator
	cmp	esi, ecx
	jbe	SHORT $LN17@operator
$LN109@operator:
	sub	esi, ecx
	sbb	edi, 0
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	edi, DWORD PTR __Pad$[ebp+4]
	mov	esi, DWORD PTR __Pad$[ebp]
$LN18@operator:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ebx+56]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 98   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], ebx

; 99   : 			{	// lock the stream buffer, if there
; 100  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN38@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN38@operator:

; 121  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase

; 314  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]

; 338  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+ebx+12], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN34@operator
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios

; 79   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [eax+ebx+60]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN34@operator
	cmp	ecx, ebx
	je	SHORT $LN34@operator

; 124  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN34@operator:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase

; 314  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]

; 338  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+ebx+12], 0
	sete	al
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al

; 778  : 		? 0 : _Ostr.width() - _Count;
; 779  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 780  : 
; 781  : 	if (!_Ok)

	test	al, al
	jne	SHORT $LN8@operator

; 782  : 		_State |= ios_base::badbit;

	mov	ecx, 4

; 783  : 	else

	jmp	$LN22@operator
$LN8@operator:

; 784  : 		{	// state okay, insert
; 785  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase

; 377  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+ebx+20]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 786  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN104@operator
	npad	1
$LL4@operator:

; 787  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	edi, edi
	jl	SHORT $LN3@operator
	jg	SHORT $LN110@operator
	test	esi, esi
	je	SHORT $LN3@operator
$LN110@operator:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios

; 112  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 788  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios

; 112  : 		return (_Fillch);

	mov	BYTE PTR $T14[ebp], al
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 788  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T14[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd

; 542  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 788  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN2@operator
$LN111@operator:

; 789  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 790  : 					{	// insertion failed, quit
; 791  : 					_State |= ios_base::badbit;

	mov	ecx, 4

; 792  : 					break;

	jmp	SHORT $LN6@operator
$LN2@operator:

; 787  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL4@operator
$LN3@operator:
	xor	ecx, ecx

; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	jne	SHORT $LN6@operator
$LN104@operator:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ebx]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	0
	push	DWORD PTR __Count$2$[ebp]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	DWORD PTR __Val$1$[ebp]
	mov	ecx, DWORD PTR [eax+ebx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Count$2$[ebp]
	jne	SHORT $LN111@operator
	test	edx, edx
	jne	SHORT $LN111@operator
$LL113@operator:

; 797  : 			_State |= ios_base::badbit;
; 798  : 
; 799  : 		if (_State == ios_base::goodbit)
; 800  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	edi, edi
	jl	SHORT $LN117@operator
	jg	SHORT $LN112@operator
	test	esi, esi
	je	SHORT $LN117@operator
$LN112@operator:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios

; 112  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 801  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios

; 112  : 		return (_Fillch);

	mov	BYTE PTR $T20[ebp], al
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 801  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T20[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\iosfwd

; 542  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 801  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN5@operator

; 802  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 803  : 					{	// insertion failed, quit
; 804  : 					_State |= ios_base::badbit;

	xor	ecx, ecx
	or	ecx, 4

; 805  : 					break;

	jmp	SHORT $LN6@operator
$LN5@operator:

; 797  : 			_State |= ios_base::badbit;
; 798  : 
; 799  : 		if (_State == ios_base::goodbit)
; 800  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL113@operator
$LN117@operator:
	xor	ecx, ecx
$LN6@operator:

; 806  : 					}
; 807  : 		_Ostr.width(0);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xiosbase

; 428  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
	jmp	SHORT $LN122@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 808  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ios
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR __State$[ebp]
$LN122@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream

; 809  : 		}
; 810  : 
; 811  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 129  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 130  :  #if _HAS_EXCEPTIONS
; 131  : 			if (!_STD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 132  : 				this->_Myostr._Osfx();

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN87@operator
	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN87@operator:

; 105  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN114@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN114@operator:

; 812  : 	return (_Ostr);

	mov	eax, ebx

; 813  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 983  : 	{	// insert newline and flush stream

	push	ebp
	mov	ebp, esp
	push	esi

; 984  : 	_Ostr.put(_Ostr.widen('\n'));

	mov	esi, DWORD PTR __Ostr$[ebp]
	push	10					; 0000000aH
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	movzx	ecx, al
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 985  : 	_Ostr.flush();

	mov	ecx, esi
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 986  : 	return (_Ostr);

	mov	eax, esi
	pop	esi

; 987  : 	}

	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 113  : 		{	// construct from representation

	push	ebp
	mov	ebp, esp

; 112  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 114  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?DM$03@@YA?AV?$Vector@M$03@@ABV0@0@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??$?DM$03@@YA?AV?$Vector@M$03@@ABV0@0@Z PROC		; operator*<float,4>, COMDAT
; ___$ReturnUdt$ = ecx
; _lhs$ = edx

; 809  : inline Vector<T, D> operator*(const Vector<T, D>& lhs, const Vector<T, D>& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mov	eax, DWORD PTR _rhs$[ebx]
	movups	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 809  : inline Vector<T, D> operator*(const Vector<T, D>& lhs, const Vector<T, D>& rhs) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm0, XMMWORD PTR [eax]
; File d:\programming\mathter\mathter\vector.hpp

; 812  : 	return tmp;

	mov	eax, ecx

; 398  : 		simd = Simd4f::mul(simd, rhs.simd);

	movups	XMMWORD PTR [ecx], xmm0

; 813  : }

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
??$?DM$03@@YA?AV?$Vector@M$03@@ABV0@0@Z ENDP		; operator*<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\main.cpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\main.cpp
;	COMDAT ??$?6M$03@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Vector@M$03@@@Z
_TEXT	SEGMENT
_v$1$ = -4						; size = 4
??$?6M$03@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Vector@M$03@@@Z PROC ; operator<<<float,4>, COMDAT
; _os$ = ecx
; _v$ = edx

; 23   : std::ostream& operator<<(std::ostream& os, const Vector<T, D>& v) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, edx
	mov	ebx, ecx
	push	edi

; 24   : 	os << "{";

	mov	edx, OFFSET $SG4294967213
	mov	DWORD PTR _v$1$[ebp], esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 25   : 	for (int x = 0; x < D; ++x) {

	xor	edi, edi
	mov	eax, OFFSET $SG4294967211
	npad	1
$LL4@operator:
; File d:\programming\mathter\mathter\vector.hpp

; 582  : 		return data[idx];

	movss	xmm0, DWORD PTR [esi+edi*4]
; File d:\programming\mathter\main.cpp

; 26   : 		os << v(x) << (x == D - 1 ? "" : "\t");

	cmp	edi, 3
	push	ecx
	mov	esi, OFFSET $SG4294967212
	movss	DWORD PTR [esp], xmm0
	mov	ecx, ebx
	cmovne	esi, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	mov	edx, esi
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, DWORD PTR _v$1$[ebp]
	inc	edi
	mov	eax, OFFSET $SG4294967211
	cmp	edi, 4
	jl	SHORT $LL4@operator

; 27   : 	}
; 28   : 	os << "}";

	mov	edx, OFFSET $SG4294967210
	mov	ecx, ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 29   : 	return os;
; 30   : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$?6M$03@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Vector@M$03@@@Z ENDP ; operator<<<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0V?$Vector@M$02@@M$0A@@?$Vector@M$03@@QAE@ABV?$Vector@M$02@@ABM@Z
_TEXT	SEGMENT
_rhs1$ = 8						; size = 4
_<rhs2_0>$ = 12						; size = 4
??$?0V?$Vector@M$02@@M$0A@@?$Vector@M$03@@QAE@ABV?$Vector@M$02@@ABM@Z PROC ; Vector<float,4>::Vector<float,4><Vector<float,3>,float,0>, COMDAT
; _this$ = ecx

; 533  : 	Vector(const U& rhs1, const V&... rhs2) {

	push	ebp
	mov	ebp, esp

; 768  : 				target.data[StartIdx + i] = GetVectorElement<Head>::Get(head, i);

	mov	edx, DWORD PTR _rhs1$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _<rhs2_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+12], eax

; 534  : 		// message("Vector(concat...)");
; 535  : 		Assign(rhs1, rhs2...);
; 536  : 	}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$Vector@M$02@@M$0A@@?$Vector@M$03@@QAE@ABV?$Vector@M$02@@ABM@Z ENDP ; Vector<float,4>::Vector<float,4><Vector<float,3>,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Set@HHH$0A@@?$Vector@M$02@@QAEAAV0@HHH@Z
_TEXT	SEGMENT
_u$dead$ = 8						; size = 4
_<v_0>$dead$ = 12					; size = 4
_<v_1>$dead$ = 16					; size = 4
??$Set@HHH$0A@@?$Vector@M$02@@QAEAAV0@HHH@Z PROC	; Vector<float,3>::Set<int,int,int,0>, COMDAT
; _this$ = ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 75   : 		res.reg = _mm_setr_ps(x, y, z, w);

	movaps	xmm0, XMMWORD PTR __xmm@0000000040400000400000003f800000
; File d:\programming\mathter\mathter\vector.hpp

; 553  : 		return *this;

	mov	eax, ecx

; 326  : 		simd = Simd4f::set(x, y, z, 0);

	movups	XMMWORD PTR [ecx], xmm0

; 554  : 	}

	ret	12					; 0000000cH
??$Set@HHH$0A@@?$Vector@M$02@@QAEAAV0@HHH@Z ENDP	; Vector<float,3>::Set<int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Set@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@QAEAAV0@ABMABV?$Vector@M$02@@@Z
_TEXT	SEGMENT
_u$ = 8							; size = 4
_<v_0>$ = 12						; size = 4
??$Set@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@QAEAAV0@ABMABV?$Vector@M$02@@@Z PROC ; Vector<float,4>::Set<float,Vector<float,3>,0>, COMDAT
; _this$ = ecx

; 558  : 	Vector& Set(const U& u, const V&... v) {

	push	ebp
	mov	ebp, esp

; 768  : 				target.data[StartIdx + i] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR _<v_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+12], eax

; 559  : 		// message("Set(concat...)");
; 560  : 		Assign(u, v...);
; 561  : 		return *this;

	mov	eax, ecx

; 562  : 	}

	pop	ebp
	ret	8
??$Set@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@QAEAAV0@ABMABV?$Vector@M$02@@@Z ENDP ; Vector<float,4>::Set<float,Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?DM$03@@YA?AV?$Vector@M$03@@MABV0@@Z
_TEXT	SEGMENT
??$?DM$03@@YA?AV?$Vector@M$03@@MABV0@@Z PROC		; operator*<float,4>, COMDAT
; ___$ReturnUdt$ = ecx
; _lhs$ = xmm1s
; _rhs$ = edx

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [edx]

; 867  : inline Vector<T, D> operator*(T lhs, const Vector<T, D>& rhs) {

	movaps	xmm0, xmm1

; 778  : 			data[i] = rhs.data[i];

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 868  : 	auto tmp = rhs;
; 869  : 	tmp *= lhs;
; 870  : 	return tmp;

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 412  : 		simd = Simd4f::mul(simd, rhs);

	movups	XMMWORD PTR [ecx], xmm0

; 871  : }

	ret	0
??$?DM$03@@YA?AV?$Vector@M$03@@MABV0@@Z ENDP		; operator*<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\main.cpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\main.cpp
;	COMDAT ??$?6M$03$03$0A@$00@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Matrix@M$03$03$0A@$00@@@Z
_TEXT	SEGMENT
tv221 = -8						; size = 4
_os$1$ = -4						; size = 4
??$?6M$03$03$0A@$00@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Matrix@M$03$03$0A@$00@@@Z PROC ; operator<<<float,4,4,0,1>, COMDAT
; _os$ = ecx
; _mat$ = edx

; 11   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Layout, Order>& mat) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 12   : 	for (int y = 0; y < mat.Height(); ++y) {

	mov	DWORD PTR tv221[ebp], 4
	push	edi
	mov	ebx, edx
	mov	DWORD PTR _os$1$[ebp], esi
	npad	9
$LL4@operator:

; 13   : 		os << "{";

	mov	edx, OFFSET $SG4294967209
	mov	ecx, esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 14   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	edi, edi
	npad	2
$LL7@operator:
; File d:\programming\mathter\mathter\vector.hpp

; 574  : 		return data[idx];

	movss	xmm0, DWORD PTR [ebx]
; File d:\programming\mathter\main.cpp

; 15   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	cmp	edi, 3
	push	ecx
	mov	ecx, DWORD PTR _os$1$[ebp]
	mov	eax, OFFSET $SG4294967207
	mov	esi, OFFSET $SG4294967208
	movss	DWORD PTR [esp], xmm0
	cmovne	esi, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	mov	edx, esi
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	inc	edi
	add	ebx, 4
	cmp	edi, 4
	jl	SHORT $LL7@operator

; 16   : 		}
; 17   : 		os << "}\n";

	mov	esi, DWORD PTR _os$1$[ebp]
	mov	edx, OFFSET $SG4294967206
	mov	ecx, esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	sub	DWORD PTR tv221[ebp], 1
	jne	SHORT $LL4@operator

; 18   : 	}
; 19   : 	return os;
; 20   : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$?6M$03$03$0A@$00@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Matrix@M$03$03$0A@$00@@@Z ENDP ; operator<<<float,4,4,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?DM$02@@YA?AV?$Vector@M$02@@ABV0@0@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??$?DM$02@@YA?AV?$Vector@M$02@@ABV0@0@Z PROC		; operator*<float,3>, COMDAT
; ___$ReturnUdt$ = ecx
; _lhs$ = edx

; 809  : inline Vector<T, D> operator*(const Vector<T, D>& lhs, const Vector<T, D>& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mov	eax, DWORD PTR _rhs$[ebx]
	movups	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 809  : inline Vector<T, D> operator*(const Vector<T, D>& lhs, const Vector<T, D>& rhs) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm0, XMMWORD PTR [eax]
; File d:\programming\mathter\mathter\vector.hpp

; 812  : 	return tmp;

	mov	eax, ecx

; 334  : 		simd = Simd4f::mul(simd, rhs.simd);

	movups	XMMWORD PTR [ecx], xmm0

; 813  : }

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
??$?DM$02@@YA?AV?$Vector@M$02@@ABV0@0@Z ENDP		; operator*<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?DM$02@@YA?AV?$Vector@M$02@@MABV0@@Z
_TEXT	SEGMENT
??$?DM$02@@YA?AV?$Vector@M$02@@MABV0@@Z PROC		; operator*<float,3>, COMDAT
; ___$ReturnUdt$ = ecx
; _lhs$ = xmm1s
; _rhs$ = edx

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [edx]

; 867  : inline Vector<T, D> operator*(T lhs, const Vector<T, D>& rhs) {

	movaps	xmm0, xmm1

; 778  : 			data[i] = rhs.data[i];

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 868  : 	auto tmp = rhs;
; 869  : 	tmp *= lhs;
; 870  : 	return tmp;

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 348  : 		simd = Simd4f::mul(simd, rhs);

	movups	XMMWORD PTR [ecx], xmm0

; 871  : }

	ret	0
??$?DM$02@@YA?AV?$Vector@M$02@@MABV0@@Z ENDP		; operator*<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\main.cpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\main.cpp
;	COMDAT ??$?6M$02$02$0A@$00@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Matrix@M$02$02$0A@$00@@@Z
_TEXT	SEGMENT
tv221 = -12						; size = 4
_mat$1$ = -8						; size = 4
_os$1$ = -4						; size = 4
??$?6M$02$02$0A@$00@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Matrix@M$02$02$0A@$00@@@Z PROC ; operator<<<float,3,3,0,1>, COMDAT
; _os$ = ecx
; _mat$ = edx

; 11   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Layout, Order>& mat) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, edx

; 12   : 	for (int y = 0; y < mat.Height(); ++y) {

	mov	DWORD PTR tv221[ebp], 3
	mov	ebx, ecx
	mov	DWORD PTR _mat$1$[ebp], esi
	push	edi
	mov	DWORD PTR _os$1$[ebp], ebx
	npad	6
$LL4@operator:

; 13   : 		os << "{";

	mov	edx, OFFSET $SG4294967205
	mov	ecx, ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 14   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	edi, edi
	mov	ebx, esi
$LL7@operator:
; File d:\programming\mathter\mathter\vector.hpp

; 574  : 		return data[idx];

	movss	xmm0, DWORD PTR [ebx]
; File d:\programming\mathter\main.cpp

; 15   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	cmp	edi, 2
	push	ecx
	mov	ecx, DWORD PTR _os$1$[ebp]
	mov	eax, OFFSET $SG4294967203
	mov	esi, OFFSET $SG4294967204
	movss	DWORD PTR [esp], xmm0
	cmovne	esi, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	mov	edx, esi
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	inc	edi
	lea	ebx, DWORD PTR [ebx+4]
	cmp	edi, 3
	jl	SHORT $LL7@operator

; 16   : 		}
; 17   : 		os << "}\n";

	mov	ebx, DWORD PTR _os$1$[ebp]
	mov	edx, OFFSET $SG4294967202
	mov	ecx, ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, DWORD PTR _mat$1$[ebp]
	add	esi, 16					; 00000010H
	sub	DWORD PTR tv221[ebp], 1
	mov	DWORD PTR _mat$1$[ebp], esi
	jne	SHORT $LL4@operator

; 18   : 	}
; 19   : 	return os;
; 20   : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$?6M$02$02$0A@$00@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABV?$Matrix@M$02$02$0A@$00@@@Z ENDP ; operator<<<float,3,3,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 851  : 	{	// add time_point to time_point

	push	ebp
	mov	ebp, esp

; 349  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	eax, DWORD PTR __Right$[ebp]

; 851  : 	{	// add time_point to time_point

	push	esi

; 349  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	sub	esi, DWORD PTR [eax]

; 112  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx], esi

; 349  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sbb	edx, DWORD PTR [eax+4]

; 852  : 	return (_Left.time_since_epoch() - _Right.time_since_epoch());

	mov	eax, ecx

; 112  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx+4], edx

; 853  : 	}

	pop	esi
	pop	ebp
	ret	0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z
_TEXT	SEGMENT
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Dur$ = edx

; 548  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 549  : 
; 550  : 	typedef typename _To::rep _ToRep;
; 551  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 552  : 
; 553  : #pragma warning(push)
; 554  : #pragma warning(disable: 6326)	// Potential comparison of a constant with another constant.
; 555  : 	return (_CF::num == 1 && _CF::den == 1

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx

; 556  : 			? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 557  : 		: _CF::num != 1 && _CF::den == 1
; 558  : 			? static_cast<_To>(static_cast<_ToRep>(
; 559  : 				static_cast<_CR>(
; 560  : 					_Dur.count()) * static_cast<_CR>(_CF::num)))
; 561  : 		: _CF::num == 1 && _CF::den != 1
; 562  : 			? static_cast<_To>(static_cast<_ToRep>(
; 563  : 				static_cast<_CR>(_Dur.count())
; 564  : 					/ static_cast<_CR>(_CF::den)))
; 565  : 		: static_cast<_To>(static_cast<_ToRep>(
; 566  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 567  : 				/ static_cast<_CR>(_CF::den))));
; 568  : #pragma warning(pop)
; 569  : 	}

	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Assign_range@PBV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPBV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Oldsize$1$ = 8					; size = 4
$T68 = 8						; size = 1
$T51 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PBV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPBV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> const *>, COMDAT
; _this$ = ecx

; 1357 : 		{	// assign [_First, _Last), forward iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1357 : 		{	// assign [_First, _Last), forward iterators

	push	ebx
	push	esi
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	esi, DWORD PTR __First$[ebp]
	sub	edx, esi
	imul	edx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1357 : 		{	// assign [_First, _Last), forward iterators

	mov	DWORD PTR _this$1$[ebp], ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	sar	edx, 3
	mov	ebx, edx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1357 : 		{	// assign [_First, _Last), forward iterators

	push	edi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	sub	ecx, edi
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	shr	ebx, 31					; 0000001fH
	add	ebx, edx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _this$1$[ebp]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR [ecx+8]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	add	eax, edx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	ecx, edi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1358 : 		const size_type _Newsize = _STD distance(_First, _Last);
; 1359 : 
; 1360 : 		this->_Orphan_all();
; 1361 : 
; 1362 : 		const size_type _Oldsize = size();
; 1363 : 		const size_type _Oldcapacity = capacity();
; 1364 : 
; 1365 : 		if (_Newsize > _Oldcapacity)

	cmp	ebx, ecx
	jbe	SHORT $LN2@Assign_ran

; 1366 : 			{	// reallocate
; 1367 : 			if (_Newsize > max_size())

	cmp	ebx, 89478485				; 05555555H
	ja	$LN318@Assign_ran

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, ecx
	mov	eax, 89478485				; 05555555H
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	ja	SHORT $LN75@Assign_ran

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow
; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, ebx
	cmovb	eax, ebx
	mov	ebx, eax
$LN75@Assign_ran:

; 1370 : 				}
; 1371 : 
; 1372 : 			const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1373 : 
; 1374 : 			if (this->_Myfirst() != pointer())

	test	edi, edi
	je	SHORT $LN5@Assign_ran

; 1375 : 				{	// destroy and deallocate old array
; 1376 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1377 : 				this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);

	push	ecx
	push	edi
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::deallocate
$LN5@Assign_ran:

; 1378 : 				}
; 1379 : 
; 1380 : 			_Buy(_Newcapacity);

	push	ebx
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	ecx, ebx
	call	?_Buy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAE_NI@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Buy
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	mov	edx, DWORD PTR __Last$[ebp]
	push	ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 876  : 	return {};

	mov	BYTE PTR $T51[ebp], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T51[ebp]
	push	ecx
	push	DWORD PTR [ebx]
	mov	ecx, esi
	call	??$_Uninitialized_copy_al_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
	add	esp, 16					; 00000010H
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1382 : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

	mov	DWORD PTR [ebx+4], eax

; 1396 : 			}
; 1397 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@Assign_ran:

; 1383 : 			}
; 1384 : 		else if (_Newsize > _Oldsize)

	mov	eax, DWORD PTR __Oldsize$1$[ebp]
	cmp	ebx, eax
	jbe	SHORT $LN6@Assign_ran
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 1079 : 	_Where += _Off;

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 4
	add	ecx, esi

; 2309 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	esi, ecx
	je	SHORT $LN220@Assign_ran
	npad	1
$LL221@Assign_ran:

; 2310 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [esi]
	lea	edi, DWORD PTR [edi+48]
	movups	XMMWORD PTR [edi-48], xmm0
	movups	xmm0, XMMWORD PTR [esi+16]
	movups	XMMWORD PTR [edi-32], xmm0
	movups	xmm0, XMMWORD PTR [esi+32]
	add	esi, 48					; 00000030H
	movups	XMMWORD PTR [edi-16], xmm0
	cmp	esi, ecx
	jne	SHORT $LL221@Assign_ran
$LN220@Assign_ran:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	push	ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 876  : 	return {};

	mov	BYTE PTR $T68[ebp], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T68[ebp]
	push	ecx
	push	DWORD PTR [ebx+4]
	call	??$_Uninitialized_copy_al_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
	add	esp, 16					; 00000010H
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1388 : 			this->_Mylast() = _Ucopy(_Mid, _Last, this->_Mylast());

	mov	DWORD PTR [ebx+4], eax

; 1396 : 			}
; 1397 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN6@Assign_ran:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 2309 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	eax, DWORD PTR __Last$[ebp]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1392 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	lea	ecx, DWORD PTR [ebx+ebx*2]
	shl	ecx, 4
	add	ecx, edi
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 2309 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	esi, eax
	je	SHORT $LN288@Assign_ran
$LL289@Assign_ran:

; 2310 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [esi]
	lea	edi, DWORD PTR [edi+48]
	movups	XMMWORD PTR [edi-48], xmm0
	movups	xmm0, XMMWORD PTR [esi+16]
	movups	XMMWORD PTR [edi-32], xmm0
	movups	xmm0, XMMWORD PTR [esi+32]
	add	esi, 48					; 00000030H
	movups	XMMWORD PTR [edi-16], xmm0
	cmp	esi, eax
	jne	SHORT $LL289@Assign_ran
$LN288@Assign_ran:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1395 : 			this->_Mylast() = _Newlast;

	mov	eax, DWORD PTR _this$1$[ebp]

; 1396 : 			}
; 1397 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax+4], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN318@Assign_ran:

; 1368 : 				{
; 1369 : 				_Xlength();

	call	?_Xlength@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@CAXXZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Xlength
$LN320@Assign_ran:
$LN317@Assign_ran:
	int	3
??$_Assign_range@PBV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPBV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAPBV?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAPBV?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > const >, COMDAT
; __Val$ = ecx

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 631  : 	}

	ret	0
??$addressof@$$CBV?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAPBV?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$assign@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@0@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::assign<Matrix<float,3,3,0,1> *>, COMDAT
; _this$ = ecx

; 1403 : 		{	// assign [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 1404 : 		_DEBUG_RANGE(_First, _Last);
; 1405 : 		_Assign_range(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>{});

	mov	BYTE PTR $T1[ebp], 0
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Assign_range@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> *>

; 1406 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$assign@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@0@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::assign<Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > ><std::allocator<Matrix<float,3,3,0,1> > const &,void>, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 517  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 517  : 		}

	ret	4
??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > ><std::allocator<Matrix<float,3,3,0,1> > const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABU10@@Z
_TEXT	SEGMENT
??$_Pocca@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1144 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1145 : 	_Pocca(_Left, _Right, _Tag);
; 1146 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Matrix<float,3,3,0,1> *,unsigned int,std::allocator<Matrix<float,3,3,0,1> > >, COMDAT
; __First$ = ecx
; __Count$dead$ = edx

; 260  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 261  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Uninitialized_default_fill_n1@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,0,1> *,unsigned int,std::allocator<Matrix<float,3,3,0,1> > >
	add	esp, 8

; 263  : 		_Conjunction_t<
; 264  : 			is_pointer<_FwdIt>,
; 265  : 			is_scalar<_Ty>,
; 266  : 			negation<is_volatile<_Ty>>,
; 267  : 			negation<is_member_pointer<_Ty>>,
; 268  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>()));
; 269  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Matrix<float,3,3,0,1> *,unsigned int,std::allocator<Matrix<float,3,3,0,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAXPAV?$Matrix@M$02$02$0A@$00@@0AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAXPAV?$Matrix@M$02$02$0A@$00@@0AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Matrix<float,3,3,0,1> >,Matrix<float,3,3,0,1> *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAXPAV?$Matrix@M$02$02$0A@$00@@0AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Matrix<float,3,3,0,1> >,Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@ABEII@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1889 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 89478485				; 05555555H

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, ecx
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN2@Calculate_

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
$LN2@Calculate_:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, DWORD PTR __Newsize$[ebp]
	cmovb	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@ABEII@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?capacity@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::capacity, COMDAT
; _this$ = ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1721 : 		}

	ret	0
?capacity@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1711 : 		}

	ret	0
?size@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QBEIXZ ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Height@?$MatrixData@M$02$02$0A@$00@@QBEHXZ
_TEXT	SEGMENT
?Height@?$MatrixData@M$02$02$0A@$00@@QBEHXZ PROC	; MatrixData<float,3,3,0,1>::Height, COMDAT
; _this$dead$ = ecx

; 37   : 		return Rows;

	mov	eax, 3

; 38   : 	}

	ret	0
?Height@?$MatrixData@M$02$02$0A@$00@@QBEHXZ ENDP	; MatrixData<float,3,3,0,1>::Height
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Width@?$MatrixData@M$02$02$0A@$00@@QBEHXZ
_TEXT	SEGMENT
?Width@?$MatrixData@M$02$02$0A@$00@@QBEHXZ PROC		; MatrixData<float,3,3,0,1>::Width, COMDAT
; _this$dead$ = ecx

; 34   : 		return Columns;

	mov	eax, 3

; 35   : 	}

	ret	0
?Width@?$MatrixData@M$02$02$0A@$00@@QBEHXZ ENDP		; MatrixData<float,3,3,0,1>::Width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Height@?$MatrixData@M$03$03$0A@$00@@QBEHXZ
_TEXT	SEGMENT
?Height@?$MatrixData@M$03$03$0A@$00@@QBEHXZ PROC	; MatrixData<float,4,4,0,1>::Height, COMDAT
; _this$dead$ = ecx

; 37   : 		return Rows;

	mov	eax, 4

; 38   : 	}

	ret	0
?Height@?$MatrixData@M$03$03$0A@$00@@QBEHXZ ENDP	; MatrixData<float,4,4,0,1>::Height
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Width@?$MatrixData@M$03$03$0A@$00@@QBEHXZ
_TEXT	SEGMENT
?Width@?$MatrixData@M$03$03$0A@$00@@QBEHXZ PROC		; MatrixData<float,4,4,0,1>::Width, COMDAT
; _this$dead$ = ecx

; 34   : 		return Columns;

	mov	eax, 4

; 35   : 	}

	ret	0
?Width@?$MatrixData@M$03$03$0A@$00@@QBEHXZ ENDP		; MatrixData<float,4,4,0,1>::Width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??X?$Vector@M$03@@QAEAAV0@M@Z
_TEXT	SEGMENT
??X?$Vector@M$03@@QAEAAV0@M@Z PROC			; Vector<float,4>::operator*=, COMDAT
; _this$ = ecx
; _rhs$ = xmm1s

; 661  : 	inline Vector& operator*=(T rhs) {

	movaps	xmm0, xmm1

; 662  : 		mul(rhs);
; 663  : 		return *this;

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 412  : 		simd = Simd4f::mul(simd, rhs);

	movups	XMMWORD PTR [ecx], xmm0

; 664  : 	}

	ret	0
??X?$Vector@M$03@@QAEAAV0@M@Z ENDP			; Vector<float,4>::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??X?$Vector@M$03@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??X?$Vector@M$03@@QAEAAV0@ABV0@@Z PROC			; Vector<float,4>::operator*=, COMDAT
; _this$ = ecx

; 639  : 	inline Vector& operator*=(const Vector& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mov	eax, DWORD PTR _rhs$[ebx]
; File d:\programming\mathter\mathter\vector.hpp

; 639  : 	inline Vector& operator*=(const Vector& rhs) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [eax]
; File d:\programming\mathter\mathter\vector.hpp

; 641  : 		return *this;

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 398  : 		simd = Simd4f::mul(simd, rhs.simd);

	movups	XMMWORD PTR [ecx], xmm0

; 642  : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
??X?$Vector@M$03@@QAEAAV0@ABV0@@Z ENDP			; Vector<float,4>::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??R?$Vector@M$03@@QBEMH@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
??R?$Vector@M$03@@QBEMH@Z PROC				; Vector<float,4>::operator(), COMDAT
; _this$ = ecx

; 581  : 	T operator()(int idx) const {

	push	ebp
	mov	ebp, esp

; 582  : 		return data[idx];

	mov	eax, DWORD PTR _idx$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]

; 583  : 	}

	pop	ebp
	ret	4
??R?$Vector@M$03@@QBEMH@Z ENDP				; Vector<float,4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 253  : 		{	// get duration from epoch

	push	ebp
	mov	ebp, esp

; 254  : 		return (_MyDur);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 255  : 		}

	pop	ebp
	ret	4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??X?$Vector@M$02@@QAEAAV0@M@Z
_TEXT	SEGMENT
??X?$Vector@M$02@@QAEAAV0@M@Z PROC			; Vector<float,3>::operator*=, COMDAT
; _this$ = ecx
; _rhs$ = xmm1s

; 661  : 	inline Vector& operator*=(T rhs) {

	movaps	xmm0, xmm1

; 662  : 		mul(rhs);
; 663  : 		return *this;

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 348  : 		simd = Simd4f::mul(simd, rhs);

	movups	XMMWORD PTR [ecx], xmm0

; 664  : 	}

	ret	0
??X?$Vector@M$02@@QAEAAV0@M@Z ENDP			; Vector<float,3>::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
; File d:\programming\mathter\mathter\simd4f_sse.hpp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??X?$Vector@M$02@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??X?$Vector@M$02@@QAEAAV0@ABV0@@Z PROC			; Vector<float,3>::operator*=, COMDAT
; _this$ = ecx

; 639  : 	inline Vector& operator*=(const Vector& rhs) {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mov	eax, DWORD PTR _rhs$[ebx]
; File d:\programming\mathter\mathter\vector.hpp

; 639  : 	inline Vector& operator*=(const Vector& rhs) {

	mov	DWORD PTR [esp+4], ebp
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movups	xmm0, XMMWORD PTR [eax]
; File d:\programming\mathter\mathter\vector.hpp

; 641  : 		return *this;

	mov	eax, ecx
; File d:\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm0, XMMWORD PTR [ecx]
; File d:\programming\mathter\mathter\vector.hpp

; 334  : 		simd = Simd4f::mul(simd, rhs.simd);

	movups	XMMWORD PTR [ecx], xmm0

; 642  : 	}

	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
??X?$Vector@M$02@@QAEAAV0@ABV0@@Z ENDP			; Vector<float,3>::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myend, COMDAT
; _this$ = ecx

; 676  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 677  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@QBEABQAV?$Matrix@M$02$02$0A@$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@V?$Vector@M$02@@M$0A@@?$Vector@M$03@@IAEXABV?$Vector@M$02@@ABM@Z
_TEXT	SEGMENT
_head$ = 8						; size = 4
_<rest_0>$ = 12						; size = 4
??$Assign@V?$Vector@M$02@@M$0A@@?$Vector@M$03@@IAEXABV?$Vector@M$02@@ABM@Z PROC ; Vector<float,4>::Assign<Vector<float,3>,float,0>, COMDAT
; _this$ = ecx

; 793  : 	void Assign(const Head& head, const Rest&... rest) {

	push	ebp
	mov	ebp, esp

; 768  : 				target.data[StartIdx + i] = GetVectorElement<Head>::Get(head, i);

	mov	edx, DWORD PTR _head$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _<rest_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+12], eax

; 794  : 		// message("Assign(concat...)");
; 795  : 
; 796  : 		constexpr int ArgDim = SumDimensions<Head, Rest...>::value;
; 797  : 		static_assert(ArgDim == D, "The sum of dimensions of arguments must match the dimension of the vector.");
; 798  : 		AssignHelper<ArgDim>::Assign<0, Head, Rest...>(*this, head, rest...);
; 799  : 	}

	pop	ebp
	ret	8
??$Assign@V?$Vector@M$02@@M$0A@@?$Vector@M$03@@IAEXABV?$Vector@M$02@@ABM@Z ENDP ; Vector<float,4>::Assign<Vector<float,3>,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@IAEXABMABV?$Vector@M$02@@@Z
_TEXT	SEGMENT
_head$ = 8						; size = 4
_<rest_0>$ = 12						; size = 4
??$Assign@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@IAEXABMABV?$Vector@M$02@@@Z PROC ; Vector<float,4>::Assign<float,Vector<float,3>,0>, COMDAT
; _this$ = ecx

; 793  : 	void Assign(const Head& head, const Rest&... rest) {

	push	ebp
	mov	ebp, esp

; 768  : 				target.data[StartIdx + i] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR _head$[ebp]
	mov	edx, DWORD PTR _<rest_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+12], eax

; 794  : 		// message("Assign(concat...)");
; 795  : 
; 796  : 		constexpr int ArgDim = SumDimensions<Head, Rest...>::value;
; 797  : 		static_assert(ArgDim == D, "The sum of dimensions of arguments must match the dimension of the vector.");
; 798  : 		AssignHelper<ArgDim>::Assign<0, Head, Rest...>(*this, head, rest...);
; 799  : 	}

	pop	ebp
	ret	8
??$Assign@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@IAEXABMABV?$Vector@M$02@@@Z ENDP ; Vector<float,4>::Assign<float,Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 346  : 	{	// subtract two durations

	push	ebp
	mov	ebp, esp

; 347  : 	typedef typename common_type<
; 348  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 349  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	sub	esi, DWORD PTR [eax]

; 112  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx], esi

; 347  : 	typedef typename common_type<
; 348  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 349  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sbb	edx, DWORD PTR [eax+4]
	mov	eax, ecx

; 112  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx+4], edx

; 350  : 	}

	pop	esi
	pop	ebp
	ret	0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$distance@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAHPBV?$Matrix@M$02$02$0A@$00@@0@Z
_TEXT	SEGMENT
??$distance@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAHPBV?$Matrix@M$02$02$0A@$00@@0@Z PROC ; std::distance<Matrix<float,3,3,0,1> const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1106 : 	return (_Last - _First);

	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
; 1114 : 	}

	ret	0
??$distance@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAHPBV?$Matrix@M$02$02$0A@$00@@0@Z ENDP ; std::distance<Matrix<float,3,3,0,1> const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Ucopy@PBV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PBV2@0PAV2@@Z
_TEXT	SEGMENT
$T3 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PBV2@0PAV2@@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Ucopy<Matrix<float,3,3,0,1> const *>, COMDAT
; _this$dead$ = ecx

; 1858 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	mov	edx, DWORD PTR __Last$[ebp]
	push	ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 876  : 	return {};

	mov	BYTE PTR $T3[ebp], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T3[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	call	??$_Uninitialized_copy_al_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
	add	esp, 16					; 00000010H
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1860 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PBV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PBV2@0PAV2@@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Ucopy<Matrix<float,3,3,0,1> const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$next@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAPBV?$Matrix@M$02$02$0A@$00@@PBV1@H@Z
_TEXT	SEGMENT
??$next@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAPBV?$Matrix@M$02$02$0A@$00@@PBV1@H@Z PROC ; std::next<Matrix<float,3,3,0,1> const *>, COMDAT
; __First$ = ecx
; __Off$ = edx

; 1079 : 	_Where += _Off;

	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 4
	add	eax, ecx

; 1120 : 	static_assert(is_base_of<input_iterator_tag, _Iter_cat_t<_InIt>>::value,
; 1121 : 		"next requires input iterator");
; 1122 : 
; 1123 : 	_STD advance(_First, _Off);
; 1124 : 	return (_First);
; 1125 : 	}

	ret	0
??$next@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAPBV?$Matrix@M$02$02$0A@$00@@PBV1@H@Z ENDP ; std::next<Matrix<float,3,3,0,1> const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@@Z PROC ; std::_Copy_unchecked<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2326 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp

; 2327 : 		// note: _Copy_unchecked is called directly from elsewhere in the STL
; 2328 : 	return (_Copy_unchecked1(_First, _Last,

	mov	eax, DWORD PTR __Dest$[ebp]

; 2309 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	ecx, edx
	je	SHORT $LN7@Copy_unche
	npad	6
$LL8@Copy_unche:

; 2310 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [eax], xmm0
	movups	xmm0, XMMWORD PTR [ecx+16]
	movups	XMMWORD PTR [eax+16], xmm0
	movups	xmm0, XMMWORD PTR [ecx+32]
	add	ecx, 48					; 00000030H
	movups	XMMWORD PTR [eax+32], xmm0
	add	eax, 48					; 00000030H
	cmp	ecx, edx
	jne	SHORT $LL8@Copy_unche
$LN7@Copy_unche:

; 2329 : 		_Dest, _Ptr_copy_cat(_First, _Dest)));
; 2330 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@@Z ENDP ; std::_Copy_unchecked<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@@Z
_TEXT	SEGMENT
??$_Unchecked@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@@Z PROC ; std::_Unchecked<Matrix<float,3,3,0,1> *>, COMDAT
; __Src$ = ecx

; 451  : 	return (_Src);

	mov	eax, ecx

; 452  : 	}

	ret	0
??$_Unchecked@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@@Z ENDP ; std::_Unchecked<Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Assign_range@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Oldsize$1$ = 8					; size = 4
$T68 = 8						; size = 1
$T51 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> *>, COMDAT
; _this$ = ecx

; 1357 : 		{	// assign [_First, _Last), forward iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1357 : 		{	// assign [_First, _Last), forward iterators

	push	ebx
	push	esi
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	mov	esi, DWORD PTR __First$[ebp]
	sub	edx, esi
	imul	edx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1357 : 		{	// assign [_First, _Last), forward iterators

	mov	DWORD PTR _this$1$[ebp], ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	sar	edx, 3
	mov	ebx, edx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1357 : 		{	// assign [_First, _Last), forward iterators

	push	edi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	sub	ecx, edi
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 1106 : 	return (_Last - _First);

	shr	ebx, 31					; 0000001fH
	add	ebx, edx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _this$1$[ebp]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR [ecx+8]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	add	eax, edx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	ecx, edi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1358 : 		const size_type _Newsize = _STD distance(_First, _Last);
; 1359 : 
; 1360 : 		this->_Orphan_all();
; 1361 : 
; 1362 : 		const size_type _Oldsize = size();
; 1363 : 		const size_type _Oldcapacity = capacity();
; 1364 : 
; 1365 : 		if (_Newsize > _Oldcapacity)

	cmp	ebx, ecx
	jbe	SHORT $LN2@Assign_ran

; 1366 : 			{	// reallocate
; 1367 : 			if (_Newsize > max_size())

	cmp	ebx, 89478485				; 05555555H
	ja	$LN318@Assign_ran

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	edx, ecx
	mov	eax, 89478485				; 05555555H
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	ja	SHORT $LN75@Assign_ran

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow
; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, ebx
	cmovb	eax, ebx
	mov	ebx, eax
$LN75@Assign_ran:

; 1370 : 				}
; 1371 : 
; 1372 : 			const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1373 : 
; 1374 : 			if (this->_Myfirst() != pointer())

	test	edi, edi
	je	SHORT $LN5@Assign_ran

; 1375 : 				{	// destroy and deallocate old array
; 1376 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1377 : 				this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);

	push	ecx
	push	edi
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@I@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::deallocate
$LN5@Assign_ran:

; 1378 : 				}
; 1379 : 
; 1380 : 			_Buy(_Newcapacity);

	push	ebx
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	ecx, ebx
	call	?_Buy@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAE_NI@Z ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Buy
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	mov	edx, DWORD PTR __Last$[ebp]
	push	ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 876  : 	return {};

	mov	BYTE PTR $T51[ebp], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T51[ebp]
	push	ecx
	push	DWORD PTR [ebx]
	mov	ecx, esi
	call	??$_Uninitialized_copy_al_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
	add	esp, 16					; 00000010H
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1382 : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

	mov	DWORD PTR [ebx+4], eax

; 1396 : 			}
; 1397 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@Assign_ran:

; 1383 : 			}
; 1384 : 		else if (_Newsize > _Oldsize)

	mov	eax, DWORD PTR __Oldsize$1$[ebp]
	cmp	ebx, eax
	jbe	SHORT $LN6@Assign_ran
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 1079 : 	_Where += _Off;

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 4
	add	ecx, esi

; 2309 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	esi, ecx
	je	SHORT $LN220@Assign_ran
	npad	1
$LL221@Assign_ran:

; 2310 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [esi]
	lea	edi, DWORD PTR [edi+48]
	movups	XMMWORD PTR [edi-48], xmm0
	movups	xmm0, XMMWORD PTR [esi+16]
	movups	XMMWORD PTR [edi-32], xmm0
	movups	xmm0, XMMWORD PTR [esi+32]
	add	esi, 48					; 00000030H
	movups	XMMWORD PTR [edi-16], xmm0
	cmp	esi, ecx
	jne	SHORT $LL221@Assign_ran
$LN220@Assign_ran:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	push	ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 876  : 	return {};

	mov	BYTE PTR $T68[ebp], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T68[ebp]
	push	ecx
	push	DWORD PTR [ebx+4]
	call	??$_Uninitialized_copy_al_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
	add	esp, 16					; 00000010H
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1388 : 			this->_Mylast() = _Ucopy(_Mid, _Last, this->_Mylast());

	mov	DWORD PTR [ebx+4], eax

; 1396 : 			}
; 1397 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN6@Assign_ran:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 2309 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	eax, DWORD PTR __Last$[ebp]
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1392 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	lea	ecx, DWORD PTR [ebx+ebx*2]
	shl	ecx, 4
	add	ecx, edi
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 2309 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	esi, eax
	je	SHORT $LN288@Assign_ran
$LL289@Assign_ran:

; 2310 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [esi]
	lea	edi, DWORD PTR [edi+48]
	movups	XMMWORD PTR [edi-48], xmm0
	movups	xmm0, XMMWORD PTR [esi+16]
	movups	XMMWORD PTR [edi-32], xmm0
	movups	xmm0, XMMWORD PTR [esi+32]
	add	esi, 48					; 00000030H
	movups	XMMWORD PTR [edi-16], xmm0
	cmp	esi, eax
	jne	SHORT $LL289@Assign_ran
$LN288@Assign_ran:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1395 : 			this->_Mylast() = _Newlast;

	mov	eax, DWORD PTR _this$1$[ebp]

; 1396 : 			}
; 1397 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax+4], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN318@Assign_ran:

; 1368 : 				{
; 1369 : 				_Xlength();

	call	?_Xlength@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@CAXXZ ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Xlength
$LN320@Assign_ran:
$LN317@Assign_ran:
	int	3
??$_Assign_range@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEXPAV?$Matrix@M$02$02$0A@$00@@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Assign_range<Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@0@ABV10@@Z PROC ; std::forward<std::allocator<Matrix<float,3,3,0,1> > const &>, COMDAT
; __Arg$ = ecx

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1336 : 	}

	ret	0
??$forward@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<Matrix<float,3,3,0,1> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1><std::allocator<Matrix<float,3,3,0,1> > const &>, COMDAT
; _this$ = ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >,1><std::allocator<Matrix<float,3,3,0,1> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1139 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,0,1> *,unsigned int,std::allocator<Matrix<float,3,3,0,1> > >, COMDAT
; __First$ = ecx
; __Count$dead$ = edx

; 228  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, 1000000				; 000f4240H
	npad	3
$LL4@Uninitiali:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN19@Uninitiali
	push	48					; 00000030H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
$LN19@Uninitiali:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	esi, 48					; 00000030H
	sub	edi, 1
	jne	SHORT $LL4@Uninitiali

; 233  : 		{
; 234  : 		_Al.construct(_Unfancy(_First));
; 235  : 		}
; 236  : 
; 237  : 	_CATCH_ALL
; 238  : 	_Destroy_range(_Next, _First, _Al);
; 239  : 	_RERAISE;
; 240  : 	_CATCH_END
; 241  : 
; 242  : 	return (_First);

	pop	edi
	mov	eax, esi
	pop	esi

; 243  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n1@PAV?$Matrix@M$02$02$0A@$00@@IV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@IAAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,0,1> *,unsigned int,std::allocator<Matrix<float,3,3,0,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAXPAV?$Matrix@M$02$02$0A@$00@@0AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAXPAV?$Matrix@M$02$02$0A@$00@@0AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Matrix<float,3,3,0,1> >,Matrix<float,3,3,0,1> *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAXPAV?$Matrix@M$02$02$0A@$00@@0AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Matrix<float,3,3,0,1> >,Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 480  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >::_Vector_val<std::_Simple_types<Matrix<float,3,3,0,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@V?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@V?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@@Z PROC ; std::_Unfancy<Matrix<float,3,3,0,1> >, COMDAT
; __Ptr$ = ecx

; 643  : 	return (_Ptr);

	mov	eax, ecx

; 644  : 	}

	ret	0
??$_Unfancy@V?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@@Z ENDP ; std::_Unfancy<Matrix<float,3,3,0,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@$0A@V?$Vector@M$02@@M@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABV?$Vector@M$02@@ABM@Z
_TEXT	SEGMENT
_<rest_0>$ = 8						; size = 4
??$Assign@$0A@V?$Vector@M$02@@M@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABV?$Vector@M$02@@ABM@Z PROC ; Vector<float,4>::AssignHelper<4>::Assign<0,Vector<float,3>,float>, COMDAT
; _target$ = ecx
; _head$ = edx

; 765  : 		static void Assign(Vector& target, const Head& head, const Rest&... rest) {

	push	ebp
	mov	ebp, esp

; 766  : 			constexpr int HeadDim = DimensionOf<Head>::value;
; 767  : 			for (int i = 0; i < HeadDim; ++i) {
; 768  : 				target.data[StartIdx + i] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _<rest_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+12], eax

; 769  : 			}
; 770  : 			return Assign<StartIdx + HeadDim, Rest... >(target, rest...);
; 771  : 		}

	pop	ebp
	ret	0
??$Assign@$0A@V?$Vector@M$02@@M@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABV?$Vector@M$02@@ABM@Z ENDP ; Vector<float,4>::AssignHelper<4>::Assign<0,Vector<float,3>,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@$0A@MV?$Vector@M$02@@@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABMABV?$Vector@M$02@@@Z
_TEXT	SEGMENT
_<rest_0>$ = 8						; size = 4
??$Assign@$0A@MV?$Vector@M$02@@@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABMABV?$Vector@M$02@@@Z PROC ; Vector<float,4>::AssignHelper<4>::Assign<0,float,Vector<float,3> >, COMDAT
; _target$ = ecx
; _head$ = edx

; 765  : 		static void Assign(Vector& target, const Head& head, const Rest&... rest) {

	push	ebp
	mov	ebp, esp

; 766  : 			constexpr int HeadDim = DimensionOf<Head>::value;
; 767  : 			for (int i = 0; i < HeadDim; ++i) {
; 768  : 				target.data[StartIdx + i] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _<rest_0>$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+12], eax

; 769  : 			}
; 770  : 			return Assign<StartIdx + HeadDim, Rest... >(target, rest...);
; 771  : 		}

	pop	ebp
	ret	0
??$Assign@$0A@MV?$Vector@M$02@@@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABMABV?$Vector@M$02@@@Z ENDP ; Vector<float,4>::AssignHelper<4>::Assign<0,float,Vector<float,3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Distance1@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAHPBV?$Matrix@M$02$02$0A@$00@@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Distance1@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAHPBV?$Matrix@M$02$02$0A@$00@@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Distance1<Matrix<float,3,3,0,1> const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1106 : 	return (_Last - _First);

	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1107 : 	}

	ret	0
??$_Distance1@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAHPBV?$Matrix@M$02$02$0A@$00@@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Distance1<Matrix<float,3,3,0,1> const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 117  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 123  : 	return (_Rechecked(_Dest,

	push	ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 876  : 	return {};

	mov	BYTE PTR $T1[ebp], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninitialized_copy_al_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
	add	esp, 16					; 00000010H

; 124  : 		_Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 125  : 			_Ptr_copy_cat(_UFirst, _UDest),
; 126  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>())));
; 127  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$advance@PBV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPBV?$Matrix@M$02$02$0A@$00@@H@Z
_TEXT	SEGMENT
??$advance@PBV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPBV?$Matrix@M$02$02$0A@$00@@H@Z PROC ; std::advance<Matrix<float,3,3,0,1> const *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1079 : 	_Where += _Off;

	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 4
	add	DWORD PTR [ecx], eax

; 1086 : 		// we remove_const_t before _Iter_cat_t for better diagnostics if the user passes an iterator that is const
; 1087 : 	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
; 1088 : 	}

	ret	0
??$advance@PBV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPBV?$Matrix@M$02$02$0A@$00@@H@Z ENDP ; std::advance<Matrix<float,3,3,0,1> const *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_copy_cat@$$CBV?$Matrix@M$02$02$0A@$00@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBV?$Matrix@M$02$02$0A@$00@@ABQAV2@@Z
_TEXT	SEGMENT
??$_Ptr_copy_cat@$$CBV?$Matrix@M$02$02$0A@$00@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBV?$Matrix@M$02$02$0A@$00@@ABQAV2@@Z PROC ; std::_Ptr_copy_cat<Matrix<float,3,3,0,1> const ,Matrix<float,3,3,0,1> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 876  : 	return {};

	xor	al, al

; 877  : 	}

	ret	0
??$_Ptr_copy_cat@$$CBV?$Matrix@M$02$02$0A@$00@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBV?$Matrix@M$02$02$0A@$00@@ABQAV2@@Z ENDP ; std::_Ptr_copy_cat<Matrix<float,3,3,0,1> const ,Matrix<float,3,3,0,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_unchecked1@PBV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_unchecked1@PBV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@U_General_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2308 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2309 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	eax, DWORD PTR __Dest$[ebp]
	cmp	ecx, edx
	je	SHORT $LN3@Copy_unche
	npad	6
$LL4@Copy_unche:

; 2310 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [eax], xmm0
	movups	xmm0, XMMWORD PTR [ecx+16]
	movups	XMMWORD PTR [eax+16], xmm0
	movups	xmm0, XMMWORD PTR [ecx+32]
	add	ecx, 48					; 00000030H
	movups	XMMWORD PTR [eax+32], xmm0
	add	eax, 48					; 00000030H
	cmp	ecx, edx
	jne	SHORT $LL4@Copy_unche
$LN3@Copy_unche:

; 2311 : 	return (_Dest);
; 2312 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked1@PBV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$distance@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAHPAV?$Matrix@M$02$02$0A@$00@@0@Z
_TEXT	SEGMENT
??$distance@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAHPAV?$Matrix@M$02$02$0A@$00@@0@Z PROC ; std::distance<Matrix<float,3,3,0,1> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1106 : 	return (_Last - _First);

	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
; 1114 : 	}

	ret	0
??$distance@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAHPAV?$Matrix@M$02$02$0A@$00@@0@Z ENDP ; std::distance<Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$_Ucopy@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PAV2@00@Z
_TEXT	SEGMENT
$T3 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PAV2@00@Z PROC ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Ucopy<Matrix<float,3,3,0,1> *>, COMDAT
; _this$dead$ = ecx

; 1858 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	mov	edx, DWORD PTR __Last$[ebp]
	push	ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 876  : 	return {};

	mov	BYTE PTR $T3[ebp], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T3[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	call	??$_Uninitialized_copy_al_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
	add	esp, 16					; 00000010H
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\vector

; 1860 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAV?$Matrix@M$02$02$0A@$00@@@?$vector@V?$Matrix@M$02$02$0A@$00@@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@AAEPAV?$Matrix@M$02$02$0A@$00@@PAV2@00@Z ENDP ; std::vector<Matrix<float,3,3,0,1>,std::allocator<Matrix<float,3,3,0,1> > >::_Ucopy<Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$next@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@H@Z
_TEXT	SEGMENT
??$next@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@H@Z PROC ; std::next<Matrix<float,3,3,0,1> *>, COMDAT
; __First$ = ecx
; __Off$ = edx

; 1079 : 	_Where += _Off;

	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 4
	add	eax, ecx

; 1120 : 	static_assert(is_base_of<input_iterator_tag, _Iter_cat_t<_InIt>>::value,
; 1121 : 		"next requires input iterator");
; 1122 : 
; 1123 : 	_STD advance(_First, _Off);
; 1124 : 	return (_First);
; 1125 : 	}

	ret	0
??$next@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@H@Z ENDP ; std::next<Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00@Z PROC ; std::_Copy_unchecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2326 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp

; 2327 : 		// note: _Copy_unchecked is called directly from elsewhere in the STL
; 2328 : 	return (_Copy_unchecked1(_First, _Last,

	mov	eax, DWORD PTR __Dest$[ebp]

; 2309 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	ecx, edx
	je	SHORT $LN7@Copy_unche
	npad	6
$LL8@Copy_unche:

; 2310 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [eax], xmm0
	movups	xmm0, XMMWORD PTR [ecx+16]
	movups	XMMWORD PTR [eax+16], xmm0
	movups	xmm0, XMMWORD PTR [ecx+32]
	add	ecx, 48					; 00000030H
	movups	XMMWORD PTR [eax+32], xmm0
	add	eax, 48					; 00000030H
	cmp	ecx, edx
	jne	SHORT $LL8@Copy_unche
$LN7@Copy_unche:

; 2329 : 		_Dest, _Ptr_copy_cat(_First, _Dest)));
; 2330 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00@Z ENDP ; std::_Copy_unchecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > ><std::allocator<Matrix<float,3,3,0,1> > const &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAE@ABV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > ><std::allocator<Matrix<float,3,3,0,1> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1> >, COMDAT
; _this$dead$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN7@construct
	push	48					; 00000030H
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN7@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	4
??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?Get@?$GetVectorElement@M@?$Vector@M$03@@SAMABMH@Z
_TEXT	SEGMENT
?Get@?$GetVectorElement@M@?$Vector@M$03@@SAMABMH@Z PROC	; Vector<float,4>::GetVectorElement<float>::Get, COMDAT
; _u$ = ecx
; _idx$dead$ = edx

; 751  : 		static U Get(const U& u, int idx) { return u; }

	movss	xmm0, DWORD PTR [ecx]
	ret	0
?Get@?$GetVectorElement@M@?$Vector@M$03@@SAMABMH@Z ENDP	; Vector<float,4>::GetVectorElement<float>::Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ?Get@?$GetVectorElement@V?$Vector@M$02@@@?$Vector@M$03@@SAMABV?$Vector@M$02@@H@Z
_TEXT	SEGMENT
?Get@?$GetVectorElement@V?$Vector@M$02@@@?$Vector@M$03@@SAMABV?$Vector@M$02@@H@Z PROC ; Vector<float,4>::GetVectorElement<Vector<float,3> >::Get, COMDAT
; _u$ = ecx
; _idx$ = edx

; 755  : 		static U Get(const Vector<U, E>& u, int idx) { return u.data[idx]; }

	movss	xmm0, DWORD PTR [ecx+edx*4]
	ret	0
?Get@?$GetVectorElement@V?$Vector@M$02@@@?$Vector@M$03@@SAMABV?$Vector@M$02@@H@Z ENDP ; Vector<float,4>::GetVectorElement<Vector<float,3> >::Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Matrix<float,3,3,0,1> >::allocator<Matrix<float,3,3,0,1> >, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Matrix<float,3,3,0,1> >::allocator<Matrix<float,3,3,0,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@$02M$$V@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABM@Z
_TEXT	SEGMENT
??$Assign@$02M$$V@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABM@Z PROC ; Vector<float,4>::AssignHelper<4>::Assign<3,float>, COMDAT
; _target$ = ecx
; _head$ = edx

; 766  : 			constexpr int HeadDim = DimensionOf<Head>::value;
; 767  : 			for (int i = 0; i < HeadDim; ++i) {
; 768  : 				target.data[StartIdx + i] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+12], eax

; 769  : 			}
; 770  : 			return Assign<StartIdx + HeadDim, Rest... >(target, rest...);
; 771  : 		}

	ret	0
??$Assign@$02M$$V@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABM@Z ENDP ; Vector<float,4>::AssignHelper<4>::Assign<3,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@$00V?$Vector@M$02@@$$V@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABV?$Vector@M$02@@@Z
_TEXT	SEGMENT
??$Assign@$00V?$Vector@M$02@@$$V@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABV?$Vector@M$02@@@Z PROC ; Vector<float,4>::AssignHelper<4>::Assign<1,Vector<float,3> >, COMDAT
; _target$ = ecx
; _head$ = edx

; 766  : 			constexpr int HeadDim = DimensionOf<Head>::value;
; 767  : 			for (int i = 0; i < HeadDim; ++i) {
; 768  : 				target.data[StartIdx + i] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+12], eax

; 769  : 			}
; 770  : 			return Assign<StartIdx + HeadDim, Rest... >(target, rest...);
; 771  : 		}

	ret	0
??$Assign@$00V?$Vector@M$02@@$$V@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@ABV?$Vector@M$02@@@Z ENDP ; Vector<float,4>::AssignHelper<4>::Assign<1,Vector<float,3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAPBV?$Matrix@M$02$02$0A@$00@@PBV1@@Z
_TEXT	SEGMENT
??$_Unchecked@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAPBV?$Matrix@M$02$02$0A@$00@@PBV1@@Z PROC ; std::_Unchecked<Matrix<float,3,3,0,1> const *>, COMDAT
; __Src$ = ecx

; 451  : 	return (_Src);

	mov	eax, ecx

; 452  : 	}

	ret	0
??$_Unchecked@PBV?$Matrix@M$02$02$0A@$00@@@std@@YAPBV?$Matrix@M$02$02$0A@$00@@PBV1@@Z ENDP ; std::_Unchecked<Matrix<float,3,3,0,1> const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
; File d:\programming\mathter\mathter\vector.hpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Last$1$ = -8						; size = 4
__First$1$ = -4						; size = 4
tv489 = 8						; size = 4
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_copy_al_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 86   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	eax, edx
	mov	DWORD PTR __First$1$[ebp], ecx
	mov	ebx, ecx
	mov	DWORD PTR __Last$1$[ebp], eax

; 90   : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	ebx, eax
	je	SHORT $LN63@Uninitiali
	push	esi
	push	edi
	mov	edi, DWORD PTR __Dest$[ebp]
	npad	6
$LL4@Uninitiali:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edi, edi
	je	SHORT $LN51@Uninitiali
	mov	edx, ebx
	lea	ecx, DWORD PTR [edi+8]
	sub	ebx, edi
	mov	esi, 3
	mov	DWORD PTR tv489[ebp], ebx
$LL37@Uninitiali:
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx-8], eax
	lea	ecx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx-12]
	mov	DWORD PTR [ecx-20], eax
	mov	eax, DWORD PTR [ebx+ecx-16]
	mov	DWORD PTR [ecx-16], eax
	sub	esi, 1
	jne	SHORT $LL37@Uninitiali
	mov	ebx, DWORD PTR __First$1$[ebp]
	mov	eax, DWORD PTR __Last$1$[ebp]
$LN51@Uninitiali:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 90   : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	ebx, 48					; 00000030H
	add	edi, 48					; 00000030H
	mov	DWORD PTR __First$1$[ebp], ebx
	cmp	ebx, eax
	jne	SHORT $LL4@Uninitiali

; 91   : 		{
; 92   : 		_Al.construct(_Unfancy(_Dest), *_First);
; 93   : 		}
; 94   : 
; 95   : 	_CATCH_ALL
; 96   : 	_Destroy_range(_Next, _Dest, _Al);
; 97   : 	_RERAISE;
; 98   : 	_CATCH_END
; 99   : 
; 100  : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 101  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@Uninitiali:

; 91   : 		{
; 92   : 		_Al.construct(_Unfancy(_Dest), *_First);
; 93   : 		}
; 94   : 
; 95   : 	_CATCH_ALL
; 96   : 	_Destroy_range(_Next, _Dest, _Al);
; 97   : 	_RERAISE;
; 98   : 	_CATCH_END
; 99   : 
; 100  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	pop	ebx

; 101  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@PBV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> const *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 556  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

	mov	eax, ecx
	ret	4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAAAPAV?$Matrix@M$02$02$0A@$00@@AAPAV1@PAV1@@Z
_TEXT	SEGMENT
??$_Rechecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAAAPAV?$Matrix@M$02$02$0A@$00@@AAPAV1@PAV1@@Z PROC ; std::_Rechecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 481  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 482  : 	return (_Dest);

	mov	eax, ecx

; 483  : 	}

	ret	0
??$_Rechecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAAAPAV?$Matrix@M$02$02$0A@$00@@AAPAV1@PAV1@@Z ENDP ; std::_Rechecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Advance1@PBV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPBV?$Matrix@M$02$02$0A@$00@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Advance1@PBV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPBV?$Matrix@M$02$02$0A@$00@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance1<Matrix<float,3,3,0,1> const *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1079 : 	_Where += _Off;

	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 4
	add	DWORD PTR [ecx], eax

; 1080 : 	}

	ret	0
??$_Advance1@PBV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPBV?$Matrix@M$02$02$0A@$00@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance1<Matrix<float,3,3,0,1> const *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Distance1@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAHPAV?$Matrix@M$02$02$0A@$00@@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Distance1@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAHPAV?$Matrix@M$02$02$0A@$00@@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Distance1<Matrix<float,3,3,0,1> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1106 : 	return (_Last - _First);

	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1107 : 	}

	ret	0
??$_Distance1@PAV?$Matrix@M$02$02$0A@$00@@@std@@YAHPAV?$Matrix@M$02$02$0A@$00@@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Distance1<Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 117  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 123  : 	return (_Rechecked(_Dest,

	push	ecx
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility

; 876  : 	return {};

	mov	BYTE PTR $T1[ebp], 0
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 123  : 	return (_Rechecked(_Dest,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninitialized_copy_al_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
	add	esp, 16					; 00000010H

; 124  : 		_Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 125  : 			_Ptr_copy_cat(_UFirst, _UDest),
; 126  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>())));
; 127  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$advance@PAV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPAV?$Matrix@M$02$02$0A@$00@@H@Z
_TEXT	SEGMENT
??$advance@PAV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPAV?$Matrix@M$02$02$0A@$00@@H@Z PROC ; std::advance<Matrix<float,3,3,0,1> *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1079 : 	_Where += _Off;

	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 4
	add	DWORD PTR [ecx], eax

; 1086 : 		// we remove_const_t before _Iter_cat_t for better diagnostics if the user passes an iterator that is const
; 1087 : 	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
; 1088 : 	}

	ret	0
??$advance@PAV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPAV?$Matrix@M$02$02$0A@$00@@H@Z ENDP ; std::advance<Matrix<float,3,3,0,1> *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_copy_cat@V?$Matrix@M$02$02$0A@$00@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$Matrix@M$02$02$0A@$00@@0@Z
_TEXT	SEGMENT
??$_Ptr_copy_cat@V?$Matrix@M$02$02$0A@$00@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$Matrix@M$02$02$0A@$00@@0@Z PROC ; std::_Ptr_copy_cat<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 876  : 	return {};

	xor	al, al

; 877  : 	}

	ret	0
??$_Ptr_copy_cat@V?$Matrix@M$02$02$0A@$00@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$Matrix@M$02$02$0A@$00@@0@Z ENDP ; std::_Ptr_copy_cat<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Copy_unchecked1@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_unchecked1@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2308 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2309 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	eax, DWORD PTR __Dest$[ebp]
	cmp	ecx, edx
	je	SHORT $LN3@Copy_unche
	npad	6
$LL4@Copy_unche:

; 2310 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [eax], xmm0
	movups	xmm0, XMMWORD PTR [ecx+16]
	movups	XMMWORD PTR [eax+16], xmm0
	movups	xmm0, XMMWORD PTR [ecx+32]
	add	ecx, 48					; 00000030H
	movups	XMMWORD PTR [eax+32], xmm0
	add	eax, 48					; 00000030H
	cmp	ecx, edx
	jne	SHORT $LL4@Copy_unche
$LN3@Copy_unche:

; 2311 : 	return (_Dest);
; 2312 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked1@PAV?$Matrix@M$02$02$0A@$00@@PAV1@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@@Z
_TEXT	SEGMENT
??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN5@construct
	push	48					; 00000030H
	push	0
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN5@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	ret	0
??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@$03@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@@Z
_TEXT	SEGMENT
??$Assign@$03@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@@Z PROC ; Vector<float,4>::AssignHelper<4>::Assign<4>, COMDAT
; _target$dead$ = ecx

; 762  : 		static void Assign(Vector& target) {}

	ret	0
??$Assign@$03@?$AssignHelper@$03@?$Vector@M$03@@SAXAAV1@@Z ENDP ; Vector<float,4>::AssignHelper<4>::Assign<4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
; File d:\programming\mathter\mathter\vector.hpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@ABV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@ABV2@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> const &>, COMDAT
; _this$dead$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN38@construct
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [eax+8]
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, 3
	sub	edi, eax
	npad	5
$LL25@construct:
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx-8], eax
	lea	ecx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx-12]
	mov	DWORD PTR [ecx-20], eax
	mov	eax, DWORD PTR [edi+ecx-16]
	mov	DWORD PTR [ecx-16], eax
	sub	esi, 1
	jne	SHORT $LL25@construct
	pop	edi
	pop	esi
$LN38@construct:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0

; 1098 : 		}

	pop	ebp
	ret	8
??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@ABV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
; File d:\programming\mathter\mathter\vector.hpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Last$1$ = -8						; size = 4
__First$1$ = -4						; size = 4
tv489 = 8						; size = 4
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_copy_al_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 86   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	eax, edx
	mov	DWORD PTR __First$1$[ebp], ecx
	mov	ebx, ecx
	mov	DWORD PTR __Last$1$[ebp], eax

; 90   : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	ebx, eax
	je	SHORT $LN63@Uninitiali
	push	esi
	push	edi
	mov	edi, DWORD PTR __Dest$[ebp]
	npad	6
$LL4@Uninitiali:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edi, edi
	je	SHORT $LN51@Uninitiali
	mov	edx, ebx
	lea	ecx, DWORD PTR [edi+8]
	sub	ebx, edi
	mov	esi, 3
	mov	DWORD PTR tv489[ebp], ebx
$LL37@Uninitiali:
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx-8], eax
	lea	ecx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx-12]
	mov	DWORD PTR [ecx-20], eax
	mov	eax, DWORD PTR [ebx+ecx-16]
	mov	DWORD PTR [ecx-16], eax
	sub	esi, 1
	jne	SHORT $LL37@Uninitiali
	mov	ebx, DWORD PTR __First$1$[ebp]
	mov	eax, DWORD PTR __Last$1$[ebp]
$LN51@Uninitiali:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory

; 90   : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	ebx, 48					; 00000030H
	add	edi, 48					; 00000030H
	mov	DWORD PTR __First$1$[ebp], ebx
	cmp	ebx, eax
	jne	SHORT $LL4@Uninitiali

; 91   : 		{
; 92   : 		_Al.construct(_Unfancy(_Dest), *_First);
; 93   : 		}
; 94   : 
; 95   : 	_CATCH_ALL
; 96   : 	_Destroy_range(_Next, _Dest, _Al);
; 97   : 	_RERAISE;
; 98   : 	_CATCH_END
; 99   : 
; 100  : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 101  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@Uninitiali:

; 91   : 		{
; 92   : 		_Al.construct(_Unfancy(_Dest), *_First);
; 93   : 		}
; 94   : 
; 95   : 	_CATCH_ALL
; 96   : 	_Destroy_range(_Next, _Dest, _Al);
; 97   : 	_RERAISE;
; 98   : 	_CATCH_END
; 99   : 
; 100  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	pop	ebx

; 101  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@PAV?$Matrix@M$02$02$0A@$00@@PAV1@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@YAPAV?$Matrix@M$02$02$0A@$00@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<Matrix<float,3,3,0,1> *,Matrix<float,3,3,0,1> *,std::allocator<Matrix<float,3,3,0,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Advance1@PAV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPAV?$Matrix@M$02$02$0A@$00@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Advance1@PAV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPAV?$Matrix@M$02$02$0A@$00@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance1<Matrix<float,3,3,0,1> *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1079 : 	_Where += _Off;

	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 4
	add	DWORD PTR [ecx], eax

; 1080 : 	}

	ret	0
??$_Advance1@PAV?$Matrix@M$02$02$0A@$00@@H@std@@YAXAAPAV?$Matrix@M$02$02$0A@$00@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance1<Matrix<float,3,3,0,1> *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@@Z PROC ; std::allocator<Matrix<float,3,3,0,1> >::construct<Matrix<float,3,3,0,1> >, COMDAT
; _this$dead$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN3@construct
	push	48					; 00000030H
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	4
??$construct@V?$Matrix@M$02$02$0A@$00@@$$V@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@@Z ENDP ; std::allocator<Matrix<float,3,3,0,1> >::construct<Matrix<float,3,3,0,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABV?$Matrix@M$02$02$0A@$00@@@std@@YAABV?$Matrix@M$02$02$0A@$00@@ABV1@@Z
_TEXT	SEGMENT
??$forward@ABV?$Matrix@M$02$02$0A@$00@@@std@@YAABV?$Matrix@M$02$02$0A@$00@@ABV1@@Z PROC ; std::forward<Matrix<float,3,3,0,1> const &>, COMDAT
; __Arg$ = ecx

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1336 : 	}

	ret	0
??$forward@ABV?$Matrix@M$02$02$0A@$00@@@std@@YAABV?$Matrix@M$02$02$0A@$00@@ABV1@@Z ENDP ; std::forward<Matrix<float,3,3,0,1> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
; File d:\programming\mathter\mathter\vector.hpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@ABV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@ABV3@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, edx

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN33@construct
	push	esi
	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [eax+8]
	mov	edx, esi
	push	edi
	mov	edi, 3
	sub	edx, eax
	npad	6
$LL20@construct:
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx-8], eax
	lea	ecx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [esi-12]
	mov	DWORD PTR [ecx-20], eax
	mov	eax, DWORD PTR [edx+ecx-16]
	mov	DWORD PTR [ecx-16], eax
	sub	edi, 1
	jne	SHORT $LL20@construct
	pop	edi
	pop	esi
$LN33@construct:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0

; 960  : 		}

	pop	ebp
	ret	0
??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@ABV3@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
; File d:\programming\mathter\mathter\vector.hpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@AAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@AAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> &>, COMDAT
; _this$dead$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN38@construct
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [eax+8]
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, 3
	sub	edi, eax
	npad	5
$LL25@construct:
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx-8], eax
	lea	ecx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx-12]
	mov	DWORD PTR [ecx-20], eax
	mov	eax, DWORD PTR [edi+ecx-16]
	mov	DWORD PTR [ecx-16], eax
	sub	esi, 1
	jne	SHORT $LL25@construct
	pop	edi
	pop	esi
$LN38@construct:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0

; 1098 : 		}

	pop	ebp
	ret	8
??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@AAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
; File d:\programming\mathter\mathter\vector.hpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@ABV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@ABV2@@Z PROC ; std::allocator<Matrix<float,3,3,0,1> >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> const &>, COMDAT
; _this$dead$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN29@construct
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [eax+8]
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, 3
	sub	edi, eax
	npad	5
$LL16@construct:
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx-8], eax
	lea	ecx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx-12]
	mov	DWORD PTR [ecx-20], eax
	mov	eax, DWORD PTR [edi+ecx-16]
	mov	DWORD PTR [ecx-16], eax
	sub	esi, 1
	jne	SHORT $LL16@construct
	pop	edi
	pop	esi
$LN29@construct:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0

; 841  : 		}

	pop	ebp
	ret	8
??$construct@V?$Matrix@M$02$02$0A@$00@@ABV1@@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@ABV2@@Z ENDP ; std::allocator<Matrix<float,3,3,0,1> >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAV?$Matrix@M$02$02$0A@$00@@@std@@YAAAV?$Matrix@M$02$02$0A@$00@@AAV1@@Z
_TEXT	SEGMENT
??$forward@AAV?$Matrix@M$02$02$0A@$00@@@std@@YAAAV?$Matrix@M$02$02$0A@$00@@AAV1@@Z PROC ; std::forward<Matrix<float,3,3,0,1> &>, COMDAT
; __Arg$ = ecx

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1336 : 	}

	ret	0
??$forward@AAV?$Matrix@M$02$02$0A@$00@@@std@@YAAAV?$Matrix@M$02$02$0A@$00@@AAV1@@Z ENDP ; std::forward<Matrix<float,3,3,0,1> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
; File d:\programming\mathter\mathter\vector.hpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@AAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@AAV3@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, edx

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN33@construct
	push	esi
	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [eax+8]
	mov	edx, esi
	push	edi
	mov	edi, 3
	sub	edx, eax
	npad	6
$LL20@construct:
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx-8], eax
	lea	ecx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [esi-12]
	mov	DWORD PTR [ecx-20], eax
	mov	eax, DWORD PTR [edx+ecx-16]
	mov	DWORD PTR [ecx-16], eax
	sub	edi, 1
	jne	SHORT $LL20@construct
	pop	edi
	pop	esi
$LN33@construct:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0

; 960  : 		}

	pop	ebp
	ret	0
??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@@std@@SAXAAV?$allocator@V?$Matrix@M$02$02$0A@$00@@@1@PAV?$Matrix@M$02$02$0A@$00@@AAV3@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,3,3,0,1> > >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$Matrix@M$02$02$0A@$00@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$Matrix@M$02$02$0A@$00@@QAE@ABV0@@Z PROC		; Matrix<float,3,3,0,1>::Matrix<float,3,3,0,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, esi
	push	edi
	mov	edi, 3
	lea	edx, DWORD PTR [ebx+8]
	sub	ecx, ebx
$LL6@Matrix:

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+16]
	mov	DWORD PTR [edx-8], eax
	lea	edx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [esi-12]
	mov	DWORD PTR [edx-20], eax
	mov	eax, DWORD PTR [ecx+edx-16]
	mov	DWORD PTR [edx-16], eax
	sub	edi, 1
	jne	SHORT $LL6@Matrix
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
??0?$Matrix@M$02$02$0A@$00@@QAE@ABV0@@Z ENDP		; Matrix<float,3,3,0,1>::Matrix<float,3,3,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\programming\mathter\mathter\vector.hpp
;	COMDAT ??0?$MatrixData@M$02$02$0A@$00@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$MatrixData@M$02$02$0A@$00@@QAE@ABV0@@Z PROC	; MatrixData<float,3,3,0,1>::MatrixData<float,3,3,0,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, esi
	push	edi
	mov	edi, 3
	lea	edx, DWORD PTR [ebx+8]
	sub	ecx, ebx
$LL4@MatrixData:

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+16]
	mov	DWORD PTR [edx-8], eax
	lea	edx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [esi-12]
	mov	DWORD PTR [edx-20], eax
	mov	eax, DWORD PTR [ecx+edx-16]
	mov	DWORD PTR [edx-16], eax
	sub	edi, 1
	jne	SHORT $LL4@MatrixData
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
??0?$MatrixData@M$02$02$0A@$00@@QAE@ABV0@@Z ENDP	; MatrixData<float,3,3,0,1>::MatrixData<float,3,3,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
; File d:\programming\mathter\mathter\vector.hpp
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@AAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@AAV2@@Z PROC ; std::allocator<Matrix<float,3,3,0,1> >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> &>, COMDAT
; _this$dead$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN29@construct
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [eax+8]
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, 3
	sub	edi, eax
	npad	5
$LL16@construct:
; File d:\programming\mathter\mathter\vector.hpp

; 778  : 			data[i] = rhs.data[i];

	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx-8], eax
	lea	ecx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx-12]
	mov	DWORD PTR [ecx-20], eax
	mov	eax, DWORD PTR [edi+ecx-16]
	mov	DWORD PTR [ecx-16], eax
	sub	esi, 1
	jne	SHORT $LL16@construct
	pop	edi
	pop	esi
$LN29@construct:
; File d:\program files\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.10.25017\include\xmemory0

; 841  : 		}

	pop	ebp
	ret	8
??$construct@V?$Matrix@M$02$02$0A@$00@@AAV1@@?$allocator@V?$Matrix@M$02$02$0A@$00@@@std@@QAEXPAV?$Matrix@M$02$02$0A@$00@@AAV2@@Z ENDP ; std::allocator<Matrix<float,3,3,0,1> >::construct<Matrix<float,3,3,0,1>,Matrix<float,3,3,0,1> &>
_TEXT	ENDS
END
