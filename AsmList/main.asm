; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	__imp_?rdstate@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__Query_perf_counter:PROC
EXTRN	__imp___std_terminate:PROC
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp__Query_perf_frequency:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	__security_check_cookie:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
$SG4294967239 DB '{', 00H
$SG4294967238 DB 00H
$SG4294967194 DB 00H
$SG4294967237 DB 09H, 00H
$SG4294967190 DB 00H
$SG4294967186 DB 00H
$SG4294967236 DB '}', 0aH, 00H
$SG4294967182 DB 00H
$SG4294967232 DB ' x ', 00H
$SG4294967235 DB 'Matrix * vec transforms:', 00H
$SG4294967178 DB 00H
$SG4294967174 DB 00H
$SG4294967170 DB 00H
$SG4294967231 DB ' = ', 00H
$SG4294967234 DB '4x4 checks:', 00H
$SG4294967230 DB ' & ', 00H
$SG4294967233 DB '3x3 checks:', 00H
$SG4294967229 DB ' ms', 00H
$SG4294967228 DB 'time 2x2 x 2x2:', 09H, 00H
$SG4294967166 DB 00H
	ORG $+2
$SG4294967227 DB ' ms', 00H
$SG4294967226 DB 'time 3x3 x 3x3:', 09H, 00H
	ORG $+3
$SG4294967225 DB ' ms', 00H
$SG4294967224 DB 'time 4x4 x 4x4:', 09H, 00H
	ORG $+3
$SG4294967223 DB ' ms', 00H
$SG4294967222 DB 'time 4x2 x 2x4:', 09H, 00H
	ORG $+3
$SG4294967221 DB ' ms', 00H
$SG4294967220 DB 'time 2x4 x 4x2:', 09H, 00H
	ORG $+3
$SG4294967219 DB ' ms', 00H
$SG4294967218 DB 'time 4x3 x 3x4:', 09H, 00H
	ORG $+3
$SG4294967217 DB ' ms', 00H
$SG4294967216 DB 'time 3x4 x 4x3:', 09H, 00H
	ORG $+3
$SG4294967195 DB '{', 00H
	ORG $+2
$SG4294967193 DB 09H, 00H
	ORG $+2
$SG4294967192 DB '}', 00H
	ORG $+2
$SG4294967191 DB '{', 00H
	ORG $+2
$SG4294967189 DB 09H, 00H
	ORG $+2
$SG4294967188 DB '}', 0aH, 00H
	ORG $+1
$SG4294967187 DB '{', 00H
	ORG $+2
$SG4294967185 DB 09H, 00H
	ORG $+2
$SG4294967184 DB '}', 0aH, 00H
	ORG $+1
$SG4294967183 DB '{', 00H
	ORG $+2
$SG4294967181 DB 09H, 00H
	ORG $+2
$SG4294967180 DB '}', 0aH, 00H
	ORG $+1
$SG4294967179 DB '{', 00H
	ORG $+2
$SG4294967177 DB 09H, 00H
	ORG $+2
$SG4294967176 DB '}', 0aH, 00H
	ORG $+1
$SG4294967175 DB '{', 00H
	ORG $+2
$SG4294967173 DB 09H, 00H
	ORG $+2
$SG4294967172 DB '}', 0aH, 00H
	ORG $+1
$SG4294967171 DB '{', 00H
	ORG $+2
$SG4294967169 DB 09H, 00H
	ORG $+2
$SG4294967168 DB '}', 0aH, 00H
	ORG $+1
$SG4294967167 DB '{', 00H
	ORG $+2
$SG4294967165 DB 09H, 00H
	ORG $+2
$SG4294967164 DB '}', 0aH, 00H
CONST	ENDS
PUBLIC	??$Assign@$0A@$03@?$Matrix@M$03$03$00@mathter@@IEAAXXZ ; mathter::Matrix<float,4,4,1>::Assign<0,4>
PUBLIC	??$Assign@$02$02H$$V@?$Matrix@M$03$03$00@mathter@@IEAAXH@Z ; mathter::Matrix<float,4,4,1>::Assign<3,3,int>
PUBLIC	??$Assign@$01$02HH@?$Matrix@M$03$03$00@mathter@@IEAAXHH@Z ; mathter::Matrix<float,4,4,1>::Assign<2,3,int,int>
PUBLIC	??$Assign@$00$02HHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<1,3,int,int,int>
PUBLIC	??$Assign@$0A@$02HHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<0,3,int,int,int,int>
PUBLIC	??$Assign@$0A@$03@?$Matrix@M$02$03$00@mathter@@IEAAXXZ ; mathter::Matrix<float,3,4,1>::Assign<0,4>
PUBLIC	??$Assign@$02$01HHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<3,2,int,int,int,int,int>
PUBLIC	??$Assign@$01$02H$$V@?$Matrix@M$02$03$00@mathter@@IEAAXH@Z ; mathter::Matrix<float,3,4,1>::Assign<2,3,int>
PUBLIC	??$Assign@$01$01HHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<2,2,int,int,int,int,int,int>
PUBLIC	??$Assign@$00$02HH@?$Matrix@M$02$03$00@mathter@@IEAAXHH@Z ; mathter::Matrix<float,3,4,1>::Assign<1,3,int,int>
PUBLIC	??$Assign@$00$01HHHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<1,2,int,int,int,int,int,int,int>
PUBLIC	??$Assign@$0A@$02HHH@?$Matrix@M$02$03$00@mathter@@IEAAXHHH@Z ; mathter::Matrix<float,3,4,1>::Assign<0,3,int,int,int>
PUBLIC	??$Assign@$0A@$01HHHHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<0,2,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@$01$01HHHH@?$Matrix@M$02$03$00@mathter@@IEAAXHHHH@Z ; mathter::Matrix<float,3,4,1>::Assign<2,2,int,int,int,int>
PUBLIC	??$Assign@$02$00HHHHHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<3,1,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@$00$01HHHHH@?$Matrix@M$02$03$00@mathter@@IEAAXHHHHH@Z ; mathter::Matrix<float,3,4,1>::Assign<1,2,int,int,int,int,int>
PUBLIC	??$Assign@H$$V$0A@@?$Vector@M$07@mathter@@IEAAXHH@Z ; mathter::Vector<float,8>::Assign<int,0>
PUBLIC	??$Assign@$01$00HHHHHHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<2,1,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@$0A@$01HHHHHH@?$Matrix@M$02$03$00@mathter@@IEAAXHHHHHH@Z ; mathter::Matrix<float,3,4,1>::Assign<0,2,int,int,int,int,int,int>
PUBLIC	??$Assign@HH$0A@@?$Vector@M$07@mathter@@IEAAXHHH@Z ; mathter::Vector<float,8>::Assign<int,int,0>
PUBLIC	??$Assign@$00$00HHHHHHHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<1,1,int,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@$01$00HHHHHHH@?$Matrix@M$02$03$00@mathter@@IEAAXHHHHHHH@Z ; mathter::Matrix<float,3,4,1>::Assign<2,1,int,int,int,int,int,int,int>
PUBLIC	??$Assign@HHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHH@Z ; mathter::Vector<float,8>::Assign<int,int,int,0>
PUBLIC	??$construct@V?$Matrix@M$01$01$00@mathter@@$$V@?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@mathter@@@Z ; std::allocator<mathter::Matrix<float,2,2,1> >::construct<mathter::Matrix<float,2,2,1> >
PUBLIC	??$construct@V?$Matrix@M$02$02$00@mathter@@$$V@?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@mathter@@@Z ; std::allocator<mathter::Matrix<float,3,3,1> >::construct<mathter::Matrix<float,3,3,1> >
PUBLIC	??$construct@V?$Matrix@M$03$03$00@mathter@@$$V@?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@mathter@@@Z ; std::allocator<mathter::Matrix<float,4,4,1> >::construct<mathter::Matrix<float,4,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$01$00@mathter@@$$V@?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@mathter@@@Z ; std::allocator<mathter::Matrix<float,4,2,1> >::construct<mathter::Matrix<float,4,2,1> >
PUBLIC	??$construct@V?$Matrix@M$01$03$00@mathter@@$$V@?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@mathter@@@Z ; std::allocator<mathter::Matrix<float,2,4,1> >::construct<mathter::Matrix<float,2,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$02$00@mathter@@$$V@?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@mathter@@@Z ; std::allocator<mathter::Matrix<float,4,3,1> >::construct<mathter::Matrix<float,4,3,1> >
PUBLIC	??$construct@V?$Matrix@M$02$03$00@mathter@@$$V@?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@mathter@@@Z ; std::allocator<mathter::Matrix<float,3,4,1> >::construct<mathter::Matrix<float,3,4,1> >
PUBLIC	??$Assign@$0A@$00HHHHHHHHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<0,1,int,int,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@$00$00HHHHHHHH@?$Matrix@M$02$03$00@mathter@@IEAAXHHHHHHHH@Z ; mathter::Matrix<float,3,4,1>::Assign<1,1,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@HHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHH@Z ; mathter::Vector<float,8>::Assign<int,int,int,int,0>
PUBLIC	??$construct@V?$Matrix@M$01$01$00@mathter@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$01$01$00@mathter@@@1@PEAV?$Matrix@M$01$01$00@mathter@@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,2,2,1> > >::construct<mathter::Matrix<float,2,2,1> >
PUBLIC	??$construct@V?$Matrix@M$02$02$00@mathter@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$02$02$00@mathter@@@1@PEAV?$Matrix@M$02$02$00@mathter@@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,3,3,1> > >::construct<mathter::Matrix<float,3,3,1> >
PUBLIC	??$construct@V?$Matrix@M$03$03$00@mathter@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$03$00@mathter@@@1@PEAV?$Matrix@M$03$03$00@mathter@@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,4,4,1> > >::construct<mathter::Matrix<float,4,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$01$00@mathter@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$01$00@mathter@@@1@PEAV?$Matrix@M$03$01$00@mathter@@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,4,2,1> > >::construct<mathter::Matrix<float,4,2,1> >
PUBLIC	??$construct@V?$Matrix@M$01$03$00@mathter@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$01$03$00@mathter@@@1@PEAV?$Matrix@M$01$03$00@mathter@@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,2,4,1> > >::construct<mathter::Matrix<float,2,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$02$00@mathter@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$02$00@mathter@@@1@PEAV?$Matrix@M$03$02$00@mathter@@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,4,3,1> > >::construct<mathter::Matrix<float,4,3,1> >
PUBLIC	??$construct@V?$Matrix@M$02$03$00@mathter@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$02$03$00@mathter@@@1@PEAV?$Matrix@M$02$03$00@mathter@@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,3,4,1> > >::construct<mathter::Matrix<float,3,4,1> >
PUBLIC	??$Assign@$02$0A@HHHHHHHHHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHHHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<3,0,int,int,int,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@$0A@$00HHHHHHHHH@?$Matrix@M$02$03$00@mathter@@IEAAXHHHHHHHHH@Z ; mathter::Matrix<float,3,4,1>::Assign<0,1,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@HHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHH@Z ; mathter::Vector<float,8>::Assign<int,int,int,int,int,0>
PUBLIC	??$Assign@M$$V$0A@@?$Vector@M$03@mathter@@IEAAXHM@Z ; mathter::Vector<float,4>::Assign<float,0>
PUBLIC	?Assign@?$Vector@M$02@mathter@@IEAAXH@Z		; mathter::Vector<float,3>::Assign
PUBLIC	??$construct@V?$Matrix@M$01$01$00@mathter@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@mathter@@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >::construct<mathter::Matrix<float,2,2,1> >
PUBLIC	??$construct@V?$Matrix@M$02$02$00@mathter@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@mathter@@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >::construct<mathter::Matrix<float,3,3,1> >
PUBLIC	??$construct@V?$Matrix@M$03$03$00@mathter@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@mathter@@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >::construct<mathter::Matrix<float,4,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$01$00@mathter@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@mathter@@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >::construct<mathter::Matrix<float,4,2,1> >
PUBLIC	??$construct@V?$Matrix@M$01$03$00@mathter@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@mathter@@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >::construct<mathter::Matrix<float,2,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$02$00@mathter@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@mathter@@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >::construct<mathter::Matrix<float,4,3,1> >
PUBLIC	??$construct@V?$Matrix@M$02$03$00@mathter@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@mathter@@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >::construct<mathter::Matrix<float,3,4,1> >
PUBLIC	??$Assign@$01$0A@HHHHHHHHHHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHHHHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<2,0,int,int,int,int,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@$01$0A@HHHHHHHHHH@?$Matrix@M$02$03$00@mathter@@IEAAXHHHHHHHHHH@Z ; mathter::Matrix<float,3,4,1>::Assign<2,0,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@H$$V$0A@@?$Vector@M$02@mathter@@IEAAXHH@Z ; mathter::Vector<float,3>::Assign<int,0>
PUBLIC	??$Assign@HHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHH@Z ; mathter::Vector<float,8>::Assign<int,int,int,int,int,int,0>
PUBLIC	??$Assign@MM$0A@@?$Vector@M$03@mathter@@IEAAXHMM@Z ; mathter::Vector<float,4>::Assign<float,float,0>
PUBLIC	??$Assign@M$$V$0A@@?$Vector@M$02@mathter@@IEAAXHM@Z ; mathter::Vector<float,3>::Assign<float,0>
PUBLIC	??$_Unfancy@V?$Matrix@M$01$01$00@mathter@@@std@@YAPEAV?$Matrix@M$01$01$00@mathter@@PEAV12@@Z ; std::_Unfancy<mathter::Matrix<float,2,2,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$02$02$00@mathter@@@std@@YAPEAV?$Matrix@M$02$02$00@mathter@@PEAV12@@Z ; std::_Unfancy<mathter::Matrix<float,3,3,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$03$03$00@mathter@@@std@@YAPEAV?$Matrix@M$03$03$00@mathter@@PEAV12@@Z ; std::_Unfancy<mathter::Matrix<float,4,4,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$03$01$00@mathter@@@std@@YAPEAV?$Matrix@M$03$01$00@mathter@@PEAV12@@Z ; std::_Unfancy<mathter::Matrix<float,4,2,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$01$03$00@mathter@@@std@@YAPEAV?$Matrix@M$01$03$00@mathter@@PEAV12@@Z ; std::_Unfancy<mathter::Matrix<float,2,4,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$03$02$00@mathter@@@std@@YAPEAV?$Matrix@M$03$02$00@mathter@@PEAV12@@Z ; std::_Unfancy<mathter::Matrix<float,4,3,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$02$03$00@mathter@@@std@@YAPEAV?$Matrix@M$02$03$00@mathter@@PEAV12@@Z ; std::_Unfancy<mathter::Matrix<float,3,4,1> >
PUBLIC	?Get@?$GetVectorElement@V?$Vector@M$02@mathter@@@?$Vector@M$03@mathter@@SAMAEBV?$Vector@M$02@3@H@Z ; mathter::Vector<float,4>::GetVectorElement<mathter::Vector<float,3> >::Get
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@PEAV?$Matrix@M$01$01$00@mathter@@@std@@YAXPEAV?$Matrix@M$01$01$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<mathter::Matrix<float,2,2,1> >,mathter::Matrix<float,2,2,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@PEAV?$Matrix@M$02$02$00@mathter@@@std@@YAXPEAV?$Matrix@M$02$02$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<mathter::Matrix<float,3,3,1> >,mathter::Matrix<float,3,3,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@PEAV?$Matrix@M$03$03$00@mathter@@@std@@YAXPEAV?$Matrix@M$03$03$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<mathter::Matrix<float,4,4,1> >,mathter::Matrix<float,4,4,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@PEAV?$Matrix@M$03$01$00@mathter@@@std@@YAXPEAV?$Matrix@M$03$01$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<mathter::Matrix<float,4,2,1> >,mathter::Matrix<float,4,2,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@PEAV?$Matrix@M$01$03$00@mathter@@@std@@YAXPEAV?$Matrix@M$01$03$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<mathter::Matrix<float,2,4,1> >,mathter::Matrix<float,2,4,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@PEAV?$Matrix@M$03$02$00@mathter@@@std@@YAXPEAV?$Matrix@M$03$02$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<mathter::Matrix<float,4,3,1> >,mathter::Matrix<float,4,3,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@PEAV?$Matrix@M$02$03$00@mathter@@@std@@YAXPEAV?$Matrix@M$02$03$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<mathter::Matrix<float,3,4,1> >,mathter::Matrix<float,3,4,1> * __ptr64>
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$01$00@mathter@@_KV?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<mathter::Matrix<float,2,2,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,2,2,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$02$00@mathter@@_KV?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<mathter::Matrix<float,3,3,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,3,3,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$03$00@mathter@@_KV?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<mathter::Matrix<float,4,4,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,4,4,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$01$00@mathter@@_KV?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<mathter::Matrix<float,4,2,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,4,2,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$03$00@mathter@@_KV?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<mathter::Matrix<float,2,4,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,2,4,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$02$00@mathter@@_KV?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<mathter::Matrix<float,4,3,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,4,3,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$03$00@mathter@@_KV?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<mathter::Matrix<float,3,4,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,3,4,1> > >
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$Assign@$00$0A@HHHHHHHHHHHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHHHHHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<1,0,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@$00$0A@HHHHHHHHHHH@?$Matrix@M$02$03$00@mathter@@IEAAXHHHHHHHHHHH@Z ; mathter::Matrix<float,3,4,1>::Assign<1,0,int,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@IEAAXHAEBV?$Vector@M$02@1@@Z ; mathter::Vector<float,4>::Assign<mathter::Vector<float,3>,0>
PUBLIC	??$Assign@HH$0A@@?$Vector@M$02@mathter@@IEAAXHHH@Z ; mathter::Vector<float,3>::Assign<int,int,0>
PUBLIC	??$Assign@HHHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHHH@Z ; mathter::Vector<float,8>::Assign<int,int,int,int,int,int,int,0>
PUBLIC	??$Assign@MMM$0A@@?$Vector@M$03@mathter@@IEAAXHMMM@Z ; mathter::Vector<float,4>::Assign<float,float,float,0>
PUBLIC	??$Assign@MM$0A@@?$Vector@M$02@mathter@@IEAAXHMM@Z ; mathter::Vector<float,3>::Assign<float,float,0>
PUBLIC	?GetElement@?$MatrixData@M$03$02$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,4,3,1>::GetElement
PUBLIC	??0?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEAA@XZ ; std::allocator<mathter::Matrix<float,2,2,1> >::allocator<mathter::Matrix<float,2,2,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEAA@XZ ; std::allocator<mathter::Matrix<float,3,3,1> >::allocator<mathter::Matrix<float,3,3,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEAA@XZ ; std::allocator<mathter::Matrix<float,4,4,1> >::allocator<mathter::Matrix<float,4,4,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEAA@XZ ; std::allocator<mathter::Matrix<float,4,2,1> >::allocator<mathter::Matrix<float,4,2,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEAA@XZ ; std::allocator<mathter::Matrix<float,2,4,1> >::allocator<mathter::Matrix<float,2,4,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEAA@XZ ; std::allocator<mathter::Matrix<float,4,3,1> >::allocator<mathter::Matrix<float,4,3,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEAA@XZ ; std::allocator<mathter::Matrix<float,3,4,1> >::allocator<mathter::Matrix<float,3,4,1> >
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??X?$Vector@M$03@mathter@@QEAAAEAV01@M@Z	; mathter::Vector<float,4>::operator*=
PUBLIC	?Assign@?$Vector@M$07@mathter@@IEAAXH@Z		; mathter::Vector<float,8>::Assign
PUBLIC	??R?$Matrix@M$03$02$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,4,3,1>::operator()
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,2,1> > >::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,2,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,3,1> > >::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,3,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,4,1> > >::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,4,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,2,1> > >::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,2,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,4,1> > >::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,4,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,3,1> > >::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,3,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,4,1> > >::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,4,1> > >
PUBLIC	?Get@?$GetVectorElement@V?$Vector@M$03@mathter@@@?$Vector@M$07@mathter@@SAMAEBV?$Vector@M$03@3@H@Z ; mathter::Vector<float,8>::GetVectorElement<mathter::Vector<float,4> >::Get
PUBLIC	?Get@?$GetVectorElement@M@?$Vector@M$03@mathter@@SAMAEBMH@Z ; mathter::Vector<float,4>::GetVectorElement<float>::Get
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@PEAV?$Matrix@M$01$01$00@mathter@@@std@@YAXPEAV?$Matrix@M$01$01$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<mathter::Matrix<float,2,2,1> >,mathter::Matrix<float,2,2,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@PEAV?$Matrix@M$02$02$00@mathter@@@std@@YAXPEAV?$Matrix@M$02$02$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<mathter::Matrix<float,3,3,1> >,mathter::Matrix<float,3,3,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@PEAV?$Matrix@M$03$03$00@mathter@@@std@@YAXPEAV?$Matrix@M$03$03$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<mathter::Matrix<float,4,4,1> >,mathter::Matrix<float,4,4,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@PEAV?$Matrix@M$03$01$00@mathter@@@std@@YAXPEAV?$Matrix@M$03$01$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<mathter::Matrix<float,4,2,1> >,mathter::Matrix<float,4,2,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@PEAV?$Matrix@M$01$03$00@mathter@@@std@@YAXPEAV?$Matrix@M$01$03$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<mathter::Matrix<float,2,4,1> >,mathter::Matrix<float,2,4,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@PEAV?$Matrix@M$03$02$00@mathter@@@std@@YAXPEAV?$Matrix@M$03$02$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<mathter::Matrix<float,4,3,1> >,mathter::Matrix<float,4,3,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@PEAV?$Matrix@M$02$03$00@mathter@@@std@@YAXPEAV?$Matrix@M$02$03$00@mathter@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<mathter::Matrix<float,3,4,1> >,mathter::Matrix<float,3,4,1> * __ptr64>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@mathter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,2,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,2,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@mathter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,3,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,3,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@mathter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,4,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@mathter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,2,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,2,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@mathter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,4,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@mathter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,3,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,3,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@mathter@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,4,1> > >,1><>
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$01$01$00@mathter@@_KV?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<mathter::Matrix<float,2,2,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,2,2,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$02$02$00@mathter@@_KV?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<mathter::Matrix<float,3,3,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,3,3,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$03$00@mathter@@_KV?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<mathter::Matrix<float,4,4,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,4,4,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$01$00@mathter@@_KV?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<mathter::Matrix<float,4,2,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,4,2,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$01$03$00@mathter@@_KV?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<mathter::Matrix<float,2,4,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,2,4,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$02$00@mathter@@_KV?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<mathter::Matrix<float,4,3,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,4,3,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$02$03$00@mathter@@_KV?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@mathter@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<mathter::Matrix<float,3,4,1> * __ptr64,unsigned __int64,std::allocator<mathter::Matrix<float,3,4,1> > >
PUBLIC	??$?DMM$02$03$03$00$00MX@mathter@@YA?AV?$Matrix@M$03$03$00@0@AEBV?$Matrix@M$02$03$00@0@AEBV?$Matrix@M$03$02$00@0@@Z ; mathter::operator*<float,float,3,4,4,1,1,float,void>
PUBLIC	??$?DMM$03$02$02$00$00MX@mathter@@YA?AV?$Matrix@M$02$02$00@0@AEBV?$Matrix@M$03$02$00@0@AEBV?$Matrix@M$02$03$00@0@@Z ; mathter::operator*<float,float,4,3,3,1,1,float,void>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?DMM$01$01$01$00$00MX@mathter@@YA?AV?$Matrix@M$01$01$00@0@AEBV10@0@Z ; mathter::operator*<float,float,2,2,2,1,1,float,void>
PUBLIC	??$?HM$03@mathter@@YA?AV?$Vector@M$03@0@AEBV10@0@Z ; mathter::operator+<float,4>
PUBLIC	??$Assign@$0A@$0A@HHHHHHHHHHHHHHHH@?$Matrix@M$03$03$00@mathter@@IEAAXHHHHHHHHHHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Assign<0,0,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$?DM$03@mathter@@YA?AV?$Vector@M$03@0@MAEBV10@@Z ; mathter::operator*<float,4>
PUBLIC	??$Assign@$0A@$0A@HHHHHHHHHHHH@?$Matrix@M$02$03$00@mathter@@IEAAXHHHHHHHHHHHH@Z ; mathter::Matrix<float,3,4,1>::Assign<0,0,int,int,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$Assign@HHHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHHH@Z ; mathter::Vector<float,3>::Assign<int,int,int,int,0>
PUBLIC	??$Assign@MV?$Vector@M$02@mathter@@$0A@@?$Vector@M$03@mathter@@IEAAXHAEBMAEBV?$Vector@M$02@1@@Z ; mathter::Vector<float,4>::Assign<float,mathter::Vector<float,3>,0>
PUBLIC	??$Assign@HHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHH@Z ; mathter::Vector<float,3>::Assign<int,int,int,0>
PUBLIC	??$Assign@V?$Vector@M$03@mathter@@V12@$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@0@Z ; mathter::Vector<float,8>::Assign<mathter::Vector<float,4>,mathter::Vector<float,4>,0>
PUBLIC	??$Assign@HHHHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHHHH@Z ; mathter::Vector<float,8>::Assign<int,int,int,int,int,int,int,int,0>
PUBLIC	??$Assign@V?$Vector@M$03@mathter@@$$V$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@@Z ; mathter::Vector<float,8>::Assign<mathter::Vector<float,4>,0>
PUBLIC	??$Assign@MMMM$0A@@?$Vector@M$03@mathter@@IEAAXHMMMM@Z ; mathter::Vector<float,4>::Assign<float,float,float,float,0>
PUBLIC	??$Assign@MMM$0A@@?$Vector@M$02@mathter@@IEAAXHMMM@Z ; mathter::Vector<float,3>::Assign<float,float,float,0>
PUBLIC	?max_size@?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEBA_KXZ ; std::allocator<mathter::Matrix<float,2,2,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEBA_KXZ ; std::allocator<mathter::Matrix<float,3,3,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEBA_KXZ ; std::allocator<mathter::Matrix<float,4,4,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEBA_KXZ ; std::allocator<mathter::Matrix<float,4,2,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEBA_KXZ ; std::allocator<mathter::Matrix<float,2,4,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEBA_KXZ ; std::allocator<mathter::Matrix<float,4,3,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEBA_KXZ ; std::allocator<mathter::Matrix<float,3,4,1> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$01$01$00@mathter@@@2@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,2,2,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@mathter@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,2,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$02$02$00@mathter@@@2@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,3,3,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@mathter@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,3,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$03$00@mathter@@@2@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,4,4,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@mathter@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,4,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$01$00@mathter@@@2@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,4,2,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@mathter@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,2,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$01$03$00@mathter@@@2@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,2,4,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@mathter@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,4,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$02$00@mathter@@@2@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,4,3,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@mathter@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,3,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$02$03$00@mathter@@@2@@Z ; std::allocator_traits<std::allocator<mathter::Matrix<float,3,4,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@mathter@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,4,1> > >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,2,2,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEAAPEAV?$Matrix@M$01$01$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,2,2,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@mathter@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,2,1> > >,1>::_Get_second
PUBLIC	?_Reset@?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@IEAAXI@Z ; std::linear_congruential<unsigned int,48271,0,2147483647>::_Reset
PUBLIC	?_Init@param_type@?$uniform_real@M@std@@QEAAXMM@Z ; std::uniform_real<float>::param_type::_Init
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,3,3,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEAAPEAV?$Matrix@M$02$02$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,3,3,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@mathter@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,3,1> > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,4,4,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$03$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,4,4,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@mathter@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,4,1> > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,4,2,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$01$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,4,2,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@mathter@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,2,1> > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,2,4,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$01$03$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,2,4,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@mathter@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,4,1> > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,4,3,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$02$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,4,3,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@mathter@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,3,1> > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,3,4,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$02$03$00@mathter@@_K@Z ; std::allocator<mathter::Matrix<float,3,4,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@mathter@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,4,1> > >,1>::_Get_second
PUBLIC	??A?$Vector@M$03@mathter@@QEBAMH@Z		; mathter::Vector<float,4>::operator[]
PUBLIC	??A?$Vector@M$01@mathter@@QEBAMH@Z		; mathter::Vector<float,2>::operator[]
PUBLIC	?max_size@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEBA_KXZ ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEAAXPEAV?$Matrix@M$01$01$00@mathter@@0@Z ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEBAXXZ ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@mathter@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,2,1> > >,1>::_Get_first
PUBLIC	?seed@?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAAXI@Z ; std::linear_congruential<unsigned int,48271,0,2147483647>::seed
PUBLIC	??0?$_Mul_mod@_KI$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z ; std::_Mul_mod<unsigned __int64,unsigned int,48271,0,2147483647>::_Mul_mod<unsigned __int64,unsigned int,48271,0,2147483647>
PUBLIC	??0param_type@?$uniform_real@M@std@@QEAA@MM@Z	; std::uniform_real<float>::param_type::param_type
PUBLIC	?max_size@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEBA_KXZ ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEAAXPEAV?$Matrix@M$02$02$00@mathter@@0@Z ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEBAXXZ ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@mathter@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,3,1> > >,1>::_Get_first
PUBLIC	?max_size@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEBA_KXZ ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$03$00@mathter@@0@Z ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEBAXXZ ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@mathter@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,4,1> > >,1>::_Get_first
PUBLIC	?max_size@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEBA_KXZ ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$01$00@mathter@@0@Z ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEBAXXZ ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@mathter@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,2,1> > >,1>::_Get_first
PUBLIC	?max_size@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEBA_KXZ ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEAAXPEAV?$Matrix@M$01$03$00@mathter@@0@Z ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEBAXXZ ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@mathter@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,2,4,1> > >,1>::_Get_first
PUBLIC	?max_size@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEBA_KXZ ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$02$00@mathter@@0@Z ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEBAXXZ ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@mathter@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,4,3,1> > >,1>::_Get_first
PUBLIC	?max_size@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEBA_KXZ ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEAAXPEAV?$Matrix@M$02$03$00@mathter@@0@Z ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEBAXXZ ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@mathter@@_K@Z ; std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@mathter@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<mathter::Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<mathter::Matrix<float,3,4,1> > >,1>::_Get_first
PUBLIC	?zero@?$duration_values@_J@chrono@std@@SA_JXZ	; std::chrono::duration_values<__int64>::zero
PUBLIC	?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero
PUBLIC	??A?$Vector@M$00@mathter@@QEAAAEAMH@Z		; mathter::Vector<float,1>::operator[]
PUBLIC	?GetElement@?$MatrixData@M$02$03$00@mathter@@IEAAAEAMHH@Z ; mathter::MatrixData<float,3,4,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$00$03$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,1,4,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$00$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,3,1,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$03$00$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,4,1,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$03$03$00@mathter@@IEAAAEAMHH@Z ; mathter::MatrixData<float,4,4,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$03$03$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,4,4,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$02$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,3,3,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$03$01$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,4,2,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$01$03$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,2,4,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$01$01$00@mathter@@IEAAAEAMHH@Z ; mathter::MatrixData<float,2,2,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$01$01$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,2,2,1>::GetElement
PUBLIC	?_Buy@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEAA_N_K@Z ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEAAXXZ ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > > >::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > > >::_Mylast
PUBLIC	??0?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z ; std::linear_congruential<unsigned int,48271,0,2147483647>::linear_congruential<unsigned int,48271,0,2147483647>
PUBLIC	??0?$uniform_real@M@std@@QEAA@MM@Z		; std::uniform_real<float>::uniform_real<float>
PUBLIC	?_Buy@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEAA_N_K@Z ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEAAXXZ ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > > >::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > > >::_Mylast
PUBLIC	?_Buy@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEAA_N_K@Z ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEAAXXZ ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > > >::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > > >::_Mylast
PUBLIC	?_Buy@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEAA_N_K@Z ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEAAXXZ ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > > >::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > > >::_Mylast
PUBLIC	?_Buy@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEAA_N_K@Z ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEAAXXZ ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > > >::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > > >::_Mylast
PUBLIC	?_Buy@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEAA_N_K@Z ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEAAXXZ ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > > >::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > > >::_Mylast
PUBLIC	?_Buy@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEAA_N_K@Z ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEAAXXZ ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > > >::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@mathter@@XZ ; std::_Vector_alloc<std::_Vec_base_types<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > > >::_Mylast
PUBLIC	??R?$Vector@M$02@mathter@@QEBAMH@Z		; mathter::Vector<float,3>::operator()
PUBLIC	?Dot@?$Vector@M$02@mathter@@SAMAEBV12@0@Z	; mathter::Vector<float,3>::Dot
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??0?$linear_congruential_engine@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z ; std::linear_congruential_engine<unsigned int,48271,0,2147483647>::linear_congruential_engine<unsigned int,48271,0,2147483647>
PUBLIC	??R?$Vector@M$03@mathter@@QEBAMH@Z		; mathter::Vector<float,4>::operator()
PUBLIC	??R?$Vector@M$03@mathter@@QEAAAEAMH@Z		; mathter::Vector<float,4>::operator()
PUBLIC	??X?$Vector@M$03@mathter@@QEAAAEAV01@AEBV01@@Z	; mathter::Vector<float,4>::operator*=
PUBLIC	??Y?$Vector@M$03@mathter@@QEAAAEAV01@AEBV01@@Z	; mathter::Vector<float,4>::operator+=
PUBLIC	?Assign@?$Vector@M$03@mathter@@IEAAXH@Z		; mathter::Vector<float,4>::Assign
PUBLIC	?GetElement@?$MatrixData@M$00$02$00@mathter@@IEAAAEAMHH@Z ; mathter::MatrixData<float,1,3,1>::GetElement
PUBLIC	?add@?$VectorSpec@M$00@mathter@@IEAAXAEBV12@@Z	; mathter::VectorSpec<float,1>::add
PUBLIC	?mul@?$VectorSpec@M$00@mathter@@IEAAXM@Z	; mathter::VectorSpec<float,1>::mul
PUBLIC	??R?$Matrix@M$02$00$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,3,1,1>::operator()
PUBLIC	??R?$Matrix@M$02$03$00@mathter@@QEAAAEAMHH@Z	; mathter::Matrix<float,3,4,1>::operator()
PUBLIC	??R?$Matrix@M$00$03$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,1,4,1>::operator()
PUBLIC	?Width@?$MatrixData@M$00$03$00@mathter@@QEBAHXZ	; mathter::MatrixData<float,1,4,1>::Width
PUBLIC	?Height@?$MatrixData@M$00$03$00@mathter@@QEBAHXZ ; mathter::MatrixData<float,1,4,1>::Height
PUBLIC	??R?$Matrix@M$03$00$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,4,1,1>::operator()
PUBLIC	?Width@?$MatrixData@M$03$00$00@mathter@@QEBAHXZ	; mathter::MatrixData<float,4,1,1>::Width
PUBLIC	?Height@?$MatrixData@M$03$00$00@mathter@@QEBAHXZ ; mathter::MatrixData<float,4,1,1>::Height
PUBLIC	??R?$Matrix@M$02$02$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,3,3,1>::operator()
PUBLIC	??R?$Matrix@M$03$03$00@mathter@@QEAAAEAMHH@Z	; mathter::Matrix<float,4,4,1>::operator()
PUBLIC	??R?$Matrix@M$03$03$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,4,4,1>::operator()
PUBLIC	?Width@?$MatrixData@M$03$03$00@mathter@@QEBAHXZ	; mathter::MatrixData<float,4,4,1>::Width
PUBLIC	?Height@?$MatrixData@M$03$03$00@mathter@@QEBAHXZ ; mathter::MatrixData<float,4,4,1>::Height
PUBLIC	?Width@?$MatrixData@M$02$02$00@mathter@@QEBAHXZ	; mathter::MatrixData<float,3,3,1>::Width
PUBLIC	?Height@?$MatrixData@M$02$02$00@mathter@@QEBAHXZ ; mathter::MatrixData<float,3,3,1>::Height
PUBLIC	??R?$Matrix@M$03$01$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,4,2,1>::operator()
PUBLIC	?Width@?$MatrixData@M$03$01$00@mathter@@QEBAHXZ	; mathter::MatrixData<float,4,2,1>::Width
PUBLIC	?Height@?$MatrixData@M$03$01$00@mathter@@QEBAHXZ ; mathter::MatrixData<float,4,2,1>::Height
PUBLIC	??R?$Matrix@M$01$03$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,2,4,1>::operator()
PUBLIC	?Width@?$MatrixData@M$01$03$00@mathter@@QEBAHXZ	; mathter::MatrixData<float,2,4,1>::Width
PUBLIC	?Height@?$MatrixData@M$01$03$00@mathter@@QEBAHXZ ; mathter::MatrixData<float,2,4,1>::Height
PUBLIC	?add@?$VectorSpec@M$01@mathter@@IEAAXAEBV12@@Z	; mathter::VectorSpec<float,2>::add
PUBLIC	?mul@?$VectorSpec@M$01@mathter@@IEAAXM@Z	; mathter::VectorSpec<float,2>::mul
PUBLIC	??R?$Matrix@M$01$01$00@mathter@@QEAAAEAMHH@Z	; mathter::Matrix<float,2,2,1>::operator()
PUBLIC	??R?$Matrix@M$01$01$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,2,2,1>::operator()
PUBLIC	?Width@?$MatrixData@M$01$01$00@mathter@@QEBAHXZ	; mathter::MatrixData<float,2,2,1>::Width
PUBLIC	?Height@?$MatrixData@M$01$01$00@mathter@@QEBAHXZ ; mathter::MatrixData<float,2,2,1>::Height
PUBLIC	??0?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::~vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAAAEAV?$Matrix@M$01$01$00@mathter@@_K@Z ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::operator[]
PUBLIC	??0?$uniform_real_distribution@M@std@@QEAA@MM@Z	; std::uniform_real_distribution<float>::uniform_real_distribution<float>
PUBLIC	??0?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::~vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAAAEAV?$Matrix@M$02$02$00@mathter@@_K@Z ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::operator[]
PUBLIC	??0?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::~vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAAAEAV?$Matrix@M$03$03$00@mathter@@_K@Z ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::operator[]
PUBLIC	??0?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::~vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAAAEAV?$Matrix@M$03$01$00@mathter@@_K@Z ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::operator[]
PUBLIC	??0?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::~vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAAAEAV?$Matrix@M$01$03$00@mathter@@_K@Z ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::operator[]
PUBLIC	??0?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::~vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAAAEAV?$Matrix@M$03$02$00@mathter@@_K@Z ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::operator[]
PUBLIC	??0?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::~vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAAAEAV?$Matrix@M$02$03$00@mathter@@_K@Z ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::operator[]
PUBLIC	??$MatMulSpeedTest@M$02$03$03$02@@YANXZ		; MatMulSpeedTest<float,3,4,4,3>
PUBLIC	??$MatMulSpeedTest@M$03$02$02$03@@YANXZ		; MatMulSpeedTest<float,4,3,3,4>
PUBLIC	??$MatMulSpeedTest@M$01$03$03$01@@YANXZ		; MatMulSpeedTest<float,2,4,4,2>
PUBLIC	??$MatMulSpeedTest@M$03$01$01$03@@YANXZ		; MatMulSpeedTest<float,4,2,2,4>
PUBLIC	??$MatMulSpeedTest@M$03$03$03$03@@YANXZ		; MatMulSpeedTest<float,4,4,4,4>
PUBLIC	??$MatMulSpeedTest@M$02$02$02$02@@YANXZ		; MatMulSpeedTest<float,3,3,3,3>
PUBLIC	??$MatMulSpeedTest@M$01$01$01$01@@YANXZ		; MatMulSpeedTest<float,2,2,2,2>
PUBLIC	??$?DMM$01$03$03$00$00MX@mathter@@YA?AV?$Matrix@M$03$03$00@0@AEBV?$Matrix@M$01$03$00@0@AEBV?$Matrix@M$03$01$00@0@@Z ; mathter::operator*<float,float,2,4,4,1,1,float,void>
PUBLIC	??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@mathter@@@Z ; operator<<<float,2,2,1>
PUBLIC	??$?DMM$03$01$01$00$00MX@mathter@@YA?AV?$Matrix@M$01$01$00@0@AEBV?$Matrix@M$03$01$00@0@AEBV?$Matrix@M$01$03$00@0@@Z ; mathter::operator*<float,float,4,2,2,1,1,float,void>
PUBLIC	??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@mathter@@@Z ; operator<<<float,2,4,1>
PUBLIC	??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@mathter@@@Z ; operator<<<float,4,2,1>
PUBLIC	??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@mathter@@@Z ; operator<<<float,3,3,1>
PUBLIC	??$?DMM$02$02$02$00$00MX@mathter@@YA?AV?$Matrix@M$02$02$00@0@AEBV10@0@Z ; mathter::operator*<float,float,3,3,3,1,1,float,void>
PUBLIC	??$?HMM$03$03$00$00M@mathter@@YA?AV?$Matrix@M$03$03$00@0@AEBV10@0@Z ; mathter::operator+<float,float,4,4,1,1,float>
PUBLIC	??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@mathter@@@Z ; operator<<<float,4,4,1>
PUBLIC	??$?DMM$03$03$03$00$00MX@mathter@@YA?AV?$Matrix@M$03$03$00@0@AEBV10@0@Z ; mathter::operator*<float,float,4,4,4,1,1,float,void>
PUBLIC	??$?0HHHHHHHHHHHHHHHHH@?$Matrix@M$03$03$00@mathter@@QEAA@HHHHHHHHHHHHHHHH@Z ; mathter::Matrix<float,4,4,1>::Matrix<float,4,4,1><int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$?6M$03$00$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$00$00@mathter@@@Z ; operator<<<float,4,1,1>
PUBLIC	??$?6M$00$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$00$03$00@mathter@@@Z ; operator<<<float,1,4,1>
PUBLIC	??$?DMM$02$03$00M@mathter@@YA?AV?$Vector@M$03@0@AEBV?$Vector@M$02@0@AEBV?$Matrix@M$03$02$00@0@@Z ; mathter::operator*<float,float,3,4,1,float>
PUBLIC	??$?DMM$02$00$03$00$00MX@mathter@@YA?AV?$Matrix@M$03$00$00@0@AEBV?$Matrix@M$02$00$00@0@AEBV?$Matrix@M$03$02$00@0@@Z ; mathter::operator*<float,float,3,1,4,1,1,float,void>
PUBLIC	??$?DMM$02$03$00M@mathter@@YA?AV?$Vector@M$03@0@AEBV?$Matrix@M$02$03$00@0@AEBV?$Vector@M$02@0@@Z ; mathter::operator*<float,float,3,4,1,float>
PUBLIC	??$?DMM$02$03$00$00$00MX@mathter@@YA?AV?$Matrix@M$00$03$00@0@AEBV?$Matrix@M$02$03$00@0@AEBV?$Matrix@M$00$02$00@0@@Z ; mathter::operator*<float,float,3,4,1,1,1,float,void>
PUBLIC	??$?0HHHHHHHHHHHHH@?$Matrix@M$02$03$00@mathter@@QEAA@HHHHHHHHHHHH@Z ; mathter::Matrix<float,3,4,1>::Matrix<float,3,4,1><int,int,int,int,int,int,int,int,int,int,int,int,int>
PUBLIC	??$?0HHHH$0A@@?$Vector@M$02@mathter@@QEAA@HHHH@Z ; mathter::Vector<float,3>::Vector<float,3><int,int,int,int,0>
PUBLIC	??$?RX@?$Matrix@M$00$02$00@mathter@@QEAAAEAMH@Z	; mathter::Matrix<float,1,3,1>::operator()<void>
PUBLIC	??$Set@MV?$Vector@M$02@mathter@@$0A@@?$Vector@M$03@mathter@@QEAAAEAV01@AEBMAEBV?$Vector@M$02@1@@Z ; mathter::Vector<float,4>::Set<float,mathter::Vector<float,3>,0>
PUBLIC	??$Set@HHH$0A@@?$Vector@M$02@mathter@@QEAAAEAV01@HHH@Z ; mathter::Vector<float,3>::Set<int,int,int,0>
PUBLIC	??$?0V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@QEAA@AEBV?$Vector@M$02@1@@Z ; mathter::Vector<float,4>::Vector<float,4><mathter::Vector<float,3>,0>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@mathter@@@Z ; operator<<<float,4>
PUBLIC	??$Set@V?$Vector@M$03@mathter@@V12@$0A@@?$Vector@M$07@mathter@@QEAAAEAV01@AEBV?$Vector@M$03@1@0@Z ; mathter::Vector<float,8>::Set<mathter::Vector<float,4>,mathter::Vector<float,4>,0>
PUBLIC	??$Set@HHHHHHHH$0A@@?$Vector@M$07@mathter@@QEAAAEAV01@HHHHHHHH@Z ; mathter::Vector<float,8>::Set<int,int,int,int,int,int,int,int,0>
PUBLIC	??$?0V?$Vector@M$03@mathter@@V01@$0A@@?$Vector@M$07@mathter@@QEAA@AEBV?$Vector@M$03@1@0@Z ; mathter::Vector<float,8>::Vector<float,8><mathter::Vector<float,4>,mathter::Vector<float,4>,0>
PUBLIC	??$?DM$03@mathter@@YA?AV?$Vector@M$03@0@AEBV10@0@Z ; mathter::operator*<float,4>
PUBLIC	??$?0MMMM$0A@@?$Vector@M$03@mathter@@QEAA@MMMM@Z ; mathter::Vector<float,4>::Vector<float,4><float,float,float,float,0>
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	??$?0MMM$0A@@?$Vector@M$02@mathter@@QEAA@MMM@Z	; mathter::Vector<float,3>::Vector<float,3><float,float,float,0>
PUBLIC	??A?$Vector@M$02@mathter@@QEBAMH@Z		; mathter::Vector<float,3>::operator[]
PUBLIC	??A?$Vector@M$00@mathter@@QEBAMH@Z		; mathter::Vector<float,1>::operator[]
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??A?$Vector@M$02@mathter@@QEAAAEAMH@Z		; mathter::Vector<float,3>::operator[]
PUBLIC	??A?$Vector@M$03@mathter@@QEAAAEAMH@Z		; mathter::Vector<float,4>::operator[]
PUBLIC	?GetElement@?$MatrixData@M$00$02$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,1,3,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$03$00@mathter@@IEBAMHH@Z ; mathter::MatrixData<float,3,4,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$00$00@mathter@@IEAAAEAMHH@Z ; mathter::MatrixData<float,3,1,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$03$02$00@mathter@@IEAAAEAMHH@Z ; mathter::MatrixData<float,4,3,1>::GetElement
PUBLIC	??A?$Vector@M$01@mathter@@QEAAAEAMH@Z		; mathter::Vector<float,2>::operator[]
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??R?$Matrix@M$00$02$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,1,3,1>::operator()
PUBLIC	??R?$Matrix@M$02$00$00@mathter@@QEAAAEAMHH@Z	; mathter::Matrix<float,3,1,1>::operator()
PUBLIC	??R?$Matrix@M$02$03$00@mathter@@QEBAMHH@Z	; mathter::Matrix<float,3,4,1>::operator()
PUBLIC	??R?$Matrix@M$03$02$00@mathter@@QEAAAEAMHH@Z	; mathter::Matrix<float,4,3,1>::operator()
PUBLIC	?GetElement@?$MatrixData@M$02$02$00@mathter@@IEAAAEAMHH@Z ; mathter::MatrixData<float,3,3,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$03$01$00@mathter@@IEAAAEAMHH@Z ; mathter::MatrixData<float,4,2,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$01$03$00@mathter@@IEAAAEAMHH@Z ; mathter::MatrixData<float,2,4,1>::GetElement
PUBLIC	??0?$Vector@M$02@mathter@@QEAA@M@Z		; mathter::Vector<float,3>::Vector<float,3>
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	?Transposed@?$Matrix@M$00$02$00@mathter@@QEBA?AV?$Matrix@M$02$00$00@2@XZ ; mathter::Matrix<float,1,3,1>::Transposed
PUBLIC	?Transposed@?$Matrix@M$02$03$00@mathter@@QEBA?AV?$Matrix@M$03$02$00@2@XZ ; mathter::Matrix<float,3,4,1>::Transposed
PUBLIC	??R?$Matrix@M$02$02$00@mathter@@QEAAAEAMHH@Z	; mathter::Matrix<float,3,3,1>::operator()
PUBLIC	??R?$Matrix@M$03$01$00@mathter@@QEAAAEAMHH@Z	; mathter::Matrix<float,4,2,1>::operator()
PUBLIC	??R?$Matrix@M$01$03$00@mathter@@QEAAAEAMHH@Z	; mathter::Matrix<float,2,4,1>::operator()
PUBLIC	main
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?Cross@?$VectorSpec@M$02@mathter@@SA?AV?$Vector@M$02@2@AEBV32@0@Z ; mathter::VectorSpec<float,3>::Cross
PUBLIC	?mul@?$VectorSpec@M$03@mathter@@IEAAXM@Z	; mathter::VectorSpec<float,4>::mul
PUBLIC	?add@?$VectorSpec@M$03@mathter@@IEAAXAEBV12@@Z	; mathter::VectorSpec<float,4>::add
PUBLIC	?mul@?$VectorSpec@M$03@mathter@@IEAAXAEBV12@@Z	; mathter::VectorSpec<float,4>::mul
PUBLIC	?dot@?$VectorSpec@M$02@mathter@@IEBAMAEBV12@@Z	; mathter::VectorSpec<float,3>::dot
PUBLIC	?mul@?$VectorSpec@M$02@mathter@@IEAAXM@Z	; mathter::VectorSpec<float,3>::mul
PUBLIC	?add@?$VectorSpec@M$02@mathter@@IEAAXAEBV12@@Z	; mathter::VectorSpec<float,3>::add
PUBLIC	?spread@?$VectorSpec@M$02@mathter@@IEAAXM@Z	; mathter::VectorSpec<float,3>::spread
PUBLIC	?dot@Simd4f@@SAMAEBT1@0@Z			; Simd4f::dot
PUBLIC	?spread@Simd4f@@SA?AT1@M@Z			; Simd4f::spread
PUBLIC	?mul@Simd4f@@SA?AT1@AEBT1@M@Z			; Simd4f::mul
PUBLIC	?add@Simd4f@@SA?AT1@AEBT1@0@Z			; Simd4f::add
PUBLIC	?mul@Simd4f@@SA?AT1@AEBT1@0@Z			; Simd4f::mul
PUBLIC	?_Deallocate@std@@YAXPEAX_K1@Z			; std::_Deallocate
PUBLIC	?_Allocate@std@@YAPEAX_K0_N@Z			; std::_Allocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?length@?$char_traits@D@std@@SA_KPEBD@Z		; std::char_traits<char>::length
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	__real@3e112e0be826d695
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@40e00000
PUBLIC	__real@41000000
PUBLIC	__real@41100000
PUBLIC	__xmm@3f8000003f8000003f8000003f800000
PUBLIC	__xmm@4040000040400000400000003f800000
PUBLIC	__xmm@40400000404000004080000040a00000
PUBLIC	__xmm@4080000040400000400000003f800000
PUBLIC	__xmm@408000004080000040a0000040c00000
PUBLIC	__xmm@40a0000040a0000040c0000040e00000
PUBLIC	__xmm@40c000004000000040a000003f800000
PUBLIC	__xmm@40c0000040c0000040a0000040800000
PUBLIC	__xmm@40e0000040a00000404000003f800000
PUBLIC	__xmm@410000004080000040e0000040400000
PUBLIC	__xmm@4100000040e0000040c0000040a00000
PUBLIC	__xmm@41100000411000004100000040e00000
PUBLIC	__xmm@41a000004140000040c0000040000000
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH:PROC
EXTRN	__std_terminate:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Assign@?$Vector@M$02@mathter@@IEAAXH@Z DD imagerel $LN11
	DD	imagerel $LN11+40
	DD	imagerel $unwind$?Assign@?$Vector@M$02@mathter@@IEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Assign@H$$V$0A@@?$Vector@M$02@mathter@@IEAAXHH@Z DD imagerel $LN13
	DD	imagerel $LN13+58
	DD	imagerel $unwind$??$Assign@H$$V$0A@@?$Vector@M$02@mathter@@IEAAXHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Assign@V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@IEAAXHAEBV?$Vector@M$02@1@@Z DD imagerel $LN25
	DD	imagerel $LN25+74
	DD	imagerel $unwind$??$Assign@V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@IEAAXHAEBV?$Vector@M$02@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Assign@HH$0A@@?$Vector@M$02@mathter@@IEAAXHHH@Z DD imagerel $LN15
	DD	imagerel $LN15+76
	DD	imagerel $unwind$??$Assign@HH$0A@@?$Vector@M$02@mathter@@IEAAXHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Assign@?$Vector@M$07@mathter@@IEAAXH@Z DD imagerel $LN11
	DD	imagerel $LN11+40
	DD	imagerel $unwind$?Assign@?$Vector@M$07@mathter@@IEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Assign@HHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHH@Z DD imagerel $LN17
	DD	imagerel $LN17+95
	DD	imagerel $unwind$??$Assign@HHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Assign@V?$Vector@M$03@mathter@@$$V$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@@Z DD imagerel $LN26
	DD	imagerel $LN26+83
	DD	imagerel $unwind$??$Assign@V?$Vector@M$03@mathter@@$$V$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@mathter@@_K@Z DD imagerel $LN14@deallocate
	DD	imagerel $LN14@deallocate+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEAAPEAV?$Matrix@M$01$01$00@mathter@@_K@Z DD imagerel $LN15@allocate
	DD	imagerel $LN15@allocate+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEAAPEAV?$Matrix@M$01$01$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@mathter@@_K@Z DD imagerel $LN14@deallocate
	DD	imagerel $LN14@deallocate+114
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEAAPEAV?$Matrix@M$02$02$00@mathter@@_K@Z DD imagerel $LN15@allocate
	DD	imagerel $LN15@allocate+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEAAPEAV?$Matrix@M$02$02$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@mathter@@_K@Z DD imagerel $LN14@deallocate
	DD	imagerel $LN14@deallocate+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$03$00@mathter@@_K@Z DD imagerel $LN15@allocate
	DD	imagerel $LN15@allocate+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@mathter@@_K@Z DD imagerel $LN14@deallocate
	DD	imagerel $LN14@deallocate+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$01$00@mathter@@_K@Z DD imagerel $LN15@allocate
	DD	imagerel $LN15@allocate+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$01$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@mathter@@_K@Z DD imagerel $LN14@deallocate
	DD	imagerel $LN14@deallocate+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$01$03$00@mathter@@_K@Z DD imagerel $LN15@allocate
	DD	imagerel $LN15@allocate+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$01$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@mathter@@_K@Z DD imagerel $LN14@deallocate
	DD	imagerel $LN14@deallocate+114
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$02$00@mathter@@_K@Z DD imagerel $LN15@allocate
	DD	imagerel $LN15@allocate+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$02$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@mathter@@_K@Z DD imagerel $LN14@deallocate
	DD	imagerel $LN14@deallocate+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$02$03$00@mathter@@_K@Z DD imagerel $LN15@allocate
	DD	imagerel $LN15@allocate+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$02$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEBAXXZ DD imagerel $LN4@Xlen
	DD	imagerel $LN4@Xlen+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@mathter@@_K@Z DD imagerel $LN18@allocate
	DD	imagerel $LN18@allocate+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@mathter@@_K@Z DD imagerel $LN17@deallocate
	DD	imagerel $LN17@deallocate+111
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEBAXXZ DD imagerel $LN4@Xlen
	DD	imagerel $LN4@Xlen+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@mathter@@_K@Z DD imagerel $LN18@allocate
	DD	imagerel $LN18@allocate+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@mathter@@_K@Z DD imagerel $LN17@deallocate
	DD	imagerel $LN17@deallocate+114
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEBAXXZ DD imagerel $LN4@Xlen
	DD	imagerel $LN4@Xlen+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@mathter@@_K@Z DD imagerel $LN18@allocate
	DD	imagerel $LN18@allocate+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@mathter@@_K@Z DD imagerel $LN17@deallocate
	DD	imagerel $LN17@deallocate+111
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEBAXXZ DD imagerel $LN4@Xlen
	DD	imagerel $LN4@Xlen+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@mathter@@_K@Z DD imagerel $LN18@allocate
	DD	imagerel $LN18@allocate+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@mathter@@_K@Z DD imagerel $LN17@deallocate
	DD	imagerel $LN17@deallocate+111
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEBAXXZ DD imagerel $LN4@Xlen
	DD	imagerel $LN4@Xlen+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@mathter@@_K@Z DD imagerel $LN18@allocate
	DD	imagerel $LN18@allocate+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@mathter@@_K@Z DD imagerel $LN17@deallocate
	DD	imagerel $LN17@deallocate+111
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEBAXXZ DD imagerel $LN4@Xlen
	DD	imagerel $LN4@Xlen+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@mathter@@_K@Z DD imagerel $LN18@allocate
	DD	imagerel $LN18@allocate+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@mathter@@_K@Z DD imagerel $LN17@deallocate
	DD	imagerel $LN17@deallocate+114
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEBAXXZ DD imagerel $LN4@Xlen
	DD	imagerel $LN4@Xlen+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@mathter@@_K@Z DD imagerel $LN18@allocate
	DD	imagerel $LN18@allocate+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@mathter@@_K@Z DD imagerel $LN17@deallocate
	DD	imagerel $LN17@deallocate+111
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@mathter@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123@Buy
	DD	imagerel $LN123@Buy+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEAAXXZ DD imagerel $LN108@Tidy
	DD	imagerel $LN108@Tidy+146
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123@Buy
	DD	imagerel $LN123@Buy+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEAAXXZ DD imagerel $LN108@Tidy
	DD	imagerel $LN108@Tidy+177
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123@Buy
	DD	imagerel $LN123@Buy+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEAAXXZ DD imagerel $LN108@Tidy
	DD	imagerel $LN108@Tidy+146
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123@Buy
	DD	imagerel $LN123@Buy+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEAAXXZ DD imagerel $LN108@Tidy
	DD	imagerel $LN108@Tidy+146
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123@Buy
	DD	imagerel $LN123@Buy+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEAAXXZ DD imagerel $LN108@Tidy
	DD	imagerel $LN108@Tidy+146
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123@Buy
	DD	imagerel $LN123@Buy+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEAAXXZ DD imagerel $LN108@Tidy
	DD	imagerel $LN108@Tidy+177
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123@Buy
	DD	imagerel $LN123@Buy+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEAAXXZ DD imagerel $LN108@Tidy
	DD	imagerel $LN108@Tidy+146
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Assign@?$Vector@M$03@mathter@@IEAAXH@Z DD imagerel $LN11
	DD	imagerel $LN11+40
	DD	imagerel $unwind$?Assign@?$Vector@M$03@mathter@@IEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@_K@Z DD imagerel $LN270@vector
	DD	imagerel $LN270@vector+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@XZ DD imagerel $LN111@vector
	DD	imagerel $LN111@vector+146
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@_K@Z DD imagerel $LN165@vector
	DD	imagerel $LN165@vector+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@XZ DD imagerel $LN111@vector
	DD	imagerel $LN111@vector+177
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@_K@Z DD imagerel $LN270@vector
	DD	imagerel $LN270@vector+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@XZ DD imagerel $LN111@vector
	DD	imagerel $LN111@vector+146
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@_K@Z DD imagerel $LN270@vector
	DD	imagerel $LN270@vector+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@XZ DD imagerel $LN111@vector
	DD	imagerel $LN111@vector+146
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@_K@Z DD imagerel $LN270@vector
	DD	imagerel $LN270@vector+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@XZ DD imagerel $LN111@vector
	DD	imagerel $LN111@vector+146
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@_K@Z DD imagerel $LN165@vector
	DD	imagerel $LN165@vector+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@XZ DD imagerel $LN111@vector
	DD	imagerel $LN111@vector+177
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@_K@Z DD imagerel $LN270@vector
	DD	imagerel $LN270@vector+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@XZ DD imagerel $LN111@vector
	DD	imagerel $LN111@vector+146
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ DD imagerel $LN598
	DD	imagerel $LN598+1083
	DD	imagerel $unwind$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ DD imagerel $LN598
	DD	imagerel $LN598+1106
	DD	imagerel $unwind$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ DD imagerel $LN597
	DD	imagerel $LN597+980
	DD	imagerel $unwind$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ DD imagerel $LN550
	DD	imagerel $LN550+844
	DD	imagerel $unwind$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ DD imagerel $LN601
	DD	imagerel $LN601+1080
	DD	imagerel $unwind$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ DD imagerel $LN595
	DD	imagerel $LN595+1120
	DD	imagerel $unwind$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ DD imagerel $LN591
	DD	imagerel $LN591+956
	DD	imagerel $unwind$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@mathter@@@Z DD imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@mathter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?DMM$03$01$01$00$00MX@mathter@@YA?AV?$Matrix@M$01$01$00@0@AEBV?$Matrix@M$03$01$00@0@AEBV?$Matrix@M$01$03$00@0@@Z DD imagerel $LN62@operator
	DD	imagerel $LN62@operator+379
	DD	imagerel $unwind$??$?DMM$03$01$01$00$00MX@mathter@@YA?AV?$Matrix@M$01$01$00@0@AEBV?$Matrix@M$03$01$00@0@AEBV?$Matrix@M$01$03$00@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@mathter@@@Z DD imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@mathter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@mathter@@@Z DD imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@mathter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@mathter@@@Z DD imagerel $LN30
	DD	imagerel $LN30+187
	DD	imagerel $unwind$??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@mathter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@mathter@@@Z DD imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@mathter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$03$00$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$00$00@mathter@@@Z DD imagerel $LN30
	DD	imagerel $LN30+157
	DD	imagerel $unwind$??$?6M$03$00$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$00$00@mathter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$00$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$00$03$00@mathter@@@Z DD imagerel $LN30@operator
	DD	imagerel $LN30@operator+119
	DD	imagerel $unwind$??$?6M$00$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$00$03$00@mathter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4@endl
	DD	imagerel $LN4@endl+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@mathter@@@Z DD imagerel $LN13@operator
	DD	imagerel $LN13@operator+158
	DD	imagerel $unwind$??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@mathter@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN114@operator
	DD	imagerel $LN114@operator+455
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+56
	DD	imagerel $unwind$?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN10@Sentry_bas
	DD	imagerel $LN10@Sentry_bas+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8@Sentry_bas
	DD	imagerel $LN8@Sentry_bas+45
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN26@sentry
	DD	imagerel $LN26@sentry+124
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13@sentry
	DD	imagerel $LN13@sentry+72
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN1525
	DD	imagerel $LN1525+3365
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD imagerel $LN8@now
	DD	imagerel $LN8@now+75
	DD	imagerel $unwind$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate@std@@YAXPEAX_K1@Z DD imagerel $LN11@Deallocate
	DD	imagerel $LN11@Deallocate+110
	DD	imagerel $unwind$?_Deallocate@std@@YAXPEAX_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@std@@YAPEAX_K0_N@Z DD imagerel $LN12@Allocate
	DD	imagerel $LN12@Allocate+104
	DD	imagerel $unwind$?_Allocate@std@@YAPEAX_K0_N@Z
pdata	ENDS
;	COMDAT __xmm@41a000004140000040c0000040000000
CONST	SEGMENT
__xmm@41a000004140000040c0000040000000 DB 00H, 00H, 00H, '@', 00H, 00H, 0c0H
	DB	'@', 00H, 00H, '@A', 00H, 00H, 0a0H, 'A'
CONST	ENDS
;	COMDAT __xmm@41100000411000004100000040e00000
CONST	SEGMENT
__xmm@41100000411000004100000040e00000 DB 00H, 00H, 0e0H, '@', 00H, 00H, 00H
	DB	'A', 00H, 00H, 010H, 'A', 00H, 00H, 010H, 'A'
CONST	ENDS
;	COMDAT __xmm@4100000040e0000040c0000040a00000
CONST	SEGMENT
__xmm@4100000040e0000040c0000040a00000 DB 00H, 00H, 0a0H, '@', 00H, 00H, 0c0H
	DB	'@', 00H, 00H, 0e0H, '@', 00H, 00H, 00H, 'A'
CONST	ENDS
;	COMDAT __xmm@410000004080000040e0000040400000
CONST	SEGMENT
__xmm@410000004080000040e0000040400000 DB 00H, 00H, '@@', 00H, 00H, 0e0H, '@'
	DB	00H, 00H, 080H, '@', 00H, 00H, 00H, 'A'
CONST	ENDS
;	COMDAT __xmm@40e0000040a00000404000003f800000
CONST	SEGMENT
__xmm@40e0000040a00000404000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, '@'
	DB	'@', 00H, 00H, 0a0H, '@', 00H, 00H, 0e0H, '@'
CONST	ENDS
;	COMDAT __xmm@40c0000040c0000040a0000040800000
CONST	SEGMENT
__xmm@40c0000040c0000040a0000040800000 DB 00H, 00H, 080H, '@', 00H, 00H, 0a0H
	DB	'@', 00H, 00H, 0c0H, '@', 00H, 00H, 0c0H, '@'
CONST	ENDS
;	COMDAT __xmm@40c000004000000040a000003f800000
CONST	SEGMENT
__xmm@40c000004000000040a000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 0a0H
	DB	'@', 00H, 00H, 00H, '@', 00H, 00H, 0c0H, '@'
CONST	ENDS
;	COMDAT __xmm@40a0000040a0000040c0000040e00000
CONST	SEGMENT
__xmm@40a0000040a0000040c0000040e00000 DB 00H, 00H, 0e0H, '@', 00H, 00H, 0c0H
	DB	'@', 00H, 00H, 0a0H, '@', 00H, 00H, 0a0H, '@'
CONST	ENDS
;	COMDAT __xmm@408000004080000040a0000040c00000
CONST	SEGMENT
__xmm@408000004080000040a0000040c00000 DB 00H, 00H, 0c0H, '@', 00H, 00H, 0a0H
	DB	'@', 00H, 00H, 080H, '@', 00H, 00H, 080H, '@'
CONST	ENDS
;	COMDAT __xmm@4080000040400000400000003f800000
CONST	SEGMENT
__xmm@4080000040400000400000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	'@', 00H, 00H, '@@', 00H, 00H, 080H, '@'
CONST	ENDS
;	COMDAT __xmm@40400000404000004080000040a00000
CONST	SEGMENT
__xmm@40400000404000004080000040a00000 DB 00H, 00H, 0a0H, '@', 00H, 00H, 080H
	DB	'@', 00H, 00H, '@@', 00H, 00H, '@@'
CONST	ENDS
;	COMDAT __xmm@4040000040400000400000003f800000
CONST	SEGMENT
__xmm@4040000040400000400000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	'@', 00H, 00H, '@@', 00H, 00H, '@@'
CONST	ENDS
;	COMDAT __xmm@3f8000003f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f8000003f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3e112e0be826d695
CONST	SEGMENT
__real@3e112e0be826d695 DQ 03e112e0be826d695r	; 1e-09
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@std@@YAPEAX_K0_N@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate@std@@YAXPEAX_K1@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	0154419H
	DD	0129836H
	DD	0138831H
	DD	014782cH
	DD	0156828H
	DD	0347424H
	DD	0336424H
	DD	0323424H
	DD	02c0124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+39
	DD	00H
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+66
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DQ 00000000119930522r ; 2.33398e-314
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DQ	00000000000000000r		; 0
	DD	03H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DQ	00000000000000020r		; 1.58101e-322
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	0ffffffffH
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+57
	DD	00H
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+110
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DQ	00000000000000000r		; 0
	DD	03H
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DQ	00000000000000020r		; 1.58101e-322
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DQ	00000000000000020r		; 1.58101e-322
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0ffffffffH
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+127
	DD	00H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+181
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+195
	DD	02H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+348
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+386
	DD	04H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+406
	DD	05H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+431
	DD	0ffffffffH
	DD	imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	00H
	DD	imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __std_terminate
	DD	04H
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DQ 00000000619930522r ; 1.2944e-313
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	01H
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0bH
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DQ	00000000000000020r		; 1.58101e-322
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 082219H
	DD	0103422H
	DD	0f00d7211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@mathter@@@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$00$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$00$03$00@mathter@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$03$00$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$00$00@mathter@@@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@mathter@@@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@mathter@@@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@mathter@@@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@mathter@@@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?DMM$03$01$01$00$00MX@mathter@@YA?AV?$Matrix@M$01$01$00@0@AEBV?$Matrix@M$03$01$00@0@AEBV?$Matrix@M$01$03$00@0@@Z DD 010501H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@mathter@@@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ DD imagerel ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ+67
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ+77
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ+688
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ+798
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ DD 0d3919H
	DD	0a682bH
	DD	01c7427H
	DD	01b6423H
	DD	01a341fH
	DD	0160113H
	DD	0e006f008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
	DD	092H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ DD imagerel ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ+73
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ+84
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ+802
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ+933
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ DD 0f3e19H
	DD	0c682cH
	DD	0226428H
	DD	0215424H
	DD	0203420H
	DD	01a0113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	07004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
	DD	0b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ DD imagerel ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ+73
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ+84
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ+802
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ+913
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ DD 0f3e19H
	DD	0d682cH
	DD	0246428H
	DD	0235424H
	DD	0223420H
	DD	01c0113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	07004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ DD imagerel ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ+70
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ+81
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ+559
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ+680
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ DD 0d3b19H
	DD	096829H
	DD	0197425H
	DD	0186421H
	DD	017541dH
	DD	0163419H
	DD	014010cH
	DD	0e005H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
	DD	082H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ DD imagerel ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ+70
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ+81
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ+695
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ+816
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ DD 0d3b19H
	DD	0c6829H
	DD	01f7425H
	DD	01e6421H
	DD	01d541dH
	DD	01c3419H
	DD	01a010cH
	DD	0e005H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
	DD	0b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ DD imagerel ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ+73
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ+84
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ+794
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ+918
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ DD 0f3e19H
	DD	0d682cH
	DD	0246428H
	DD	0235424H
	DD	0223420H
	DD	01c0113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	07004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ DD imagerel ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ+73
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ+84
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ+760
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ+915
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ DD 0f3e19H
	DD	0e682cH
	DD	0266428H
	DD	0255424H
	DD	0243420H
	DD	01e0113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	07004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
	DD	0d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Assign@?$Vector@M$03@mathter@@IEAAXH@Z DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$02$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$02$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$01$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$01$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEAAPEAV?$Matrix@M$03$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEAAPEAV?$Matrix@M$02$02$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEAAPEAV?$Matrix@M$01$01$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@mathter@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Assign@V?$Vector@M$03@mathter@@$$V$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@@Z DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Assign@HHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHH@Z DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Assign@?$Vector@M$07@mathter@@IEAAXH@Z DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Assign@HH$0A@@?$Vector@M$02@mathter@@IEAAXHHH@Z DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Assign@V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@IEAAXHAEBV?$Vector@M$02@1@@Z DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Assign@H$$V$0A@@?$Vector@M$02@mathter@@IEAAXHH@Z DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Assign@?$Vector@M$02@mathter@@IEAAXH@Z DD 020501H
	DD	017405H
xdata	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Cross@?$VectorSpec@M$02@mathter@@SA?AV?$Vector@M$02@2@AEBV32@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
?Cross@?$VectorSpec@M$02@mathter@@SA?AV?$Vector@M$02@2@AEBV32@0@Z PROC ; mathter::VectorSpec<float,3>::Cross, COMDAT

; 971  : 	return Vector<float, 3>(lhs.y * rhs.z - lhs.z * rhs.y,

	movss	xmm5, DWORD PTR [r8+8]
	mov	rax, rcx
	movss	xmm0, DWORD PTR [r8+4]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rdx+4]
	mulss	xmm0, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [rdx]
	subss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm4, DWORD PTR [r8+4]
	mulss	xmm0, xmm5

; 838  : 		data[idx] = head;

	movss	DWORD PTR [rcx], xmm1

; 971  : 	return Vector<float, 3>(lhs.y * rhs.z - lhs.z * rhs.y,

	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR [rdx+8]
	mulss	xmm3, DWORD PTR [rdx+4]
	subss	xmm1, xmm0
	subss	xmm4, xmm3

; 838  : 		data[idx] = head;

	movss	DWORD PTR [rcx+4], xmm1
	movss	DWORD PTR [rcx+8], xmm4

; 972  : 							lhs.z * rhs.x - lhs.x * rhs.z,
; 973  : 							lhs.x * rhs.y - lhs.y * rhs.x);
; 974  : }

	ret	0
?Cross@?$VectorSpec@M$02@mathter@@SA?AV?$Vector@M$02@2@AEBV32@0@Z ENDP ; mathter::VectorSpec<float,3>::Cross
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
;	COMDAT main
_TEXT	SEGMENT
scalarMultiplier$114 = 32
matvec_t$ = 32
v3$ = 32
mat7$ = 48
$T98 = 48
$T29 = 48
mat4$ = 48
$T82 = 48
$T69 = 48
vec_t2$ = 48
transform$ = 48
$T44 = 112
$T27 = 112
$T105 = 112
$T88 = 112
mat1$ = 112
vec$ = 176
mat8$ = 176
mat3$ = 176
mat2$ = 176
matvec$ = 240
vec_t$ = 240
matvec_t2$ = 256
__$ArrayPad$ = 272
main	PROC						; COMDAT

; 134  : int main() {

$LN1525:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 352				; 00000160H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 135  : 	// Vector operator test
; 136  : 	Vector<float, 4> v1{ 1.f, 2.f, 3.f, 4.f };
; 137  : 	Vector<float, 4> v2{ 2.f, 3.f, 4.f, 5.f };
; 138  : 	Vector<float, 4> v3 = v1*v2;
; 139  : 
; 140  : 	Vector<float, 8> v4(v2, v3);
; 141  : 	v4.Set(1, 2, 3, 4, 5, 6, 7, 8);
; 142  : 	v4.Set(v3, v2);
; 143  : 
; 144  : 	cout << v3 << endl << endl;

	mov	r15, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A

; 27   : 	os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967195
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR __xmm@41a000004140000040c0000040000000
; File c:\home\programming\mathter\main.cpp

; 27   : 	os << "{";

	mov	rcx, r15
; File c:\home\programming\mathter\mathter\vector.hpp

; 454  : 		simd = Simd4f::mul(simd, rhs.simd);

	movaps	XMMWORD PTR v3$[rsp], xmm0
; File c:\home\programming\mathter\main.cpp

; 27   : 	os << "{";

	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 28   : 	for (int x = 0; x < D; ++x) {

	xor	edi, edi
	lea	r13, OFFSET FLAT:$SG4294967194
	mov	r14d, edi
	mov	esi, edi
	npad	12
$LL102@main:

; 29   : 		os << v(x) << (x == D - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR v3$[rsp+rsi*4]
	lea	rbx, OFFSET FLAT:$SG4294967193
	cmp	r14d, 3
	mov	rcx, r15
	cmove	rbx, r13
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	r14d
	inc	rsi
	cmp	rsi, 4
	jl	SHORT $LL102@main

; 30   : 	}
; 31   : 	os << "}";

	lea	rdx, OFFSET FLAT:$SG4294967192
	mov	rcx, r15
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 135  : 	// Vector operator test
; 136  : 	Vector<float, 4> v1{ 1.f, 2.f, 3.f, 4.f };
; 137  : 	Vector<float, 4> v2{ 2.f, 3.f, 4.f, 5.f };
; 138  : 	Vector<float, 4> v3 = v1*v2;
; 139  : 
; 140  : 	Vector<float, 8> v4(v2, v3);
; 141  : 	v4.Set(1, 2, 3, 4, 5, 6, 7, 8);
; 142  : 	v4.Set(v3, v2);
; 143  : 
; 144  : 	cout << v3 << endl << endl;

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, r15
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	movaps	xmm0, XMMWORD PTR __xmm@40e0000040a00000404000003f800000

; 157  : 	matvec(0) = 1;

	lea	rax, QWORD PTR matvec_t$[rsp]
	mov	r15d, 4
	movaps	XMMWORD PTR vec$[rbp-256], xmm0
	movups	XMMWORD PTR matvec$[rbp-256], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 203  : 		(*this)(x, y) = head;

	mov	DWORD PTR transform$[rsp], 1077936128	; 40400000H
; File c:\home\programming\mathter\main.cpp

; 157  : 	matvec(0) = 1;

	lea	rcx, QWORD PTR transform$[rsp]
	movaps	xmm4, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 203  : 		(*this)(x, y) = head;

	mov	DWORD PTR transform$[rsp+4], 1082130432	; 40800000H
	mov	DWORD PTR transform$[rsp+8], 1084227584	; 40a00000H
; File c:\home\programming\mathter\main.cpp

; 157  : 	matvec(0) = 1;

	mov	edx, r15d
; File c:\home\programming\mathter\mathter\matrix.hpp

; 203  : 		(*this)(x, y) = head;

	mov	DWORD PTR transform$[rsp+16], 1065353216 ; 3f800000H
	mov	DWORD PTR transform$[rsp+20], 1073741824 ; 40000000H
	mov	DWORD PTR transform$[rsp+24], 1077936128 ; 40400000H
	mov	DWORD PTR transform$[rsp+32], 1086324736 ; 40c00000H
	mov	DWORD PTR transform$[rsp+36], 1084227584 ; 40a00000H
	mov	DWORD PTR transform$[rsp+40], 1082130432 ; 40800000H
	mov	DWORD PTR transform$[rsp+48], 1073741824 ; 40000000H
	mov	DWORD PTR transform$[rsp+52], 1077936128 ; 40400000H
	mov	DWORD PTR transform$[rsp+56], 1082130432 ; 40800000H
	npad	7
$LL339@main:
; File c:\home\programming\mathter\mathter\vector.hpp

; 675  : 		return data[idx];

	movss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rcx, QWORD PTR [rcx+16]

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movss	DWORD PTR [rax], xmm0
	lea	rax, QWORD PTR [rax+4]
	sub	rdx, 1
	jne	SHORT $LL339@main

; 231  : 	for (int x = 1; x < Match; ++x) {

	mov	rdx, rdi
	npad	7
$LL342@main:

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rcx, QWORD PTR transform$[rsp+4]
	mov	rax, rdi
	add	rcx, rdx
	npad	5
$LL345@main:

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movss	xmm0, DWORD PTR matvec$[rbp+rdx-252]
; File c:\home\programming\mathter\mathter\vector.hpp

; 95   : 			data[i] *= rhs;

	mulss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16
; File c:\home\programming\mathter\mathter\vector.hpp

; 83   : 			data[i] += rhs.data[i];

	addss	xmm0, DWORD PTR matvec_t$[rsp+rax*4]
	movss	DWORD PTR matvec_t$[rsp+rax*4], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	inc	rax
	cmp	rax, r15
	jl	SHORT $LL345@main
	add	rdx, r15

; 231  : 	for (int x = 1; x < Match; ++x) {

	cmp	rdx, 8
	jl	SHORT $LL342@main

; 338  : 	for (int i = 0; i < Mrow; ++i) {

	mov	rax, rdi
	lea	rcx, QWORD PTR transform$[rsp]
	npad	13
$LL377@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movaps	xmm3, xmm4
	mulps	xmm3, XMMWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 338  : 	for (int i = 0; i < Mrow; ++i) {

	add	rcx, 16
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 82   : 		sum = m.v[0] + m.v[1] + m.v[2] + m.v[3];

	movaps	xmm0, xmm3
	movaps	xmm2, xmm3
	shufps	xmm0, xmm3, 85				; 00000055H
	movaps	xmm1, xmm3
	addss	xmm2, xmm0
	shufps	xmm1, xmm3, 170				; 000000aaH
	shufps	xmm3, xmm3, 255				; 000000ffH
	addss	xmm2, xmm1
	addss	xmm2, xmm3
; File c:\home\programming\mathter\mathter\matrix.hpp

; 339  : 		result(i) = vec.Dot(vec, mat.stripes[i]);

	movss	DWORD PTR vec_t$[rbp+rax*4-256], xmm2
	inc	rax
	cmp	rax, r15
	jl	SHORT $LL377@main
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movaps	xmm4, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
; File c:\home\programming\mathter\mathter\matrix.hpp

; 231  : 	for (int x = 1; x < Match; ++x) {

	lea	rdx, QWORD PTR $T27[rbp-240]

; 180  : 				result(y, x) = (*this)(x, y);

	movss	xmm3, DWORD PTR transform$[rsp+12]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	movaps	xmm2, xmm4
; File c:\home\programming\mathter\mathter\matrix.hpp

; 231  : 	for (int x = 1; x < Match; ++x) {

	mov	eax, 1

; 180  : 				result(y, x) = (*this)(x, y);

	mov	DWORD PTR $T27[rsp], 1077936128		; 40400000H
	mov	DWORD PTR $T27[rsp+4], 1065353216	; 3f800000H

; 231  : 	for (int x = 1; x < Match; ++x) {

	mov	ecx, eax

; 180  : 				result(y, x) = (*this)(x, y);

	mov	DWORD PTR $T27[rsp+8], 1086324736	; 40c00000H
	mov	DWORD PTR $T27[rsp+12], 1073741824	; 40000000H
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm2, XMMWORD PTR $T27[rsp]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 180  : 				result(y, x) = (*this)(x, y);

	mov	DWORD PTR $T27[rbp-240], 1082130432	; 40800000H
	movss	DWORD PTR $T27[rbp-208], xmm3
	mov	DWORD PTR $T27[rbp-224], 1084227584	; 40a00000H
	mov	DWORD PTR $T27[rbp-236], 1073741824	; 40000000H
	mov	DWORD PTR $T27[rbp-220], 1077936128	; 40400000H
	mov	DWORD PTR $T27[rbp-232], 1084227584	; 40a00000H
	mov	DWORD PTR $T27[rbp-216], 1082130432	; 40800000H
	mov	DWORD PTR $T27[rbp-228], 1077936128	; 40400000H
	mov	DWORD PTR $T27[rbp-212], 1082130432	; 40800000H
	mov	DWORD PTR $T29[rsp], 1065353216		; 3f800000H
	mov	DWORD PTR $T29[rsp+16], 1077936128	; 40400000H
	mov	DWORD PTR $T29[rsp+4], 1077936128	; 40400000H
	mov	DWORD PTR $T29[rsp+8], 1084227584	; 40a00000H
	npad	10
$LL435@main:

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [rdx]
	add	rdx, 16
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR $T29[rsp+rcx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 231  : 	for (int x = 1; x < Match; ++x) {

	inc	rcx
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm2, xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 231  : 	for (int x = 1; x < Match; ++x) {

	cmp	rcx, 3
	jl	SHORT $LL435@main
; File c:\home\programming\mathter\mathter\vector.hpp

; 460  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR matvec_t2$[rbp-256], xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 180  : 				result(y, x) = (*this)(x, y);

	lea	rcx, QWORD PTR $T44[rbp-240]
	mov	DWORD PTR $T44[rsp], 1077936128		; 40400000H
	mov	DWORD PTR $T44[rsp+4], 1065353216	; 3f800000H
	mov	DWORD PTR $T44[rsp+8], 1086324736	; 40c00000H
	mov	DWORD PTR $T44[rsp+12], 1073741824	; 40000000H
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	movaps	xmm2, XMMWORD PTR $T44[rsp]
	mulps	xmm2, xmm4
; File c:\home\programming\mathter\mathter\matrix.hpp

; 180  : 				result(y, x) = (*this)(x, y);

	mov	DWORD PTR $T44[rbp-240], 1082130432	; 40800000H
	movss	DWORD PTR $T44[rbp-208], xmm3
	mov	DWORD PTR $T44[rbp-224], 1084227584	; 40a00000H
	mov	DWORD PTR $T44[rbp-236], 1073741824	; 40000000H
	mov	DWORD PTR $T44[rbp-220], 1077936128	; 40400000H
	mov	DWORD PTR $T44[rbp-232], 1084227584	; 40a00000H
	mov	DWORD PTR $T44[rbp-216], 1082130432	; 40800000H
	mov	DWORD PTR $T44[rbp-228], 1077936128	; 40400000H
	mov	DWORD PTR $T44[rbp-212], 1082130432	; 40800000H
	npad	3
$LL487@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR vec$[rbp+rax*4-256]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 328  : 	for (int i = 1; i < Vd; ++i) {

	inc	rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 926  : 	auto tmp = rhs;

	movaps	xmm1, XMMWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 328  : 	for (int i = 1; i < Vd; ++i) {

	add	rcx, 16
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm2, xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 328  : 	for (int i = 1; i < Vd; ++i) {

	cmp	rax, 3
	jl	SHORT $LL487@main
; File c:\home\programming\mathter\main.cpp

; 172  : 	cout << "Matrix * vec transforms:" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967235
; File c:\home\programming\mathter\mathter\vector.hpp

; 460  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR vec_t2$[rsp], xmm2
; File c:\home\programming\mathter\main.cpp

; 172  : 	cout << "Matrix * vec transforms:" << endl;

	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 173  : 	cout << matvec_t << endl

	mov	rsi, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A

; 15   : 	for (int y = 0; y < mat.Height(); ++y) {

	mov	rbx, rdi
	npad	14
$LL518@main:

; 16   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967191
	mov	rcx, rsi
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 18   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR matvec_t$[rsp+rbx*4]
	mov	rcx, rsi
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967190
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 19   : 		}
; 20   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967188
	mov	rcx, rsi
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	rbx
	cmp	rbx, r15
	jl	SHORT $LL518@main

; 173  : 	cout << matvec_t << endl

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rsi
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 27   : 	os << "{";

	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967195

; 173  : 	cout << matvec_t << endl

	mov	r12, rax

; 27   : 	os << "{";

	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 28   : 	for (int x = 0; x < D; ++x) {

	mov	r14d, edi
	mov	rsi, rdi
	npad	4
$LL538@main:

; 29   : 		os << v(x) << (x == D - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR vec_t$[rbp+rsi*4-256]
	lea	rbx, OFFSET FLAT:$SG4294967193
	cmp	r14d, 3
	mov	rcx, r12
	cmove	rbx, r13
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	r14d
	inc	rsi
	cmp	rsi, r15
	jl	SHORT $LL538@main

; 30   : 	}
; 31   : 	os << "}";

	lea	rdx, OFFSET FLAT:$SG4294967192
	mov	rcx, r12
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 173  : 	cout << matvec_t << endl

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 16   : 		os << "{";

	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967187

; 173  : 	cout << matvec_t << endl

	mov	r13, rax

; 16   : 		os << "{";

	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	r12, r15
	lea	r14, QWORD PTR matvec_t2$[rbp-256]
	lea	r15, OFFSET FLAT:$SG4294967186

; 17   : 		for (int x = 0; x < mat.Width(); ++x) {

	mov	esi, edi
	npad	11
$LL548@main:

; 18   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [r14]
	lea	rbx, OFFSET FLAT:$SG4294967185
	cmp	esi, 3
	mov	rcx, r13
	cmove	rbx, r15
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	lea	r14, QWORD PTR [r14+4]
	sub	r12, 1
	jne	SHORT $LL548@main

; 19   : 		}
; 20   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967184
	mov	rcx, r13
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 173  : 	cout << matvec_t << endl

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, r13
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 27   : 	os << "{";

	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967195

; 173  : 	cout << matvec_t << endl

	mov	r12, rax

; 27   : 	os << "{";

	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 28   : 	for (int x = 0; x < D; ++x) {

	mov	r14d, edi
	lea	r13, OFFSET FLAT:$SG4294967194
	mov	rsi, rdi
	mov	r15d, 4
	npad	9
$LL565@main:

; 29   : 		os << v(x) << (x == D - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR vec_t2$[rsp+rsi*4]
	lea	rbx, OFFSET FLAT:$SG4294967193
	cmp	r14d, 3
	mov	rcx, r12
	cmove	rbx, r13
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	r14d
	inc	rsi
	cmp	rsi, r15
	jl	SHORT $LL565@main

; 30   : 	}
; 31   : 	os << "}";

	lea	rdx, OFFSET FLAT:$SG4294967192
	mov	rcx, r12
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 173  : 	cout << matvec_t << endl

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 174  : 		<< vec_t << endl 
; 175  : 		<< matvec_t2 << endl 
; 176  : 		<< vec_t2 << endl << endl;
; 177  : 
; 178  : 
; 179  : 
; 180  : 
; 181  : 	// Matrix test types
; 182  : 	using Matrix3x3 = typename std::conditional<false, PlainMat3, Matrix<float, 3, 3>>::type;
; 183  : 	using Matrix4x4 = Matrix<float, 4, 4>;
; 184  : 
; 185  : 
; 186  : 	// correct test mat4x4
; 187  : 	cout << "4x4 checks:" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967234
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	movaps	xmm0, XMMWORD PTR __xmm@4040000040400000400000003f800000
; File c:\home\programming\mathter\mathter\matrix.hpp

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	mov	rax, rdi
	movaps	xmm1, XMMWORD PTR __xmm@40c0000040c0000040a0000040800000
	movaps	xmm2, XMMWORD PTR __xmm@40400000404000004080000040a00000
	movaps	XMMWORD PTR mat1$[rsp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@41100000411000004100000040e00000
	movaps	XMMWORD PTR mat1$[rbp-240], xmm1
	movaps	xmm1, xmm0
	movaps	xmm1, XMMWORD PTR __xmm@40a0000040a0000040c0000040e00000
	movaps	XMMWORD PTR mat1$[rbp-224], xmm0
	movaps	XMMWORD PTR mat1$[rbp-208], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@408000004080000040a0000040c00000
	movaps	XMMWORD PTR mat2$[rbp-240], xmm0
	movaps	xmm0, xmm1
	movaps	XMMWORD PTR mat2$[rbp-224], xmm1
	movaps	XMMWORD PTR mat2$[rbp-208], xmm1
	movaps	XMMWORD PTR mat2$[rbp-256], xmm2
	npad	6
$LL836@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR mat1$[rsp+rax]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR $T69[rsp+rax], xmm0
	add	rax, 16

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	cmp	rax, 64					; 00000040H
	jl	SHORT $LL836@main

; 231  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR mat1$[rsp+4]
	mov	r10d, 3
	lea	r8, QWORD PTR mat2$[rbp-240]
	npad	5
$LL839@main:

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T69[rsp]
	mov	rcx, r9
	mov	rdx, r15
	npad	5
$LL842@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 460  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL842@main

; 231  : 	for (int x = 1; x < Match; ++x) {

	add	r8, 16
	add	r9, r15
	sub	r10, 1
	jne	SHORT $LL839@main
; File c:\home\programming\mathter\main.cpp

; 201  : 	cout << mat1 * mat2 << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, QWORD PTR $T69[rsp]
	call	??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@mathter@@@Z ; operator<<<float,4,4,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File c:\home\programming\mathter\mathter\matrix.hpp

; 246  : 	for (int i = 0; i < Rows; ++i) {

	mov	rax, rdi
	npad	12
$LL871@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm1, XMMWORD PTR mat2$[rbp+rax-256]
	addps	xmm1, XMMWORD PTR mat1$[rsp+rax]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 247  : 		result.stripes[i] = lhs.stripes[i] + rhs.stripes[i];

	movaps	XMMWORD PTR $T82[rsp+rax], xmm1
	add	rax, 16

; 246  : 	for (int i = 0; i < Rows; ++i) {

	cmp	rax, 64					; 00000040H
	jl	SHORT $LL871@main
; File c:\home\programming\mathter\main.cpp

; 202  : 	cout << mat1 + mat2 << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, QWORD PTR $T82[rsp]
	call	??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@mathter@@@Z ; operator<<<float,4,4,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 203  : 
; 204  : 
; 205  : 	// correct test mat3x3
; 206  : 	cout << "3x3 checks:" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967233
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 212  : 	mat3(0, 2) = 7;		mat3(1, 2) = 8;		mat3(2, 2) = 9;

	movss	xmm0, DWORD PTR __real@41100000
; File c:\home\programming\mathter\mathter\matrix.hpp

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	mov	rax, rdi
; File c:\home\programming\mathter\main.cpp

; 214  : 	mat4(0, 0) = 5;		mat4(1, 0) = 4;		mat4(2, 0) = 3;

	mov	DWORD PTR mat4$[rsp], 1084227584	; 40a00000H
	mov	DWORD PTR mat4$[rsp+4], 1082130432	; 40800000H
	mov	DWORD PTR mat4$[rsp+8], 1077936128	; 40400000H
; File c:\home\programming\mathter\mathter\matrix.hpp

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	movaps	xmm1, XMMWORD PTR mat4$[rsp]
; File c:\home\programming\mathter\main.cpp

; 212  : 	mat3(0, 2) = 7;		mat3(1, 2) = 8;		mat3(2, 2) = 9;

	movss	DWORD PTR mat3$[rbp-216], xmm0
	mov	DWORD PTR mat3$[rbp-256], 1065353216	; 3f800000H
	mov	DWORD PTR mat3$[rbp-252], 1073741824	; 40000000H
	mov	DWORD PTR mat3$[rbp-248], 1077936128	; 40400000H
	mov	DWORD PTR mat3$[rbp-240], 1082130432	; 40800000H
	mov	DWORD PTR mat3$[rbp-236], 1084227584	; 40a00000H
	mov	DWORD PTR mat3$[rbp-232], 1086324736	; 40c00000H
	mov	DWORD PTR mat3$[rbp-224], 1088421888	; 40e00000H
	mov	DWORD PTR mat3$[rbp-220], 1090519040	; 41000000H

; 215  : 	mat4(0, 1) = 6;		mat4(1, 1) = 5;		mat4(2, 1) = 4;

	mov	DWORD PTR mat4$[rsp+16], 1086324736	; 40c00000H
	mov	DWORD PTR mat4$[rsp+20], 1084227584	; 40a00000H
	mov	DWORD PTR mat4$[rsp+24], 1082130432	; 40800000H

; 216  : 	mat4(0, 2) = 7;		mat4(1, 2) = 6;		mat4(2, 2) = 5;

	mov	DWORD PTR mat4$[rsp+32], 1088421888	; 40e00000H
	mov	DWORD PTR mat4$[rsp+36], 1086324736	; 40c00000H
	mov	DWORD PTR mat4$[rsp+40], 1084227584	; 40a00000H
$LL992@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR mat3$[rbp+rax-256]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR $T88[rsp+rax], xmm0
	add	rax, 16

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	cmp	rax, 48					; 00000030H
	jl	SHORT $LL992@main

; 231  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR mat3$[rbp-252]
	mov	r10d, 2
	lea	r8, QWORD PTR mat4$[rsp+16]
	npad	3
$LL995@main:

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T88[rsp]
	mov	rcx, r9
	mov	edx, 3
	npad	3
$LL998@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rax]
	addps	xmm0, xmm1
; File c:\home\programming\mathter\mathter\vector.hpp

; 400  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL998@main

; 231  : 	for (int x = 1; x < Match; ++x) {

	add	r8, 16
	add	r9, r15
	sub	r10, 1
	jne	SHORT $LL995@main
; File c:\home\programming\mathter\main.cpp

; 218  : 	cout << mat3 * mat4 << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, QWORD PTR $T88[rsp]
	call	??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@mathter@@@Z ; operator<<<float,3,3,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	movaps	xmm8, XMMWORD PTR __xmm@4080000040400000400000003f800000

; 219  : 
; 220  : 	// correct test mat4x2 & 2x4
; 221  : 	Matrix<float, 4, 2> mat7;
; 222  : 	Matrix<float, 2, 4> mat8;
; 223  : 
; 224  : 	mat7(0, 0) = 1;		mat7(1, 0) = 2;		mat7(2, 0) = 3;		mat7(3, 0) = 4;
; 225  : 	mat7(0, 1) = 5;		mat7(1, 1) = 6;		mat7(2, 1) = 7;		mat7(3, 1) = 8;
; 226  : 
; 227  : 	mat8(0, 0) = 1;		mat8(1, 0) = 5;
; 228  : 	mat8(0, 1) = 2;		mat8(1, 1) = 6;
; 229  : 	mat8(0, 2) = 3;		mat8(1, 2) = 7;
; 230  : 	mat8(0, 3) = 4;		mat8(1, 3) = 8;
; 231  : 
; 232  : 	cout << mat7 << " x " << endl;

	lea	rdx, QWORD PTR mat7$[rsp]
	movaps	xmm9, XMMWORD PTR __xmm@4100000040e0000040c0000040a00000
	movaps	xmm6, XMMWORD PTR __xmm@40c000004000000040a000003f800000
	movaps	xmm7, XMMWORD PTR __xmm@410000004080000040e0000040400000
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	movaps	XMMWORD PTR mat7$[rsp], xmm8
	movaps	XMMWORD PTR mat7$[rsp+16], xmm9
	movups	XMMWORD PTR mat8$[rbp-256], xmm6
	movups	XMMWORD PTR mat8$[rbp-240], xmm7
	call	??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@mathter@@@Z ; operator<<<float,4,2,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967232
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 233  : 	cout << mat8 << " = " << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, QWORD PTR mat8$[rbp-256]
	call	??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@mathter@@@Z ; operator<<<float,2,4,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967231
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File c:\home\programming\mathter\mathter\matrix.hpp

; 227  : 		scalarMultiplier = rhs.stripes[0];

	movq	QWORD PTR scalarMultiplier$114[rsp], xmm6
; File c:\home\programming\mathter\mathter\vector.hpp

; 170  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$114[rsp]
	mulss	xmm0, DWORD PTR __real@40a00000

; 171  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$114[rsp+4]
	mulss	xmm1, DWORD PTR __real@40a00000
	movss	DWORD PTR scalarMultiplier$114[rsp], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movq	QWORD PTR $T98[rsp], xmm6
; File c:\home\programming\mathter\mathter\vector.hpp

; 160  : 		this->x += rhs.x;

	movss	xmm2, DWORD PTR $T98[rsp]

; 161  : 		this->y += rhs.y;

	movss	xmm3, DWORD PTR $T98[rsp+4]

; 171  : 		this->y *= rhs;

	movss	DWORD PTR scalarMultiplier$114[rsp+4], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	rax, QWORD PTR scalarMultiplier$114[rsp]

; 233  : 			scalarMultiplier = rhs.stripes[x];

	psrldq	xmm6, 8
	movq	QWORD PTR scalarMultiplier$114[rsp], xmm6
; File c:\home\programming\mathter\mathter\vector.hpp

; 170  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$114[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	QWORD PTR $T98[rsp+8], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 171  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$114[rsp+4]
	mulss	xmm1, DWORD PTR __real@40000000

; 160  : 		this->x += rhs.x;

	movss	xmm4, DWORD PTR $T98[rsp+8]
	addss	xmm2, xmm0

; 161  : 		this->y += rhs.y;

	movss	xmm5, DWORD PTR $T98[rsp+12]
	addss	xmm3, xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movq	QWORD PTR scalarMultiplier$114[rsp], xmm6
; File c:\home\programming\mathter\mathter\vector.hpp

; 170  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$114[rsp]
	mulss	xmm0, DWORD PTR __real@40c00000

; 171  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$114[rsp+4]
	mulss	xmm1, DWORD PTR __real@40c00000

; 160  : 		this->x += rhs.x;

	addss	xmm4, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movq	QWORD PTR scalarMultiplier$114[rsp], xmm7
; File c:\home\programming\mathter\mathter\vector.hpp

; 171  : 		this->y *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$114[rsp+4]
	mulss	xmm0, DWORD PTR __real@40400000

; 161  : 		this->y += rhs.y;

	addss	xmm5, xmm1

; 170  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$114[rsp]
	mulss	xmm1, DWORD PTR __real@40400000

; 161  : 		this->y += rhs.y;

	addss	xmm3, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movq	QWORD PTR scalarMultiplier$114[rsp], xmm7
; File c:\home\programming\mathter\mathter\vector.hpp

; 171  : 		this->y *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$114[rsp+4]
	mulss	xmm0, DWORD PTR __real@40e00000

; 160  : 		this->x += rhs.x;

	addss	xmm2, xmm1

; 170  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$114[rsp]
	mulss	xmm1, DWORD PTR __real@40e00000

; 161  : 		this->y += rhs.y;

	addss	xmm5, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 233  : 			scalarMultiplier = rhs.stripes[x];

	psrldq	xmm7, 8
	movq	QWORD PTR scalarMultiplier$114[rsp], xmm7
; File c:\home\programming\mathter\mathter\vector.hpp

; 170  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$114[rsp]

; 160  : 		this->x += rhs.x;

	addss	xmm4, xmm1

; 171  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$114[rsp+4]
	mulss	xmm0, DWORD PTR __real@40800000
	mulss	xmm1, DWORD PTR __real@40800000
; File c:\home\programming\mathter\main.cpp

; 234  : 	cout << mat7 * mat8 << " & " << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
; File c:\home\programming\mathter\mathter\vector.hpp

; 160  : 		this->x += rhs.x;

	addss	xmm2, xmm0

; 161  : 		this->y += rhs.y;

	addss	xmm3, xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movq	QWORD PTR scalarMultiplier$114[rsp], xmm7
; File c:\home\programming\mathter\mathter\vector.hpp

; 170  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$114[rsp]
; File c:\home\programming\mathter\main.cpp

; 234  : 	cout << mat7 * mat8 << " & " << endl;

	lea	rdx, QWORD PTR $T98[rsp]
; File c:\home\programming\mathter\mathter\vector.hpp

; 171  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$114[rsp+4]
	mulss	xmm0, DWORD PTR __real@41000000
	mulss	xmm1, DWORD PTR __real@41000000

; 160  : 		this->x += rhs.x;

	addss	xmm4, xmm0
	movss	DWORD PTR $T98[rsp], xmm2

; 161  : 		this->y += rhs.y;

	movss	DWORD PTR $T98[rsp+4], xmm3
	addss	xmm5, xmm1
	movss	DWORD PTR $T98[rsp+8], xmm4
	movss	DWORD PTR $T98[rsp+12], xmm5
; File c:\home\programming\mathter\main.cpp

; 234  : 	cout << mat7 * mat8 << " & " << endl;

	call	??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@mathter@@@Z ; operator<<<float,2,2,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967230
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	lea	rax, QWORD PTR $T105[rsp]
	npad	2
$LL1152@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR mat8$[rbp+rdi*8-256]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR [rax+16]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	inc	rdi
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, xmm8
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rax-16], xmm0
	cmp	rdi, r15
	jl	SHORT $LL1152@main

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T105[rsp]
	lea	rcx, QWORD PTR mat8$[rbp-252]
	npad	9
$LL1158@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rax]

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm1, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 8
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm1, xmm1, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm9

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm0, xmm1
; File c:\home\programming\mathter\mathter\vector.hpp

; 460  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	r15, 1
	jne	SHORT $LL1158@main
; File c:\home\programming\mathter\main.cpp

; 235  : 	cout << mat8 * mat7 << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, QWORD PTR $T105[rsp]
	call	??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@mathter@@@Z ; operator<<<float,4,4,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 236  : 
; 237  : 
; 238  : 	double elapsed;
; 239  : 	elapsed = MatMulSpeedTest<float, 2, 2, 2, 2>();

	call	??$MatMulSpeedTest@M$01$01$01$01@@YANXZ	; MatMulSpeedTest<float,2,2,2,2>

; 240  : 	cout << "time 2x2 x 2x2:\t" << elapsed * 1000 << " ms" << endl;

	movsd	xmm7, QWORD PTR __real@408f400000000000
	lea	rdx, OFFSET FLAT:$SG4294967228
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967229
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 241  : 	elapsed = MatMulSpeedTest<float, 3, 3, 3, 3>();

	call	??$MatMulSpeedTest@M$02$02$02$02@@YANXZ	; MatMulSpeedTest<float,3,3,3,3>

; 242  : 	cout << "time 3x3 x 3x3:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967226
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967227
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 243  : 	elapsed = MatMulSpeedTest<float, 4, 4, 4, 4>();

	call	??$MatMulSpeedTest@M$03$03$03$03@@YANXZ	; MatMulSpeedTest<float,4,4,4,4>

; 244  : 	cout << "time 4x4 x 4x4:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967224
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967225
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 245  : 	//elapsed = MatMulSpeedTest<float, 8, 8, 8, 8>();
; 246  : 	//cout << "time 8x8 x 8x8:\t" << elapsed * 1000 << " ms" << endl;
; 247  : 	elapsed = MatMulSpeedTest<float, 4, 2, 2, 4>();

	call	??$MatMulSpeedTest@M$03$01$01$03@@YANXZ	; MatMulSpeedTest<float,4,2,2,4>

; 248  : 	cout << "time 4x2 x 2x4:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967222
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967223
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 249  : 	elapsed = MatMulSpeedTest<float, 2, 4, 4, 2>();

	call	??$MatMulSpeedTest@M$01$03$03$01@@YANXZ	; MatMulSpeedTest<float,2,4,4,2>

; 250  : 	cout << "time 2x4 x 4x2:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967220
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967221
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 251  : 	elapsed = MatMulSpeedTest<float, 4, 3, 3, 4>();

	call	??$MatMulSpeedTest@M$03$02$02$03@@YANXZ	; MatMulSpeedTest<float,4,3,3,4>

; 252  : 	cout << "time 4x3 x 3x4:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967218
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967219
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 253  : 	elapsed = MatMulSpeedTest<float, 3, 4, 4, 3>();

	call	??$MatMulSpeedTest@M$02$03$03$02@@YANXZ	; MatMulSpeedTest<float,3,4,4,3>

; 254  : 	cout << "time 3x4 x 4x3:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967216
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967217
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 255  : 	
; 256  : 
; 257  : 	return 0;

	xor	eax, eax

; 258  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+352]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0MMM$0A@@?$Vector@M$02@mathter@@QEAA@MMM@Z
_TEXT	SEGMENT
this$ = 8
h1$ = 16
h2$ = 24
<scalars_0>$ = 32
??$?0MMM$0A@@?$Vector@M$02@mathter@@QEAA@MMM@Z PROC	; mathter::Vector<float,3>::Vector<float,3><float,float,float,0>, COMDAT

; 838  : 		data[idx] = head;

	movss	DWORD PTR [rcx], xmm1

; 637  : 		static_assert(impl::SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 638  : 		Assign(0, h1, h2, scalars...);
; 639  : 	}

	mov	rax, rcx

; 838  : 		data[idx] = head;

	movss	DWORD PTR [rcx+4], xmm2
	movss	DWORD PTR [rcx+8], xmm3

; 637  : 		static_assert(impl::SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 638  : 		Assign(0, h1, h2, scalars...);
; 639  : 	}

	ret	0
??$?0MMM$0A@@?$Vector@M$02@mathter@@QEAA@MMM@Z ENDP	; mathter::Vector<float,3>::Vector<float,3><float,float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0MMMM$0A@@?$Vector@M$03@mathter@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
h1$ = 16
h2$ = 24
<scalars_0>$ = 32
<scalars_1>$ = 40
??$?0MMMM$0A@@?$Vector@M$03@mathter@@QEAA@MMMM@Z PROC	; mathter::Vector<float,4>::Vector<float,4><float,float,float,float,0>, COMDAT

; 838  : 		data[idx] = head;

	movss	xmm0, DWORD PTR <scalars_1>$[rsp]

; 637  : 		static_assert(impl::SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 638  : 		Assign(0, h1, h2, scalars...);
; 639  : 	}

	mov	rax, rcx

; 838  : 		data[idx] = head;

	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm2
	movss	DWORD PTR [rcx+8], xmm3
	movss	DWORD PTR [rcx+12], xmm0

; 637  : 		static_assert(impl::SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 638  : 		Assign(0, h1, h2, scalars...);
; 639  : 	}

	ret	0
??$?0MMMM$0A@@?$Vector@M$03@mathter@@QEAA@MMMM@Z ENDP	; mathter::Vector<float,4>::Vector<float,4><float,float,float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0V?$Vector@M$03@mathter@@V01@$0A@@?$Vector@M$07@mathter@@QEAA@AEBV?$Vector@M$03@1@0@Z
_TEXT	SEGMENT
this$ = 8
h1$dead$ = 16
<mixed_0>$ = 24
??$?0V?$Vector@M$03@mathter@@V01@$0A@@?$Vector@M$07@mathter@@QEAA@AEBV?$Vector@M$03@1@0@Z PROC ; mathter::Vector<float,8>::Vector<float,8><mathter::Vector<float,4>,mathter::Vector<float,4>,0>, COMDAT

; 846  : 			data[idx] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r8+12]
	mov	DWORD PTR [rcx+12], eax

; 855  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 644  : 		static_assert(impl::SumDimensions<Mixed...>::value <= D, "Arguments exceed vector dimension.");
; 645  : 		Assign(0, mixed...);
; 646  : 	}

	mov	rax, rcx
	ret	0
??$?0V?$Vector@M$03@mathter@@V01@$0A@@?$Vector@M$07@mathter@@QEAA@AEBV?$Vector@M$03@1@0@Z ENDP ; mathter::Vector<float,8>::Vector<float,8><mathter::Vector<float,4>,mathter::Vector<float,4>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Set@HHHHHHHH$0A@@?$Vector@M$07@mathter@@QEAAAEAV01@HHHHHHHH@Z
_TEXT	SEGMENT
this$ = 8
<scalars_0>$dead$ = 16
<scalars_1>$dead$ = 24
<scalars_2>$dead$ = 32
<scalars_3>$dead$ = 40
<scalars_4>$dead$ = 48
<scalars_5>$dead$ = 56
<scalars_6>$dead$ = 64
<scalars_7>$dead$ = 72
??$Set@HHHHHHHH$0A@@?$Vector@M$07@mathter@@QEAAAEAV01@HHHHHHHH@Z PROC ; mathter::Vector<float,8>::Set<int,int,int,int,int,int,int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx], 1065353216		; 3f800000H

; 651  : 		static_assert(impl::SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 652  : 		Assign(0, scalars...);
; 653  : 		return *this;

	mov	rax, rcx

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+12], 1082130432		; 40800000H
	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 654  : 	}

	ret	0
??$Set@HHHHHHHH$0A@@?$Vector@M$07@mathter@@QEAAAEAV01@HHHHHHHH@Z ENDP ; mathter::Vector<float,8>::Set<int,int,int,int,int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Set@V?$Vector@M$03@mathter@@V12@$0A@@?$Vector@M$07@mathter@@QEAAAEAV01@AEBV?$Vector@M$03@1@0@Z
_TEXT	SEGMENT
this$ = 8
<mixed_0>$ = 16
<mixed_1>$ = 24
??$Set@V?$Vector@M$03@mathter@@V12@$0A@@?$Vector@M$07@mathter@@QEAAAEAV01@AEBV?$Vector@M$03@1@0@Z PROC ; mathter::Vector<float,8>::Set<mathter::Vector<float,4>,mathter::Vector<float,4>,0>, COMDAT

; 846  : 			data[idx] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+12], eax
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx+16], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+20], eax
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+24], eax
	mov	eax, DWORD PTR [r8+12]
	mov	DWORD PTR [rcx+28], eax

; 659  : 		static_assert(impl::SumDimensions<Mixed...>::value <= D, "Arguments exceed vector dimension.");
; 660  : 		Assign(0, mixed...);
; 661  : 		return *this;

	mov	rax, rcx

; 662  : 	}

	ret	0
??$Set@V?$Vector@M$03@mathter@@V12@$0A@@?$Vector@M$07@mathter@@QEAAAEAV01@AEBV?$Vector@M$03@1@0@Z ENDP ; mathter::Vector<float,8>::Set<mathter::Vector<float,4>,mathter::Vector<float,4>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@QEAA@AEBV?$Vector@M$02@1@@Z
_TEXT	SEGMENT
this$ = 8
h1$dead$ = 16
??$?0V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@QEAA@AEBV?$Vector@M$02@1@@Z PROC ; mathter::Vector<float,4>::Vector<float,4><mathter::Vector<float,3>,0>, COMDAT

; 855  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 644  : 		static_assert(impl::SumDimensions<Mixed...>::value <= D, "Arguments exceed vector dimension.");
; 645  : 		Assign(0, mixed...);
; 646  : 	}

	mov	rax, rcx
	ret	0
??$?0V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@QEAA@AEBV?$Vector@M$02@1@@Z ENDP ; mathter::Vector<float,4>::Vector<float,4><mathter::Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Set@HHH$0A@@?$Vector@M$02@mathter@@QEAAAEAV01@HHH@Z
_TEXT	SEGMENT
this$ = 8
<scalars_0>$dead$ = 16
<scalars_1>$dead$ = 24
<scalars_2>$dead$ = 32
??$Set@HHH$0A@@?$Vector@M$02@mathter@@QEAAAEAV01@HHH@Z PROC ; mathter::Vector<float,3>::Set<int,int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx], 1065353216		; 3f800000H

; 651  : 		static_assert(impl::SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 652  : 		Assign(0, scalars...);
; 653  : 		return *this;

	mov	rax, rcx

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H

; 654  : 	}

	ret	0
??$Set@HHH$0A@@?$Vector@M$02@mathter@@QEAAAEAV01@HHH@Z ENDP ; mathter::Vector<float,3>::Set<int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Set@MV?$Vector@M$02@mathter@@$0A@@?$Vector@M$03@mathter@@QEAAAEAV01@AEBMAEBV?$Vector@M$02@1@@Z
_TEXT	SEGMENT
this$ = 8
<mixed_0>$ = 16
<mixed_1>$ = 24
??$Set@MV?$Vector@M$02@mathter@@$0A@@?$Vector@M$03@mathter@@QEAAAEAV01@AEBMAEBV?$Vector@M$02@1@@Z PROC ; mathter::Vector<float,4>::Set<float,mathter::Vector<float,3>,0>, COMDAT

; 846  : 			data[idx] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+12], eax

; 659  : 		static_assert(impl::SumDimensions<Mixed...>::value <= D, "Arguments exceed vector dimension.");
; 660  : 		Assign(0, mixed...);
; 661  : 		return *this;

	mov	rax, rcx

; 662  : 	}

	ret	0
??$Set@MV?$Vector@M$02@mathter@@$0A@@?$Vector@M$03@mathter@@QEAAAEAV01@AEBMAEBV?$Vector@M$02@1@@Z ENDP ; mathter::Vector<float,4>::Set<float,mathter::Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0HHHH$0A@@?$Vector@M$02@mathter@@QEAA@HHHH@Z
_TEXT	SEGMENT
this$ = 8
h1$dead$ = 16
h2$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
??$?0HHHH$0A@@?$Vector@M$02@mathter@@QEAA@HHHH@Z PROC	; mathter::Vector<float,3>::Vector<float,3><int,int,int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx], 1065353216		; 3f800000H

; 637  : 		static_assert(impl::SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 638  : 		Assign(0, h1, h2, scalars...);
; 639  : 	}

	mov	rax, rcx

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx+4], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+8], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+12], 1088421888		; 40e00000H

; 637  : 		static_assert(impl::SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 638  : 		Assign(0, h1, h2, scalars...);
; 639  : 	}

	ret	0
??$?0HHHH$0A@@?$Vector@M$02@mathter@@QEAA@HHHH@Z ENDP	; mathter::Vector<float,3>::Vector<float,3><int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?DMM$02$03$00M@mathter@@YA?AV?$Vector@M$03@0@AEBV?$Matrix@M$02$03$00@0@AEBV?$Vector@M$02@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
mat$ = 16
vec$ = 24
??$?DMM$02$03$00M@mathter@@YA?AV?$Vector@M$03@0@AEBV?$Matrix@M$02$03$00@0@AEBV?$Vector@M$02@0@@Z PROC ; mathter::operator*<float,float,3,4,1,float>, COMDAT
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movaps	xmm4, XMMWORD PTR [r8]
	xor	eax, eax
	npad	10
$LL4@operator:
	movaps	xmm3, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 338  : 	for (int i = 0; i < Mrow; ++i) {

	add	rdx, 16
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm3, xmm4

; 82   : 		sum = m.v[0] + m.v[1] + m.v[2] + m.v[3];

	movaps	xmm0, xmm3
	movaps	xmm2, xmm3
	shufps	xmm0, xmm3, 85				; 00000055H
	movaps	xmm1, xmm3
	addss	xmm2, xmm0
	shufps	xmm1, xmm3, 170				; 000000aaH
	shufps	xmm3, xmm3, 255				; 000000ffH
	addss	xmm2, xmm1
	addss	xmm2, xmm3
; File c:\home\programming\mathter\mathter\matrix.hpp

; 339  : 		result(i) = vec.Dot(vec, mat.stripes[i]);

	movss	DWORD PTR [rcx+rax*4], xmm2
	inc	rax
	cmp	rax, 4
	jl	SHORT $LL4@operator

; 340  : 	}
; 341  : 	return result;

	mov	rax, rcx

; 342  : }

	ret	0
??$?DMM$02$03$00M@mathter@@YA?AV?$Vector@M$03@0@AEBV?$Matrix@M$02$03$00@0@AEBV?$Vector@M$02@0@@Z ENDP ; mathter::operator*<float,float,3,4,1,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$03$00$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$00$00@mathter@@@Z
_TEXT	SEGMENT
os$ = 64
mat$ = 72
??$?6M$03$00$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$00$00@mathter@@@Z PROC ; operator<<<float,4,1,1>, COMDAT

; 14   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx

; 15   : 	for (int y = 0; y < mat.Height(); ++y) {
; 16   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967187
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 17   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	ebp, ebp
	lea	r15, OFFSET FLAT:$SG4294967186
	lea	r14d, QWORD PTR [rbp+4]
	npad	9
$LL7@operator:

; 18   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rsi]
	lea	rbx, OFFSET FLAT:$SG4294967185
	cmp	ebp, 3
	mov	rcx, rdi
	cmove	rbx, r15
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	ebp
	lea	rsi, QWORD PTR [rsi+4]
	sub	r14, 1
	jne	SHORT $LL7@operator

; 19   : 		}
; 20   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967184
	mov	rcx, rdi
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 21   : 	}
; 22   : 	return os;
; 23   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
??$?6M$03$00$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$00$00@mathter@@@Z ENDP ; operator<<<float,4,1,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@mathter@@@Z
_TEXT	SEGMENT
os$ = 64
mat$ = 72
??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@mathter@@@Z PROC ; operator<<<float,4,4,1>, COMDAT

; 14   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 15   : 	for (int y = 0; y < mat.Height(); ++y) {

	lea	r12, OFFSET FLAT:$SG4294967182
	mov	rbp, rcx
	mov	r15d, 4
$LL4@operator:

; 16   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967183
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 17   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	esi, esi
	lea	r14d, QWORD PTR [rsi+4]
	npad	10
$LL7@operator:

; 18   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rdi]
	lea	rbx, OFFSET FLAT:$SG4294967181
	cmp	esi, 3
	mov	rcx, rbp
	cmove	rbx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	add	rdi, 4
	sub	r14, 1
	jne	SHORT $LL7@operator

; 19   : 		}
; 20   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967180
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	sub	r15, 1
	jne	SHORT $LL4@operator

; 21   : 	}
; 22   : 	return os;
; 23   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@mathter@@@Z ENDP ; operator<<<float,4,4,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@mathter@@@Z
_TEXT	SEGMENT
os$ = 80
mat$ = 88
??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@mathter@@@Z PROC ; operator<<<float,3,3,1>, COMDAT

; 14   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r15, rdx

; 15   : 	for (int y = 0; y < mat.Height(); ++y) {

	lea	r13, OFFSET FLAT:$SG4294967178
	mov	rbp, rcx
	mov	r12d, 3
	npad	1
$LL4@operator:

; 16   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967179
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 17   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	edi, edi
	mov	rsi, r15
	lea	r14d, QWORD PTR [rdi+3]
	npad	8
$LL7@operator:

; 18   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rsi]
	lea	rbx, OFFSET FLAT:$SG4294967177
	cmp	edi, 2
	mov	rcx, rbp
	cmove	rbx, r13
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	edi
	lea	rsi, QWORD PTR [rsi+4]
	sub	r14, 1
	jne	SHORT $LL7@operator

; 19   : 		}
; 20   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967176
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	add	r15, 16
	sub	r12, 1
	jne	SHORT $LL4@operator

; 21   : 	}
; 22   : 	return os;
; 23   : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@mathter@@@Z ENDP ; operator<<<float,3,3,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@mathter@@@Z
_TEXT	SEGMENT
os$ = 64
mat$ = 72
??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@mathter@@@Z PROC ; operator<<<float,4,2,1>, COMDAT

; 14   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 15   : 	for (int y = 0; y < mat.Height(); ++y) {

	lea	r12, OFFSET FLAT:$SG4294967174
	mov	rbp, rcx
	mov	r15d, 2
$LL4@operator:

; 16   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967175
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 17   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	esi, esi
	lea	r14d, QWORD PTR [rsi+4]
	npad	10
$LL7@operator:

; 18   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rdi]
	lea	rbx, OFFSET FLAT:$SG4294967173
	cmp	esi, 3
	mov	rcx, rbp
	cmove	rbx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	add	rdi, 4
	sub	r14, 1
	jne	SHORT $LL7@operator

; 19   : 		}
; 20   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967172
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	sub	r15, 1
	jne	SHORT $LL4@operator

; 21   : 	}
; 22   : 	return os;
; 23   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@mathter@@@Z ENDP ; operator<<<float,4,2,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@mathter@@@Z
_TEXT	SEGMENT
os$ = 64
mat$ = 72
??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@mathter@@@Z PROC ; operator<<<float,2,4,1>, COMDAT

; 14   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 15   : 	for (int y = 0; y < mat.Height(); ++y) {

	lea	r12, OFFSET FLAT:$SG4294967170
	mov	rbp, rcx
	mov	r15d, 4
$LL4@operator:

; 16   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967171
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 17   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	esi, esi
	lea	r14d, QWORD PTR [rsi+2]
	npad	10
$LL7@operator:

; 18   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rdi]
	lea	rbx, OFFSET FLAT:$SG4294967169
	cmp	esi, 1
	mov	rcx, rbp
	cmove	rbx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	add	rdi, 4
	sub	r14, 1
	jne	SHORT $LL7@operator

; 19   : 		}
; 20   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967168
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	sub	r15, 1
	jne	SHORT $LL4@operator

; 21   : 	}
; 22   : 	return os;
; 23   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@mathter@@@Z ENDP ; operator<<<float,2,4,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@mathter@@@Z
_TEXT	SEGMENT
os$ = 64
mat$ = 72
??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@mathter@@@Z PROC ; operator<<<float,2,2,1>, COMDAT

; 14   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 15   : 	for (int y = 0; y < mat.Height(); ++y) {

	lea	r12, OFFSET FLAT:$SG4294967166
	mov	rbp, rcx
	mov	r15d, 2
$LL4@operator:

; 16   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967167
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 17   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	esi, esi
	lea	r14d, QWORD PTR [rsi+2]
	npad	10
$LL7@operator:

; 18   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rdi]
	lea	rbx, OFFSET FLAT:$SG4294967165
	cmp	esi, 1
	mov	rcx, rbp
	cmove	rbx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	add	rdi, 4
	sub	r14, 1
	jne	SHORT $LL7@operator

; 19   : 		}
; 20   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967164
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	sub	r15, 1
	jne	SHORT $LL4@operator

; 21   : 	}
; 22   : 	return os;
; 23   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@mathter@@@Z ENDP ; operator<<<float,2,2,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
_TEXT	SEGMENT
scalarMultiplier$146 = 32
$T147 = 40
result$ = 48
right$ = 72
left$ = 96
$T22 = 120
__$ArrayPad$ = 144
??$MatMulSpeedTest@M$01$01$01$01@@YANXZ PROC		; MatMulSpeedTest<float,2,2,2,2>, COMDAT

; 90   : double MatMulSpeedTest() {

$LN591:
	mov	rax, rsp
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 176				; 000000b0H
	mov	QWORD PTR $T147[rbp-105], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	movaps	XMMWORD PTR [rax-40], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rbp-105]
	call	??0?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >
	npad	1

; 97   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rbp-105]
	call	??0?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >
	npad	1

; 98   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rbp-105]
	call	??0?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	rsi, QWORD PTR right$[rbp-105]
	mov	rcx, rsi

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	r14, QWORD PTR left$[rbp-105]
	mov	rdi, r14
	sub	rdi, rsi

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r8d, 100000				; 000186a0H
	npad	3
$LL4@MatMulSpee:

; 104  : 		LeftT& l = left[i];

	lea	rdx, QWORD PTR [rdi+rcx]

; 105  : 		RightT& r = right[i];
; 106  : 
; 107  : 		for (int x = 0; x < Col1; ++x) {

	xor	eax, eax
	npad	10
$LL7@MatMulSpee:

; 108  : 			for (int y = 0; y < Row1; ++y) {
; 109  : 				l(x, y) = 2;

	mov	DWORD PTR [rdx+rax*8], 1073741824	; 40000000H
	mov	DWORD PTR [rdx+rax*8+4], 1073741824	; 40000000H

; 105  : 		RightT& r = right[i];
; 106  : 
; 107  : 		for (int x = 0; x < Col1; ++x) {

	inc	rax
	cmp	rax, 2
	jl	SHORT $LL7@MatMulSpee

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	xor	eax, eax
	npad	6
$LL13@MatMulSpee:

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	DWORD PTR [rcx+rax*8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax*8+4], 1073741824	; 40000000H

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	inc	rax
	cmp	rax, 2
	jl	SHORT $LL13@MatMulSpee

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	add	rcx, 16
	sub	r8, 1
	jne	SHORT $LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	mov	r15, QWORD PTR result$[rbp-105]
	mov	r10, r15
	sub	r10, rsi

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	r9d, 100				; 00000064H
	npad	3
$LL19@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 124  : 		for (int i = 0; i < iterationCount; ++i) {

	lea	rdx, QWORD PTR [rsi+8]
	mov	r8d, 100000				; 000186a0H
	npad	6
$LL22@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 227  : 		scalarMultiplier = rhs.stripes[0];

	mov	rax, QWORD PTR [rdx-8]
	mov	QWORD PTR scalarMultiplier$146[rbp-105], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 170  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$146[rbp-105]
	mulss	xmm0, DWORD PTR [rdi+rdx-8]
	movss	DWORD PTR scalarMultiplier$146[rbp-105], xmm0

; 171  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$146[rbp-101]
	mulss	xmm1, DWORD PTR [rdi+rdx-8]
	movss	DWORD PTR scalarMultiplier$146[rbp-101], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	rcx, QWORD PTR scalarMultiplier$146[rbp-105]
	mov	QWORD PTR $T22[rbp-105], rcx

; 227  : 		scalarMultiplier = rhs.stripes[0];

	mov	QWORD PTR scalarMultiplier$146[rbp-105], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 170  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$146[rbp-105]
	mulss	xmm0, DWORD PTR [rdx+rdi]
	movss	DWORD PTR scalarMultiplier$146[rbp-105], xmm0

; 171  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$146[rbp-101]
	mulss	xmm1, DWORD PTR [rdx+rdi]
	movss	DWORD PTR scalarMultiplier$146[rbp-101], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	rax, QWORD PTR scalarMultiplier$146[rbp-105]
	mov	QWORD PTR $T22[rbp-97], rax

; 233  : 			scalarMultiplier = rhs.stripes[x];

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR scalarMultiplier$146[rbp-105], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 170  : 		this->x *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$146[rbp-105]
	mulss	xmm2, DWORD PTR [rdi+rdx-4]

; 171  : 		this->y *= rhs;

	movss	xmm3, DWORD PTR scalarMultiplier$146[rbp-101]
	mulss	xmm3, DWORD PTR [rdi+rdx-4]

; 160  : 		this->x += rhs.x;

	movss	xmm1, DWORD PTR $T22[rbp-105]
	addss	xmm1, xmm2
	movss	DWORD PTR $T22[rbp-105], xmm1

; 161  : 		this->y += rhs.y;

	movss	xmm0, DWORD PTR $T22[rbp-101]
	addss	xmm0, xmm3
	movss	DWORD PTR $T22[rbp-101], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 233  : 			scalarMultiplier = rhs.stripes[x];

	mov	QWORD PTR scalarMultiplier$146[rbp-105], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 170  : 		this->x *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$146[rbp-105]
	mulss	xmm2, DWORD PTR [rdi+rdx+4]

; 171  : 		this->y *= rhs;

	movss	xmm3, DWORD PTR scalarMultiplier$146[rbp-101]
	mulss	xmm3, DWORD PTR [rdi+rdx+4]

; 160  : 		this->x += rhs.x;

	movss	xmm0, DWORD PTR $T22[rbp-97]
	addss	xmm0, xmm2
	movss	DWORD PTR $T22[rbp-97], xmm0

; 161  : 		this->y += rhs.y;

	movss	xmm1, DWORD PTR $T22[rbp-93]
	addss	xmm1, xmm3
	movss	DWORD PTR $T22[rbp-93], xmm1
; File c:\home\programming\mathter\main.cpp

; 125  : 			result[i] = left[i] * right[i];

	movups	xmm0, XMMWORD PTR $T22[rbp-105]
	movups	XMMWORD PTR [r10+rdx-8], xmm0

; 124  : 		for (int i = 0; i < iterationCount; ++i) {

	add	rdx, 16
	sub	r8, 1
	jne	$LL22@MatMulSpee

; 115  : 			}
; 116  : 		}
; 117  : 	}
; 118  : 
; 119  : 	std::chrono::high_resolution_clock::time_point startTime;
; 120  : 	std::chrono::high_resolution_clock::time_point endTime;
; 121  : 
; 122  : 	startTime = std::chrono::high_resolution_clock::now();
; 123  : 	for (int j = 0; j < 100; ++j) {

	sub	r9, 1
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, rbx
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 1152921504606846975		; 0fffffffffffffffH
	test	r15, r15
	je	SHORT $LN218@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR result$[rbp-89]
	sub	rax, r15
	sar	rax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN285@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN285@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN286@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r15b, 31
	je	SHORT $LN287@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN287@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r15-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r15
	jb	SHORT $LN288@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN288@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r15, rax
	cmp	r15, 8
	jae	SHORT $LN289@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN289@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r15, 39					; 00000027H
	jbe	SHORT $LN290@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN290@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r15, rax
$LN286@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r15
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN218@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rsi, rsi
	je	SHORT $LN328@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR right$[rbp-89]
	sub	rax, rsi
	sar	rax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN395@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN395@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN396@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	sil, 31
	je	SHORT $LN397@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN397@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rsi-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rsi
	jb	SHORT $LN398@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN398@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rsi, rax
	cmp	rsi, 8
	jae	SHORT $LN399@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN399@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rsi, 39					; 00000027H
	jbe	SHORT $LN400@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN400@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rsi, rax
$LN396@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rsi
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN328@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r14, r14
	je	SHORT $LN437@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR left$[rbp-89]
	sub	rax, r14
	sar	rax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN504@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN504@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN505@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r14b, 31
	je	SHORT $LN506@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN506@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r14-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r14
	jb	SHORT $LN507@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN507@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r14, rax
	cmp	r14, 8
	jae	SHORT $LN508@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN508@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r14, 39					; 00000027H
	jbe	SHORT $LN509@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN509@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r14, rax
$LN505@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r14
	call	??3@YAXPEAX@Z				; operator delete
$LN437@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 131  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rdi, QWORD PTR [r11+48]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN590@MatMulSpee:
??$MatMulSpeedTest@M$01$01$01$01@@YANXZ ENDP		; MatMulSpeedTest<float,2,2,2,2>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
scalarMultiplier$146 = 32
$T147 = 40
result$ = 48
right$ = 72
left$ = 96
$T22 = 120
__$ArrayPad$ = 144
?dtor$0@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::~vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$0
scalarMultiplier$146 = 32
$T147 = 40
result$ = 48
right$ = 72
left$ = 96
$T22 = 120
__$ArrayPad$ = 144
?dtor$1@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::~vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
scalarMultiplier$146 = 32
$T147 = 40
result$ = 48
right$ = 72
left$ = 96
$T22 = 120
__$ArrayPad$ = 144
?dtor$0@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::~vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
scalarMultiplier$146 = 32
$T147 = 40
result$ = 48
right$ = 72
left$ = 96
$T22 = 120
__$ArrayPad$ = 144
?dtor$1@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::~vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
_TEXT	SEGMENT
tv1922 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 176
??$MatMulSpeedTest@M$02$02$02$02@@YANXZ PROC		; MatMulSpeedTest<float,3,3,3,3>, COMDAT

; 90   : double MatMulSpeedTest() {

$LN595:
	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 208				; 000000d0H
	mov	QWORD PTR $T157[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >
	npad	1

; 97   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >
	npad	1

; 98   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r14, QWORD PTR left$[rsp]
	mov	r9, r14

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	rsi, r14
	mov	r13, QWORD PTR right$[rsp]
	sub	rsi, r13
	mov	rbx, r13
	sub	rbx, r14
	mov	rdi, r14
	neg	rdi

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r11d, 100000				; 000186a0H
	npad	13
$LL4@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rcx, QWORD PTR [rbx+8]
	add	rcx, r9
	lea	rax, QWORD PTR [rcx+rsi]
; File c:\home\programming\mathter\main.cpp

; 109  : 				l(x, y) = 2;

	lea	r10, QWORD PTR [rdi+r9]
	mov	rdx, r9
	sub	rdx, r10
	sub	rdx, r14
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	r8d, 3
	npad	2
$LL7@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 109  : 				l(x, y) = 2;

	mov	DWORD PTR [rdx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rdx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H

; 104  : 		LeftT& l = left[i];
; 105  : 		RightT& r = right[i];
; 106  : 
; 107  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	r8, 1
	jne	SHORT $LL7@MatMulSpee

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	rax, rbx
	sub	rax, r10
	sub	rax, r13
	lea	rdx, QWORD PTR [rax+r9]
	lea	r8, QWORD PTR [rax+r9]

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	mov	eax, 3
$LL13@MatMulSpee:

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	DWORD PTR [r8+rcx-8], 1073741824	; 40000000H
	mov	DWORD PTR [rdx+rcx-4], 1073741824	; 40000000H
	mov	DWORD PTR [rcx], 1073741824		; 40000000H

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	lea	rcx, QWORD PTR [rcx+16]
	sub	rax, 1
	jne	SHORT $LL13@MatMulSpee

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	add	r9, 48					; 00000030H
	sub	r11, 1
	jne	$LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	lea	r14, QWORD PTR [r13+16]
	lea	r15, QWORD PTR [rsi-12]
	lea	rax, QWORD PTR $T26[rsp]
	sub	rsi, rax
	mov	r12, QWORD PTR result$[rsp]
	mov	rdi, r12
	sub	rdi, r13

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	QWORD PTR tv1922[rsp], 100		; 00000064H
	npad	9
$LL19@MatMulSpee:
	mov	r10, r14
	mov	ebp, 100000				; 000186a0H
	npad	8
$LL22@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rcx, QWORD PTR $T26[rsp]
	mov	edx, 3
	npad	3
$LL130@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 227  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm1, XMMWORD PTR [r10-16]
; File c:\home\programming\mathter\mathter\vector.hpp

; 675  : 		return data[idx];

	lea	rax, QWORD PTR [rsi+r10]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rax+rcx-16]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rcx], xmm1

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rcx, QWORD PTR [rcx+16]
	sub	rdx, 1
	jne	SHORT $LL130@MatMulSpee

; 230  : 	}
; 231  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR [r15+r10]
	mov	r8, r10
	lea	r11d, QWORD PTR [rdx+2]
	npad	2
$LL133@MatMulSpee:

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T26[rsp]
	mov	rcx, r9
	mov	edx, 3
$LL136@MatMulSpee:

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 400  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16
	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL136@MatMulSpee

; 230  : 	}
; 231  : 	for (int x = 1; x < Match; ++x) {

	add	r8, 16
	add	r9, 4
	sub	r11, 1
	jne	SHORT $LL133@MatMulSpee
; File c:\home\programming\mathter\main.cpp

; 125  : 			result[i] = left[i] * right[i];

	movaps	xmm0, XMMWORD PTR $T26[rsp]
	movaps	XMMWORD PTR [rdi+r10-16], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+16]
	movaps	XMMWORD PTR [rdi+r10], xmm1
	movaps	xmm0, XMMWORD PTR $T26[rsp+32]
	movaps	XMMWORD PTR [rdi+r10+16], xmm0

; 124  : 		for (int i = 0; i < iterationCount; ++i) {

	add	r10, 48					; 00000030H
	sub	rbp, 1
	jne	$LL22@MatMulSpee

; 115  : 			}
; 116  : 		}
; 117  : 	}
; 118  : 
; 119  : 	std::chrono::high_resolution_clock::time_point startTime;
; 120  : 	std::chrono::high_resolution_clock::time_point endTime;
; 121  : 
; 122  : 	startTime = std::chrono::high_resolution_clock::now();
; 123  : 	for (int j = 0; j < 100; ++j) {

	sub	QWORD PTR tv1922[rsp], 1
	lea	r14, QWORD PTR [r13+16]
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, rbx
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rdi, 384307168202282325			; 0555555555555555H
	test	r12, r12
	mov	r14, QWORD PTR left$[rsp]
	je	SHORT $LN224@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR result$[rsp+16]
	sub	rcx, r12
	mov	rax, rbx
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rdx, rdi
	jbe	SHORT $LN291@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN291@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN292@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r12b, 31
	je	SHORT $LN293@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r12-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r12
	jb	SHORT $LN294@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN294@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r12, rax
	cmp	r12, 8
	jae	SHORT $LN295@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r12, 39					; 00000027H
	jbe	SHORT $LN296@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN296@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r12, rax
$LN292@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r12
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN224@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r13, r13
	je	SHORT $LN334@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR right$[rsp+16]
	sub	rcx, r13
	mov	rax, rbx
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rdx, rdi
	jbe	SHORT $LN401@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN401@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN402@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r13b, 31
	je	SHORT $LN403@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN403@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r13-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r13
	jb	SHORT $LN404@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r13, rax
	cmp	r13, 8
	jae	SHORT $LN405@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN405@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r13, 39					; 00000027H
	jbe	SHORT $LN406@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN406@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r13, rax
$LN402@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r13
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN334@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r14, r14
	je	SHORT $LN443@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR left$[rsp+16]
	sub	rcx, r14
	mov	rax, rbx
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rdx, rdi
	jbe	SHORT $LN510@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN510@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN511@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r14b, 31
	je	SHORT $LN512@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN512@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r14-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r14
	jb	SHORT $LN513@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN513@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r14, rax
	cmp	r14, 8
	jae	SHORT $LN514@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN514@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r14, 39					; 00000027H
	jbe	SHORT $LN515@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN515@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r14, rax
$LN511@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r14
	call	??3@YAXPEAX@Z				; operator delete
$LN443@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 131  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN594@MatMulSpee:
??$MatMulSpeedTest@M$02$02$02$02@@YANXZ ENDP		; MatMulSpeedTest<float,3,3,3,3>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv1922 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 176
?dtor$0@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::~vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$0
tv1922 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 176
?dtor$1@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::~vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1922 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 176
?dtor$0@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::~vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1922 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 176
?dtor$1@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::~vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
_TEXT	SEGMENT
tv2195 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 192
??$MatMulSpeedTest@M$03$03$03$03@@YANXZ PROC		; MatMulSpeedTest<float,4,4,4,4>, COMDAT

; 90   : double MatMulSpeedTest() {

$LN601:
	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H
	mov	QWORD PTR $T157[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >
	npad	1

; 97   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >
	npad	1

; 98   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r14, QWORD PTR left$[rsp]
	mov	r9, r14

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	rsi, r14
	mov	r13, QWORD PTR right$[rsp]
	sub	rsi, r13
	mov	rbx, r13
	sub	rbx, r14
	mov	rdi, r14
	neg	rdi

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r11d, 100000				; 000186a0H
	npad	13
$LL4@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rcx, QWORD PTR [rbx+8]
	add	rcx, r9
	lea	rax, QWORD PTR [rcx+rsi]
; File c:\home\programming\mathter\main.cpp

; 109  : 				l(x, y) = 2;

	lea	r10, QWORD PTR [rdi+r9]
	mov	rdx, r9
	sub	rdx, r10
	sub	rdx, r14
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	r8d, 4
	npad	2
$LL7@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 109  : 				l(x, y) = 2;

	mov	DWORD PTR [rdx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rdx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H
	mov	DWORD PTR [rax+4], 1073741824		; 40000000H

; 104  : 		LeftT& l = left[i];
; 105  : 		RightT& r = right[i];
; 106  : 
; 107  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	r8, 1
	jne	SHORT $LL7@MatMulSpee

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	rax, rbx
	sub	rax, r10
	sub	rax, r13
	lea	rdx, QWORD PTR [rax+r9]
	lea	r8, QWORD PTR [rax+r9]

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	mov	eax, 4
	npad	3
$LL13@MatMulSpee:

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	DWORD PTR [r8+rcx-8], 1073741824	; 40000000H
	mov	DWORD PTR [rdx+rcx-4], 1073741824	; 40000000H
	mov	DWORD PTR [rcx], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	lea	rcx, QWORD PTR [rcx+16]
	sub	rax, 1
	jne	SHORT $LL13@MatMulSpee

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	add	r9, 64					; 00000040H
	sub	r11, 1
	jne	$LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	lea	r14, QWORD PTR [r13+16]
	lea	r15, QWORD PTR [rsi-12]
	lea	rax, QWORD PTR $T26[rsp]
	sub	rsi, rax
	mov	r12, QWORD PTR result$[rsp]
	mov	rdi, r12
	sub	rdi, r13

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	QWORD PTR tv2195[rsp], 100		; 00000064H
	npad	8
$LL19@MatMulSpee:
	mov	r10, r14
	mov	ebp, 100000				; 000186a0H
	npad	8
$LL22@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rcx, QWORD PTR $T26[rsp]
	mov	edx, 4
	npad	3
$LL130@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 227  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm1, XMMWORD PTR [r10-16]
; File c:\home\programming\mathter\mathter\vector.hpp

; 675  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rsi]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rax+r10-16]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rcx], xmm1

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rcx, QWORD PTR [rcx+16]
	sub	rdx, 1
	jne	SHORT $LL130@MatMulSpee

; 230  : 	}
; 231  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR [r15+r10]
	mov	r8, r10
	lea	r11d, QWORD PTR [rdx+3]
	npad	1
$LL133@MatMulSpee:

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T26[rsp]
	mov	rcx, r9
	mov	edx, 4
$LL136@MatMulSpee:

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 460  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16
	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL136@MatMulSpee

; 230  : 	}
; 231  : 	for (int x = 1; x < Match; ++x) {

	add	r8, 16
	add	r9, 4
	sub	r11, 1
	jne	SHORT $LL133@MatMulSpee
; File c:\home\programming\mathter\main.cpp

; 125  : 			result[i] = left[i] * right[i];

	movaps	xmm0, XMMWORD PTR $T26[rsp]
	movaps	XMMWORD PTR [rdi+r10-16], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+16]
	movaps	XMMWORD PTR [rdi+r10], xmm1
	movaps	xmm0, XMMWORD PTR $T26[rsp+32]
	movaps	XMMWORD PTR [rdi+r10+16], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+48]
	movaps	XMMWORD PTR [rdi+r10+32], xmm1

; 124  : 		for (int i = 0; i < iterationCount; ++i) {

	add	r10, 64					; 00000040H
	sub	rbp, 1
	jne	$LL22@MatMulSpee

; 115  : 			}
; 116  : 		}
; 117  : 	}
; 118  : 
; 119  : 	std::chrono::high_resolution_clock::time_point startTime;
; 120  : 	std::chrono::high_resolution_clock::time_point endTime;
; 121  : 
; 122  : 	startTime = std::chrono::high_resolution_clock::now();
; 123  : 	for (int j = 0; j < 100; ++j) {

	sub	QWORD PTR tv2195[rsp], 1
	lea	r14, QWORD PTR [r13+16]
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, rbx
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 288230376151711743			; 03ffffffffffffffH
	test	r12, r12
	mov	r14, QWORD PTR left$[rsp]
	je	SHORT $LN224@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR result$[rsp+16]
	sub	rax, r12
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN291@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN291@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN292@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r12b, 31
	je	SHORT $LN293@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r12-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r12
	jb	SHORT $LN294@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN294@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r12, rax
	cmp	r12, 8
	jae	SHORT $LN295@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r12, 39					; 00000027H
	jbe	SHORT $LN296@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN296@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r12, rax
$LN292@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r12
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN224@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r13, r13
	je	SHORT $LN334@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR right$[rsp+16]
	sub	rax, r13
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN401@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN401@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN402@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r13b, 31
	je	SHORT $LN403@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN403@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r13-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r13
	jb	SHORT $LN404@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r13, rax
	cmp	r13, 8
	jae	SHORT $LN405@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN405@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r13, 39					; 00000027H
	jbe	SHORT $LN406@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN406@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r13, rax
$LN402@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r13
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN334@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r14, r14
	je	SHORT $LN443@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR left$[rsp+16]
	sub	rax, r14
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN510@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN510@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN511@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r14b, 31
	je	SHORT $LN512@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN512@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r14-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r14
	jb	SHORT $LN513@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN513@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r14, rax
	cmp	r14, 8
	jae	SHORT $LN514@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN514@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r14, 39					; 00000027H
	jbe	SHORT $LN515@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN515@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r14, rax
$LN511@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r14
	call	??3@YAXPEAX@Z				; operator delete
$LN443@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 131  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN600@MatMulSpee:
??$MatMulSpeedTest@M$03$03$03$03@@YANXZ ENDP		; MatMulSpeedTest<float,4,4,4,4>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv2195 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 192
?dtor$0@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::~vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$0
tv2195 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 192
?dtor$1@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::~vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2195 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 192
?dtor$0@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::~vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2195 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 192
?dtor$1@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::~vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
_TEXT	SEGMENT
$T145 = 32
result$ = 40
right$ = 64
left$ = 88
$T25 = 112
__$ArrayPad$ = 128
??$MatMulSpeedTest@M$03$01$01$03@@YANXZ PROC		; MatMulSpeedTest<float,4,2,2,4>, COMDAT

; 90   : double MatMulSpeedTest() {

$LN550:
	mov	rax, rsp
	push	r14
	sub	rsp, 160				; 000000a0H
	mov	QWORD PTR $T145[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >
	npad	1

; 97   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >
	npad	1

; 98   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$01$01$00@mathter@@V?$allocator@V?$Matrix@M$01$01$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >::vector<mathter::Matrix<float,2,2,1>,std::allocator<mathter::Matrix<float,2,2,1> > >

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	rsi, QWORD PTR left$[rsp]
	lea	rdx, QWORD PTR [rsi+8]

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	r14, QWORD PTR right$[rsp]
	mov	rdi, r14
	sub	rdi, rsi

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r10, -8
	sub	r10, rsi
	mov	r9d, 100000				; 000186a0H
	npad	1
$LL4@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	rax, rdx
; File c:\home\programming\mathter\main.cpp

; 109  : 				l(x, y) = 2;

	mov	rcx, -8
	sub	rcx, r10
	sub	rcx, rsi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	r8d, 2
	npad	10
$LL7@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 109  : 				l(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H
	mov	DWORD PTR [rax+4], 1073741824		; 40000000H

; 104  : 		LeftT& l = left[i];
; 105  : 		RightT& r = right[i];
; 106  : 
; 107  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	r8, 1
	jne	SHORT $LL7@MatMulSpee

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	xor	ecx, ecx
	npad	7
$LL13@MatMulSpee:
	lea	rax, QWORD PTR [rdi+rcx*8]

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	DWORD PTR [rax+rdx-8], 1073741824	; 40000000H

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [rdi+rcx*8]

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	DWORD PTR [rax+rdx-4], 1073741824	; 40000000H

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	inc	rcx
	cmp	rcx, 4
	jl	SHORT $LL13@MatMulSpee

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	add	rdx, 32					; 00000020H
	sub	r9, 1
	jne	SHORT $LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	r11d, 100				; 00000064H
	mov	rbp, QWORD PTR result$[rsp]
	npad	15
$LL19@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 124  : 		for (int i = 0; i < iterationCount; ++i) {

	mov	r9, rbp
	mov	rdx, rsi
	mov	r10d, 100000				; 000186a0H
	npad	4
$LL22@MatMulSpee:

; 125  : 			result[i] = left[i] * right[i];

	lea	r8, QWORD PTR [rdx+rdi]
	lea	rcx, QWORD PTR $T25[rsp]
	call	??$?DMM$03$01$01$00$00MX@mathter@@YA?AV?$Matrix@M$01$01$00@0@AEBV?$Matrix@M$03$01$00@0@AEBV?$Matrix@M$01$03$00@0@@Z ; mathter::operator*<float,float,4,2,2,1,1,float,void>
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [r9], xmm0

; 124  : 		for (int i = 0; i < iterationCount; ++i) {

	add	rdx, 32					; 00000020H
	lea	r9, QWORD PTR [r9+16]
	sub	r10, 1
	jne	SHORT $LL22@MatMulSpee

; 115  : 			}
; 116  : 		}
; 117  : 	}
; 118  : 
; 119  : 	std::chrono::high_resolution_clock::time_point startTime;
; 120  : 	std::chrono::high_resolution_clock::time_point endTime;
; 121  : 
; 122  : 	startTime = std::chrono::high_resolution_clock::now();
; 123  : 	for (int j = 0; j < 100; ++j) {

	sub	r11, 1
	jne	SHORT $LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, rbx
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rbp, rbp
	je	SHORT $LN189@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR result$[rsp+16]
	sub	rax, rbp
	sar	rax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rcx, 1152921504606846975		; 0fffffffffffffffH
	cmp	rax, rcx
	jbe	SHORT $LN256@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN256@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN257@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	bpl, 31
	je	SHORT $LN258@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN258@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rbp-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rbp
	jb	SHORT $LN259@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN259@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rbp, rax
	cmp	rbp, 8
	jae	SHORT $LN260@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN260@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rbp, 39					; 00000027H
	jbe	SHORT $LN261@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN261@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rbp, rax
$LN257@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rbp
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN189@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 576460752303423487			; 07ffffffffffffffH
	test	r14, r14
	je	SHORT $LN299@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR right$[rsp+16]
	sub	rax, r14
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN366@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN366@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN367@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r14b, 31
	je	SHORT $LN368@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN368@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r14-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r14
	jb	SHORT $LN369@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN369@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r14, rax
	cmp	r14, 8
	jae	SHORT $LN370@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN370@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r14, 39					; 00000027H
	jbe	SHORT $LN371@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN371@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r14, rax
$LN367@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r14
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN299@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rsi, rsi
	je	SHORT $LN408@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR left$[rsp+16]
	sub	rax, rsi
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN475@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN475@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN476@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	sil, 31
	je	SHORT $LN477@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN477@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rsi-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rsi
	jb	SHORT $LN478@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN478@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rsi, rax
	cmp	rsi, 8
	jae	SHORT $LN479@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN479@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rsi, 39					; 00000027H
	jbe	SHORT $LN480@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN480@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rsi, rax
$LN476@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rsi
	call	??3@YAXPEAX@Z				; operator delete
$LN408@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 131  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r14
	ret	0
$LN549@MatMulSpee:
??$MatMulSpeedTest@M$03$01$01$03@@YANXZ ENDP		; MatMulSpeedTest<float,4,2,2,4>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T145 = 32
result$ = 40
right$ = 64
left$ = 88
$T25 = 112
__$ArrayPad$ = 128
?dtor$0@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::~vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$0
$T145 = 32
result$ = 40
right$ = 64
left$ = 88
$T25 = 112
__$ArrayPad$ = 128
?dtor$1@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::~vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T145 = 32
result$ = 40
right$ = 64
left$ = 88
$T25 = 112
__$ArrayPad$ = 128
?dtor$0@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::~vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T145 = 32
result$ = 40
right$ = 64
left$ = 88
$T25 = 112
__$ArrayPad$ = 128
?dtor$1@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::~vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
_TEXT	SEGMENT
$T157 = 32
result$ = 40
right$ = 64
left$ = 88
$T26 = 112
__$ArrayPad$ = 176
??$MatMulSpeedTest@M$01$03$03$01@@YANXZ PROC		; MatMulSpeedTest<float,2,4,4,2>, COMDAT

; 90   : double MatMulSpeedTest() {

$LN597:
	mov	rax, rsp
	push	r14
	sub	rsp, 208				; 000000d0H
	mov	QWORD PTR $T157[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >
	npad	1

; 97   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >
	npad	1

; 98   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r14, QWORD PTR right$[rsp]
	lea	rdx, QWORD PTR [r14+8]

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	rbp, QWORD PTR left$[rsp]
	mov	r9, rbp
	sub	r9, r14

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r11, -8
	sub	r11, r14
	mov	r10d, 100000				; 000186a0H
	npad	1
$LL4@MatMulSpee:

; 104  : 		LeftT& l = left[i];
; 105  : 		RightT& r = right[i];
; 106  : 
; 107  : 		for (int x = 0; x < Col1; ++x) {

	xor	ecx, ecx
	npad	14
$LL7@MatMulSpee:
	lea	rax, QWORD PTR [r9+rdx]

; 108  : 			for (int y = 0; y < Row1; ++y) {
; 109  : 				l(x, y) = 2;

	mov	DWORD PTR [rax+rcx*8-8], 1073741824	; 40000000H

; 104  : 		LeftT& l = left[i];
; 105  : 		RightT& r = right[i];
; 106  : 
; 107  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [r9+rdx]

; 108  : 			for (int y = 0; y < Row1; ++y) {
; 109  : 				l(x, y) = 2;

	mov	DWORD PTR [rax+rcx*8-4], 1073741824	; 40000000H

; 104  : 		LeftT& l = left[i];
; 105  : 		RightT& r = right[i];
; 106  : 
; 107  : 		for (int x = 0; x < Col1; ++x) {

	inc	rcx
	cmp	rcx, 4
	jl	SHORT $LL7@MatMulSpee

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	mov	rax, rdx

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	rcx, -8
	sub	rcx, r11
	sub	rcx, r14

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	mov	r8d, 2
	npad	9
$LL13@MatMulSpee:

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H
	mov	DWORD PTR [rax+4], 1073741824		; 40000000H

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	r8, 1
	jne	SHORT $LL13@MatMulSpee

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	add	rdx, 32					; 00000020H
	sub	r10, 1
	jne	$LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	mov	r10, r14
	sub	r10, rbp

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	edi, 100				; 00000064H
	mov	rsi, QWORD PTR result$[rsp]
$LL19@MatMulSpee:
	mov	r8, rsi
	mov	rcx, rbp
	mov	r11d, 100000				; 000186a0H
	npad	4
$LL22@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rdx, QWORD PTR $T26[rsp]
	npad	9
$LL130@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 227  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm1, XMMWORD PTR [r10+rcx]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx+rax*8]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rdx], xmm1

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	inc	rax
	lea	rdx, QWORD PTR [rdx+16]
	cmp	rax, 4
	jl	SHORT $LL130@MatMulSpee

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T26[rsp]
	lea	rdx, QWORD PTR [rcx+4]
	mov	r9d, 4
$LL136@MatMulSpee:

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r10+rcx+16]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rdx]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 460  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rdx, 8
	add	rax, 16
	sub	r9, 1
	jne	SHORT $LL136@MatMulSpee
; File c:\home\programming\mathter\main.cpp

; 125  : 			result[i] = left[i] * right[i];

	movaps	xmm0, XMMWORD PTR $T26[rsp]
	movaps	XMMWORD PTR [r8], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+16]
	movaps	XMMWORD PTR [r8+16], xmm1
	movaps	xmm0, XMMWORD PTR $T26[rsp+32]
	movaps	XMMWORD PTR [r8+32], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+48]
	movaps	XMMWORD PTR [r8+48], xmm1

; 124  : 		for (int i = 0; i < iterationCount; ++i) {

	add	rcx, 32					; 00000020H
	add	r8, 64					; 00000040H
	sub	r11, 1
	jne	$LL22@MatMulSpee

; 115  : 			}
; 116  : 		}
; 117  : 	}
; 118  : 
; 119  : 	std::chrono::high_resolution_clock::time_point startTime;
; 120  : 	std::chrono::high_resolution_clock::time_point endTime;
; 121  : 
; 122  : 	startTime = std::chrono::high_resolution_clock::now();
; 123  : 	for (int j = 0; j < 100; ++j) {

	sub	rdi, 1
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, rbx
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rsi, rsi
	je	SHORT $LN224@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR result$[rsp+16]
	sub	rax, rsi
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rcx, 288230376151711743			; 03ffffffffffffffH
	cmp	rax, rcx
	jbe	SHORT $LN291@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN291@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN292@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	sil, 31
	je	SHORT $LN293@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rsi-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rsi
	jb	SHORT $LN294@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN294@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rsi, rax
	cmp	rsi, 8
	jae	SHORT $LN295@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rsi, 39					; 00000027H
	jbe	SHORT $LN296@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN296@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rsi, rax
$LN292@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rsi
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN224@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 576460752303423487			; 07ffffffffffffffH
	test	r14, r14
	je	SHORT $LN334@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR right$[rsp+16]
	sub	rax, r14
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN401@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN401@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN402@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r14b, 31
	je	SHORT $LN403@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN403@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r14-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r14
	jb	SHORT $LN404@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r14, rax
	cmp	r14, 8
	jae	SHORT $LN405@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN405@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r14, 39					; 00000027H
	jbe	SHORT $LN406@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN406@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r14, rax
$LN402@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r14
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN334@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rbp, rbp
	je	SHORT $LN443@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR left$[rsp+16]
	sub	rax, rbp
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN510@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN510@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN511@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	bpl, 31
	je	SHORT $LN512@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN512@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rbp-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rbp
	jb	SHORT $LN513@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN513@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rbp, rax
	cmp	rbp, 8
	jae	SHORT $LN514@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN514@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rbp, 39					; 00000027H
	jbe	SHORT $LN515@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN515@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rbp, rax
$LN511@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rbp
	call	??3@YAXPEAX@Z				; operator delete
$LN443@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 131  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r14
	ret	0
$LN596@MatMulSpee:
??$MatMulSpeedTest@M$01$03$03$01@@YANXZ ENDP		; MatMulSpeedTest<float,2,4,4,2>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T157 = 32
result$ = 40
right$ = 64
left$ = 88
$T26 = 112
__$ArrayPad$ = 176
?dtor$0@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::~vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$0
$T157 = 32
result$ = 40
right$ = 64
left$ = 88
$T26 = 112
__$ArrayPad$ = 176
?dtor$1@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::~vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T157 = 32
result$ = 40
right$ = 64
left$ = 88
$T26 = 112
__$ArrayPad$ = 176
?dtor$0@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$03$00@mathter@@V?$allocator@V?$Matrix@M$01$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >::~vector<mathter::Matrix<float,2,4,1>,std::allocator<mathter::Matrix<float,2,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T157 = 32
result$ = 40
right$ = 64
left$ = 88
$T26 = 112
__$ArrayPad$ = 176
?dtor$1@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$01$00@mathter@@V?$allocator@V?$Matrix@M$03$01$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >::~vector<mathter::Matrix<float,4,2,1>,std::allocator<mathter::Matrix<float,4,2,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
_TEXT	SEGMENT
tv1997 = 32
tv2001 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 192
??$MatMulSpeedTest@M$03$02$02$03@@YANXZ PROC		; MatMulSpeedTest<float,4,3,3,4>, COMDAT

; 90   : double MatMulSpeedTest() {

$LN598:
	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H
	mov	QWORD PTR $T157[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >
	npad	1

; 97   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >
	npad	1

; 98   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$02$02$00@mathter@@V?$allocator@V?$Matrix@M$02$02$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >::vector<mathter::Matrix<float,3,3,1>,std::allocator<mathter::Matrix<float,3,3,1> > >

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r15, QWORD PTR right$[rsp]
	mov	r8, r15
	mov	r12, QWORD PTR left$[rsp]
	mov	r9, r12

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	r11, r12
	neg	r11
	mov	rbx, r15
	neg	rbx

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r10d, 100000				; 000186a0H
$LL4@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rax, QWORD PTR [r9+8]
; File c:\home\programming\mathter\main.cpp

; 109  : 				l(x, y) = 2;

	lea	rcx, QWORD PTR [r11+r12]
	neg	rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	edx, 3
$LL7@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 109  : 				l(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H
	mov	DWORD PTR [rax+4], 1073741824		; 40000000H

; 104  : 		LeftT& l = left[i];
; 105  : 		RightT& r = right[i];
; 106  : 
; 107  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	rdx, 1
	jne	SHORT $LL7@MatMulSpee

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [r8+8]

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	lea	rcx, QWORD PTR [rbx+r15]
	neg	rcx

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	mov	edx, 4
	npad	9
$LL13@MatMulSpee:

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	rdx, 1
	jne	SHORT $LL13@MatMulSpee

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	add	r9, 48					; 00000030H
	add	r8, 64					; 00000040H
	sub	r10, 1
	jne	SHORT $LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	mov	QWORD PTR startTime$1$[rsp], rbx
	lea	rcx, QWORD PTR $T26[rsp]
	mov	rax, r12
	sub	rax, rcx
	mov	QWORD PTR tv2001[rsp], rax
	lea	rbx, QWORD PTR [r12+4]

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	QWORD PTR tv1997[rsp], 100		; 00000064H
	mov	r13, QWORD PTR result$[rsp]
	mov	r12, rax
	npad	9
$LL19@MatMulSpee:
	mov	rsi, r13
	mov	r11, r15
	mov	rdi, r12
	mov	rbp, rbx
	mov	r14d, 100000				; 000186a0H
$LL22@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rax, QWORD PTR $T26[rsp]
	mov	ecx, 3
	npad	1
$LL130@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 227  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm1, XMMWORD PTR [r11]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rdi+rax]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rax], xmm1

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR [rax+16]
	sub	rcx, 1
	jne	SHORT $LL130@MatMulSpee

; 230  : 	}
; 231  : 	for (int x = 1; x < Match; ++x) {

	mov	r9, rbp
	lea	rdx, QWORD PTR [r11+16]
	lea	r10d, QWORD PTR [rcx+3]
	npad	8
$LL133@MatMulSpee:

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T26[rsp]
	mov	rcx, r9
	mov	r8d, 3
$LL136@MatMulSpee:

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 400  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16
	add	rax, 16
	sub	r8, 1
	jne	SHORT $LL136@MatMulSpee

; 230  : 	}
; 231  : 	for (int x = 1; x < Match; ++x) {

	add	rdx, 16
	add	r9, 4
	sub	r10, 1
	jne	SHORT $LL133@MatMulSpee
; File c:\home\programming\mathter\main.cpp

; 125  : 			result[i] = left[i] * right[i];

	movaps	xmm0, XMMWORD PTR $T26[rsp]
	movaps	XMMWORD PTR [rsi], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+16]
	movaps	XMMWORD PTR [rsi+16], xmm1
	movaps	xmm0, XMMWORD PTR $T26[rsp+32]
	movaps	XMMWORD PTR [rsi+32], xmm0

; 124  : 		for (int i = 0; i < iterationCount; ++i) {

	add	r11, 64					; 00000040H
	add	rbp, 48					; 00000030H
	add	rdi, 48					; 00000030H
	add	rsi, 48					; 00000030H
	sub	r14, 1
	jne	$LL22@MatMulSpee

; 115  : 			}
; 116  : 		}
; 117  : 	}
; 118  : 
; 119  : 	std::chrono::high_resolution_clock::time_point startTime;
; 120  : 	std::chrono::high_resolution_clock::time_point endTime;
; 121  : 
; 122  : 	startTime = std::chrono::high_resolution_clock::now();
; 123  : 	for (int j = 0; j < 100; ++j) {

	sub	QWORD PTR tv1997[rsp], 1
	mov	r12, QWORD PTR tv2001[rsp]
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, QWORD PTR startTime$1$[rsp]
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rdi, 384307168202282325			; 0555555555555555H
	test	r13, r13
	mov	r12, QWORD PTR left$[rsp]
	je	SHORT $LN224@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR result$[rsp+16]
	sub	rcx, r13
	mov	rax, rbx
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rdx, rdi
	jbe	SHORT $LN291@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN291@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN292@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r13b, 31
	je	SHORT $LN293@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r13-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r13
	jb	SHORT $LN294@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN294@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r13, rax
	cmp	r13, 8
	jae	SHORT $LN295@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r13, 39					; 00000027H
	jbe	SHORT $LN296@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN296@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r13, rax
$LN292@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r13
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN224@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r15, r15
	je	SHORT $LN334@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR right$[rsp+16]
	sub	rax, r15
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rcx, 288230376151711743			; 03ffffffffffffffH
	cmp	rax, rcx
	jbe	SHORT $LN401@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN401@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN402@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r15b, 31
	je	SHORT $LN403@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN403@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r15-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r15
	jb	SHORT $LN404@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r15, rax
	cmp	r15, 8
	jae	SHORT $LN405@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN405@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r15, 39					; 00000027H
	jbe	SHORT $LN406@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN406@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r15, rax
$LN402@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r15
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN334@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r12, r12
	je	SHORT $LN443@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR left$[rsp+16]
	sub	rcx, r12
	mov	rax, rbx
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rdx, rdi
	jbe	SHORT $LN510@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN510@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN511@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r12b, 31
	je	SHORT $LN512@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN512@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r12-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r12
	jb	SHORT $LN513@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN513@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r12, rax
	cmp	r12, 8
	jae	SHORT $LN514@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN514@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r12, 39					; 00000027H
	jbe	SHORT $LN515@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN515@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r12, rax
$LN511@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r12
	call	??3@YAXPEAX@Z				; operator delete
$LN443@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 131  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN597@MatMulSpee:
??$MatMulSpeedTest@M$03$02$02$03@@YANXZ ENDP		; MatMulSpeedTest<float,4,3,3,4>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv1997 = 32
tv2001 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 192
?dtor$0@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::~vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$0
tv1997 = 32
tv2001 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 192
?dtor$1@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::~vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1997 = 32
tv2001 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 192
?dtor$0@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::~vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1997 = 32
tv2001 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 192
?dtor$1@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::~vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
_TEXT	SEGMENT
tv2014 = 32
tv2017 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 208
??$MatMulSpeedTest@M$02$03$03$02@@YANXZ PROC		; MatMulSpeedTest<float,3,4,4,3>, COMDAT

; 90   : double MatMulSpeedTest() {

$LN598:
	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 240				; 000000f0H
	mov	QWORD PTR $T157[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >
	npad	1

; 97   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >
	npad	1

; 98   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$03$03$00@mathter@@V?$allocator@V?$Matrix@M$03$03$00@mathter@@@std@@@std@@QEAA@_K@Z ; std::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >::vector<mathter::Matrix<float,4,4,1>,std::allocator<mathter::Matrix<float,4,4,1> > >

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r15, QWORD PTR right$[rsp]
	mov	r8, r15
	mov	r12, QWORD PTR left$[rsp]
	mov	r9, r12

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	r11, r12
	neg	r11
	mov	rbx, r15
	neg	rbx

; 91   : 	using LeftT = Matrix<T, Col1, Row1>;
; 92   : 	using RightT = Matrix<T, Col2, Row2>;
; 93   : 	using ResultT = typename decltype(LeftT()*RightT());
; 94   : 
; 95   : 	constexpr int iterationCount = 100'000;
; 96   : 	std::vector<LeftT> left(iterationCount);

	mov	r10d, 100000				; 000186a0H
$LL4@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rax, QWORD PTR [r9+8]
; File c:\home\programming\mathter\main.cpp

; 109  : 				l(x, y) = 2;

	lea	rcx, QWORD PTR [r11+r12]
	neg	rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	edx, 4
$LL7@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 109  : 				l(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H

; 104  : 		LeftT& l = left[i];
; 105  : 		RightT& r = right[i];
; 106  : 
; 107  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	rdx, 1
	jne	SHORT $LL7@MatMulSpee

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [r8+8]

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	lea	rcx, QWORD PTR [rbx+r15]
	neg	rcx

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	mov	edx, 3
$LL13@MatMulSpee:

; 113  : 			for (int y = 0; y < Row2; ++y) {
; 114  : 				r(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H
	mov	DWORD PTR [rax+4], 1073741824		; 40000000H

; 110  : 			}
; 111  : 		}
; 112  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	rdx, 1
	jne	SHORT $LL13@MatMulSpee

; 99   : 
; 100  : 	std::minstd_rand rne;
; 101  : 	std::uniform_real_distribution<T> rng;
; 102  : 
; 103  : 	for (int i = 0; i < iterationCount; ++i) {

	add	r9, 64					; 00000040H
	add	r8, 48					; 00000030H
	sub	r10, 1
	jne	SHORT $LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	mov	QWORD PTR startTime$1$[rsp], rbx
	lea	rcx, QWORD PTR $T26[rsp]
	mov	rax, r12
	sub	rax, rcx
	mov	QWORD PTR tv2017[rsp], rax
	lea	rbx, QWORD PTR [r12+4]

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	QWORD PTR tv2014[rsp], 100		; 00000064H
	mov	r13, QWORD PTR result$[rsp]
	mov	r12, rax
	npad	2
$LL19@MatMulSpee:
	mov	rdi, r13
	mov	r11, r15
	mov	rsi, r12
	mov	rbp, rbx
	mov	r14d, 100000				; 000186a0H
$LL22@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rax, QWORD PTR $T26[rsp]
	mov	ecx, 4
	npad	1
$LL130@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 227  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm1, XMMWORD PTR [r11]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rsi+rax]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 229  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rax], xmm1

; 226  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR [rax+16]
	sub	rcx, 1
	jne	SHORT $LL130@MatMulSpee

; 230  : 	}
; 231  : 	for (int x = 1; x < Match; ++x) {

	mov	r9, rbp
	lea	rdx, QWORD PTR [r11+16]
	lea	r10d, QWORD PTR [rcx+2]
	npad	8
$LL133@MatMulSpee:

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T26[rsp]
	mov	rcx, r9
	mov	r8d, 4
$LL136@MatMulSpee:

; 233  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 460  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 232  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16
	add	rax, 16
	sub	r8, 1
	jne	SHORT $LL136@MatMulSpee

; 230  : 	}
; 231  : 	for (int x = 1; x < Match; ++x) {

	add	rdx, 16
	add	r9, 4
	sub	r10, 1
	jne	SHORT $LL133@MatMulSpee
; File c:\home\programming\mathter\main.cpp

; 125  : 			result[i] = left[i] * right[i];

	movaps	xmm0, XMMWORD PTR $T26[rsp]
	movaps	XMMWORD PTR [rdi], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+16]
	movaps	XMMWORD PTR [rdi+16], xmm1
	movaps	xmm0, XMMWORD PTR $T26[rsp+32]
	movaps	XMMWORD PTR [rdi+32], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+48]
	movaps	XMMWORD PTR [rdi+48], xmm1

; 124  : 		for (int i = 0; i < iterationCount; ++i) {

	add	r11, 48					; 00000030H
	add	rbp, 64					; 00000040H
	add	rsi, 64					; 00000040H
	add	rdi, 64					; 00000040H
	sub	r14, 1
	jne	$LL22@MatMulSpee

; 115  : 			}
; 116  : 		}
; 117  : 	}
; 118  : 
; 119  : 	std::chrono::high_resolution_clock::time_point startTime;
; 120  : 	std::chrono::high_resolution_clock::time_point endTime;
; 121  : 
; 122  : 	startTime = std::chrono::high_resolution_clock::now();
; 123  : 	for (int j = 0; j < 100; ++j) {

	sub	QWORD PTR tv2014[rsp], 1
	mov	r12, QWORD PTR tv2017[rsp]
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, QWORD PTR startTime$1$[rsp]
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 288230376151711743			; 03ffffffffffffffH
	test	r13, r13
	mov	r12, QWORD PTR left$[rsp]
	je	SHORT $LN224@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR result$[rsp+16]
	sub	rax, r13
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN291@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN291@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN292@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r13b, 31
	je	SHORT $LN293@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r13-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r13
	jb	SHORT $LN294@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN294@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r13, rax
	cmp	r13, 8
	jae	SHORT $LN295@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r13, 39					; 00000027H
	jbe	SHORT $LN296@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN296@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r13, rax
$LN292@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r13
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN224@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r15, r15
	je	$LN334@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR right$[rsp+16]
	sub	rcx, r15
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	rdx, rax
	jbe	SHORT $LN401@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN401@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN402@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r15b, 31
	je	SHORT $LN403@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN403@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r15-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r15
	jb	SHORT $LN404@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r15, rax
	cmp	r15, 8
	jae	SHORT $LN405@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN405@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r15, 39					; 00000027H
	jbe	SHORT $LN406@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN406@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r15, rax
$LN402@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r15
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN334@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r12, r12
	je	SHORT $LN443@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR left$[rsp+16]
	sub	rax, r12
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN510@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN510@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN511@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r12b, 31
	je	SHORT $LN512@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN512@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r12-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r12
	jb	SHORT $LN513@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN513@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r12, rax
	cmp	r12, 8
	jae	SHORT $LN514@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN514@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r12, 39					; 00000027H
	jbe	SHORT $LN515@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN515@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r12, rax
$LN511@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r12
	call	??3@YAXPEAX@Z				; operator delete
$LN443@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 130  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 131  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+240]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN597@MatMulSpee:
??$MatMulSpeedTest@M$02$03$03$02@@YANXZ ENDP		; MatMulSpeedTest<float,3,4,4,3>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv2014 = 32
tv2017 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 208
?dtor$0@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::~vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$0
tv2014 = 32
tv2017 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 208
?dtor$1@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::~vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2014 = 32
tv2017 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 208
?dtor$0@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$03$00@mathter@@V?$allocator@V?$Matrix@M$02$03$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >::~vector<mathter::Matrix<float,3,4,1>,std::allocator<mathter::Matrix<float,3,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2014 = 32
tv2017 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 208
?dtor$1@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$02$00@mathter@@V?$allocator@V?$Matrix@M$03$02$00@mathter@@@std@@@std@@QEAA@XZ ; std::vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >::~vector<mathter::Matrix<float,4,3,1>,std::allocator<mathter::Matrix<float,4,3,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Assign@?$Vector@M$03@mathter@@IEAAXH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
?Assign@?$Vector@M$03@mathter@@IEAAXH@Z PROC		; mathter::Vector<float,4>::Assign, COMDAT

; 853  : 	void Assign(int idx) {

$LN11:
	mov	QWORD PTR [rsp+8], rdi
	mov	rdi, rcx

; 854  : 		for (; idx < D; idx++) {

	cmp	edx, 4
	jge	SHORT $LN3@Assign

; 855  : 			data[idx] = T(0);

	mov	eax, 4
	sub	eax, edx
	movsxd	rcx, eax
	movsxd	rax, edx
	lea	rdi, QWORD PTR [rdi+rax*4]
	xor	eax, eax
	rep stosd
$LN3@Assign:

; 856  : 		}
; 857  : 	}

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
?Assign@?$Vector@M$03@mathter@@IEAAXH@Z ENDP		; mathter::Vector<float,4>::Assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??R?$Vector@M$03@mathter@@QEAAAEAMH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??R?$Vector@M$03@mathter@@QEAAAEAMH@Z PROC		; mathter::Vector<float,4>::operator(), COMDAT

; 687  : 		return data[idx];

	movsxd	rax, edx
	lea	rax, QWORD PTR [rcx+rax*4]

; 688  : 	}

	ret	0
??R?$Vector@M$03@mathter@@QEAAAEAMH@Z ENDP		; mathter::Vector<float,4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MMM$0A@@?$Vector@M$02@mathter@@IEAAXHMMM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<scalars_0>$ = 32
<scalars_1>$ = 40
??$Assign@MMM$0A@@?$Vector@M$02@mathter@@IEAAXHMMM@Z PROC ; mathter::Vector<float,3>::Assign<float,float,float,0>, COMDAT

; 838  : 		data[idx] = head;

	movss	xmm0, DWORD PTR <scalars_1>$[rsp]
	movss	DWORD PTR [rcx], xmm2
	movss	DWORD PTR [rcx+4], xmm3
	movss	DWORD PTR [rcx+8], xmm0

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@MMM$0A@@?$Vector@M$02@mathter@@IEAAXHMMM@Z ENDP ; mathter::Vector<float,3>::Assign<float,float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MMMM$0A@@?$Vector@M$03@mathter@@IEAAXHMMMM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<scalars_0>$ = 32
<scalars_1>$ = 40
<scalars_2>$ = 48
??$Assign@MMMM$0A@@?$Vector@M$03@mathter@@IEAAXHMMMM@Z PROC ; mathter::Vector<float,4>::Assign<float,float,float,float,0>, COMDAT

; 838  : 		data[idx] = head;

	movss	xmm0, DWORD PTR <scalars_1>$[rsp]
	movss	xmm1, DWORD PTR <scalars_2>$[rsp]
	movss	DWORD PTR [rcx], xmm2
	movss	DWORD PTR [rcx+4], xmm3
	movss	DWORD PTR [rcx+8], xmm0
	movss	DWORD PTR [rcx+12], xmm1

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@MMMM$0A@@?$Vector@M$03@mathter@@IEAAXHMMMM@Z ENDP ; mathter::Vector<float,4>::Assign<float,float,float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@V?$Vector@M$03@mathter@@$$V$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
head$ = 24
??$Assign@V?$Vector@M$03@mathter@@$$V$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@@Z PROC ; mathter::Vector<float,8>::Assign<mathter::Vector<float,4>,0>, COMDAT

; 844  : 	void Assign(int idx, const Head& head, const Mixed&... mixed) {

$LN26:
	mov	QWORD PTR [rsp+8], rdi

; 845  : 		for (int i = 0; i < impl::DimensionOf<Head>::value; ++i) {
; 846  : 			data[idx] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [r8]
	mov	r10, rcx
	movsxd	r9, edx
	mov	DWORD PTR [rcx+r9*4], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+r9*4+4], eax
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+r9*4+8], eax
	mov	eax, DWORD PTR [r8+12]
	mov	DWORD PTR [rcx+r9*4+12], eax
	add	r9d, 4

; 854  : 		for (; idx < D; idx++) {

	cmp	r9d, 8
	jge	SHORT $LN10@Assign
	mov	eax, 8

; 855  : 			data[idx] = T(0);

	movsxd	rdx, r9d
	sub	eax, r9d
	movsxd	rcx, eax
	xor	eax, eax
	lea	rdi, QWORD PTR [r10+rdx*4]
	rep stosd
$LN10@Assign:

; 847  : 			++idx;
; 848  : 		}
; 849  : 		Assign(idx, mixed...);
; 850  : 	}

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
??$Assign@V?$Vector@M$03@mathter@@$$V$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@@Z ENDP ; mathter::Vector<float,8>::Assign<mathter::Vector<float,4>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
<scalars_3>$dead$ = 56
<scalars_4>$dead$ = 64
<scalars_5>$dead$ = 72
<scalars_6>$dead$ = 80
??$Assign@HHHHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHHHH@Z PROC ; mathter::Vector<float,8>::Assign<int,int,int,int,int,int,int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+12], 1082130432		; 40800000H
	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@HHHHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHHHH@Z ENDP ; mathter::Vector<float,8>::Assign<int,int,int,int,int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@V?$Vector@M$03@mathter@@V12@$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@0@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<mixed_0>$ = 32
??$Assign@V?$Vector@M$03@mathter@@V12@$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@0@Z PROC ; mathter::Vector<float,8>::Assign<mathter::Vector<float,4>,mathter::Vector<float,4>,0>, COMDAT

; 845  : 		for (int i = 0; i < impl::DimensionOf<Head>::value; ++i) {
; 846  : 			data[idx] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r8+12]
	mov	DWORD PTR [rcx+12], eax
	mov	eax, DWORD PTR [r9]
	mov	DWORD PTR [rcx+16], eax
	mov	eax, DWORD PTR [r9+4]
	mov	DWORD PTR [rcx+20], eax
	mov	eax, DWORD PTR [r9+8]
	mov	DWORD PTR [rcx+24], eax
	mov	eax, DWORD PTR [r9+12]
	mov	DWORD PTR [rcx+28], eax

; 847  : 			++idx;
; 848  : 		}
; 849  : 		Assign(idx, mixed...);
; 850  : 	}

	ret	0
??$Assign@V?$Vector@M$03@mathter@@V12@$0A@@?$Vector@M$07@mathter@@IEAAXHAEBV?$Vector@M$03@1@0@Z ENDP ; mathter::Vector<float,8>::Assign<mathter::Vector<float,4>,mathter::Vector<float,4>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
head$ = 24
<scalars_0>$ = 32
<scalars_1>$ = 40
??$Assign@HHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHH@Z PROC ; mathter::Vector<float,3>::Assign<int,int,int,0>, COMDAT

; 837  : 	void Assign(int idx, Head head, Scalars... scalars) {

$LN17:
	mov	QWORD PTR [rsp+8], rdi

; 838  : 		data[idx] = head;

	movsxd	rax, edx
	mov	rdi, rcx

; 839  : 		Assign(idx + 1, scalars...);

	inc	edx
	movd	xmm0, r8d
	cvtdq2ps xmm0, xmm0
	movd	xmm1, r9d
	movss	DWORD PTR [rcx+rax*4], xmm0
	movd	xmm0, DWORD PTR <scalars_1>$[rsp]

; 838  : 		data[idx] = head;

	movsxd	rax, edx

; 839  : 		Assign(idx + 1, scalars...);

	inc	edx
	cvtdq2ps xmm1, xmm1

; 838  : 		data[idx] = head;

	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rcx+rax*4], xmm1
	movsxd	rax, edx

; 839  : 		Assign(idx + 1, scalars...);

	inc	edx
	movss	DWORD PTR [rcx+rax*4], xmm0

; 854  : 		for (; idx < D; idx++) {

	cmp	edx, 3
	jge	SHORT $LN9@Assign
	mov	eax, 3
	sub	eax, edx
	movsxd	rcx, eax

; 855  : 			data[idx] = T(0);

	movsxd	rax, edx
	lea	rdi, QWORD PTR [rdi+rax*4]
	xor	eax, eax
	rep stosd
$LN9@Assign:

; 840  : 	}

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
??$Assign@HHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHH@Z ENDP ; mathter::Vector<float,3>::Assign<int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MV?$Vector@M$02@mathter@@$0A@@?$Vector@M$03@mathter@@IEAAXHAEBMAEBV?$Vector@M$02@1@@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<mixed_0>$ = 32
??$Assign@MV?$Vector@M$02@mathter@@$0A@@?$Vector@M$03@mathter@@IEAAXHAEBMAEBV?$Vector@M$02@1@@Z PROC ; mathter::Vector<float,4>::Assign<float,mathter::Vector<float,3>,0>, COMDAT

; 845  : 		for (int i = 0; i < impl::DimensionOf<Head>::value; ++i) {
; 846  : 			data[idx] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [r9]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [r9+4]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r9+8]
	mov	DWORD PTR [rcx+12], eax

; 847  : 			++idx;
; 848  : 		}
; 849  : 		Assign(idx, mixed...);
; 850  : 	}

	ret	0
??$Assign@MV?$Vector@M$02@mathter@@$0A@@?$Vector@M$03@mathter@@IEAAXHAEBMAEBV?$Vector@M$02@1@@Z ENDP ; mathter::Vector<float,4>::Assign<float,mathter::Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
??$Assign@HHHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHHH@Z PROC ; mathter::Vector<float,3>::Assign<int,int,int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+4], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+8], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+12], 1088421888		; 40e00000H

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@HHHH$0A@@?$Vector@M$02@mathter@@IEAAXHHHHH@Z ENDP ; mathter::Vector<float,3>::Assign<int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Assign@?$Vector@M$07@mathter@@IEAAXH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
?Assign@?$Vector@M$07@mathter@@IEAAXH@Z PROC		; mathter::Vector<float,8>::Assign, COMDAT

; 853  : 	void Assign(int idx) {

$LN11:
	mov	QWORD PTR [rsp+8], rdi
	mov	rdi, rcx

; 854  : 		for (; idx < D; idx++) {

	cmp	edx, 8
	jge	SHORT $LN3@Assign

; 855  : 			data[idx] = T(0);

	mov	eax, 8
	sub	eax, edx
	movsxd	rcx, eax
	movsxd	rax, edx
	lea	rdi, QWORD PTR [rdi+rax*4]
	xor	eax, eax
	rep stosd
$LN3@Assign:

; 856  : 		}
; 857  : 	}

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
?Assign@?$Vector@M$07@mathter@@IEAAXH@Z ENDP		; mathter::Vector<float,8>::Assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MM$0A@@?$Vector@M$02@mathter@@IEAAXHMM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<scalars_0>$ = 32
??$Assign@MM$0A@@?$Vector@M$02@mathter@@IEAAXHMM@Z PROC	; mathter::Vector<float,3>::Assign<float,float,0>, COMDAT

; 838  : 		data[idx] = head;

	movss	DWORD PTR [rcx+4], xmm2
	movss	DWORD PTR [rcx+8], xmm3

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@MM$0A@@?$Vector@M$02@mathter@@IEAAXHMM@Z ENDP	; mathter::Vector<float,3>::Assign<float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MMM$0A@@?$Vector@M$03@mathter@@IEAAXHMMM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<scalars_0>$ = 32
<scalars_1>$ = 40
??$Assign@MMM$0A@@?$Vector@M$03@mathter@@IEAAXHMMM@Z PROC ; mathter::Vector<float,4>::Assign<float,float,float,0>, COMDAT

; 838  : 		data[idx] = head;

	movss	xmm0, DWORD PTR <scalars_1>$[rsp]
	movss	DWORD PTR [rcx+4], xmm2
	movss	DWORD PTR [rcx+8], xmm3
	movss	DWORD PTR [rcx+12], xmm0

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@MMM$0A@@?$Vector@M$03@mathter@@IEAAXHMMM@Z ENDP ; mathter::Vector<float,4>::Assign<float,float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
<scalars_3>$dead$ = 56
<scalars_4>$dead$ = 64
<scalars_5>$dead$ = 72
??$Assign@HHHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHHH@Z PROC ; mathter::Vector<float,8>::Assign<int,int,int,int,int,int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+12], 1082130432		; 40800000H
	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@HHHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHHH@Z ENDP ; mathter::Vector<float,8>::Assign<int,int,int,int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HH$0A@@?$Vector@M$02@mathter@@IEAAXHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
head$ = 24
<scalars_0>$ = 32
??$Assign@HH$0A@@?$Vector@M$02@mathter@@IEAAXHHH@Z PROC	; mathter::Vector<float,3>::Assign<int,int,0>, COMDAT

; 837  : 	void Assign(int idx, Head head, Scalars... scalars) {

$LN15:
	mov	QWORD PTR [rsp+8], rdi

; 838  : 		data[idx] = head;

	movsxd	rax, edx
	mov	rdi, rcx

; 839  : 		Assign(idx + 1, scalars...);

	inc	edx
	movd	xmm0, r8d
	cvtdq2ps xmm0, xmm0
	movd	xmm1, r9d
	movss	DWORD PTR [rcx+rax*4], xmm0

; 838  : 		data[idx] = head;

	movsxd	rax, edx

; 839  : 		Assign(idx + 1, scalars...);

	inc	edx
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR [rcx+rax*4], xmm1

; 854  : 		for (; idx < D; idx++) {

	cmp	edx, 3
	jge	SHORT $LN7@Assign
	mov	eax, 3
	sub	eax, edx
	movsxd	rcx, eax

; 855  : 			data[idx] = T(0);

	movsxd	rax, edx
	lea	rdi, QWORD PTR [rdi+rax*4]
	xor	eax, eax
	rep stosd
$LN7@Assign:

; 840  : 	}

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
??$Assign@HH$0A@@?$Vector@M$02@mathter@@IEAAXHHH@Z ENDP	; mathter::Vector<float,3>::Assign<int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@IEAAXHAEBV?$Vector@M$02@1@@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
head$ = 24
??$Assign@V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@IEAAXHAEBV?$Vector@M$02@1@@Z PROC ; mathter::Vector<float,4>::Assign<mathter::Vector<float,3>,0>, COMDAT

; 844  : 	void Assign(int idx, const Head& head, const Mixed&... mixed) {

$LN25:
	mov	QWORD PTR [rsp+8], rdi

; 845  : 		for (int i = 0; i < impl::DimensionOf<Head>::value; ++i) {
; 846  : 			data[idx] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [r8]
	mov	r10, rcx
	movsxd	r9, edx
	mov	DWORD PTR [rcx+r9*4], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+r9*4+4], eax
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+r9*4+8], eax
	add	r9d, 3

; 854  : 		for (; idx < D; idx++) {

	cmp	r9d, 4
	jge	SHORT $LN10@Assign
	mov	eax, 4

; 855  : 			data[idx] = T(0);

	movsxd	rdx, r9d
	sub	eax, r9d
	movsxd	rcx, eax
	xor	eax, eax
	lea	rdi, QWORD PTR [r10+rdx*4]
	rep stosd
$LN10@Assign:

; 847  : 			++idx;
; 848  : 		}
; 849  : 		Assign(idx, mixed...);
; 850  : 	}

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
??$Assign@V?$Vector@M$02@mathter@@$$V$0A@@?$Vector@M$03@mathter@@IEAAXHAEBV?$Vector@M$02@1@@Z ENDP ; mathter::Vector<float,4>::Assign<mathter::Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@M$$V$0A@@?$Vector@M$02@mathter@@IEAAXHM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
??$Assign@M$$V$0A@@?$Vector@M$02@mathter@@IEAAXHM@Z PROC ; mathter::Vector<float,3>::Assign<float,0>, COMDAT

; 838  : 		data[idx] = head;

	movss	DWORD PTR [rcx+8], xmm2

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@M$$V$0A@@?$Vector@M$02@mathter@@IEAAXHM@Z ENDP ; mathter::Vector<float,3>::Assign<float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MM$0A@@?$Vector@M$03@mathter@@IEAAXHMM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<scalars_0>$ = 32
??$Assign@MM$0A@@?$Vector@M$03@mathter@@IEAAXHMM@Z PROC	; mathter::Vector<float,4>::Assign<float,float,0>, COMDAT

; 838  : 		data[idx] = head;

	movss	DWORD PTR [rcx+8], xmm2
	movss	DWORD PTR [rcx+12], xmm3

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@MM$0A@@?$Vector@M$03@mathter@@IEAAXHMM@Z ENDP	; mathter::Vector<float,4>::Assign<float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
<scalars_3>$dead$ = 56
<scalars_4>$dead$ = 64
??$Assign@HHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHH@Z PROC ; mathter::Vector<float,8>::Assign<int,int,int,int,int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+12], 1082130432		; 40800000H
	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@HHHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHHH@Z ENDP ; mathter::Vector<float,8>::Assign<int,int,int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@H$$V$0A@@?$Vector@M$02@mathter@@IEAAXHH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
head$ = 24
??$Assign@H$$V$0A@@?$Vector@M$02@mathter@@IEAAXHH@Z PROC ; mathter::Vector<float,3>::Assign<int,0>, COMDAT

; 837  : 	void Assign(int idx, Head head, Scalars... scalars) {

$LN13:
	mov	QWORD PTR [rsp+8], rdi

; 838  : 		data[idx] = head;

	movsxd	rax, edx
	mov	rdi, rcx
	movd	xmm0, r8d

; 839  : 		Assign(idx + 1, scalars...);

	inc	edx
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rcx+rax*4], xmm0

; 854  : 		for (; idx < D; idx++) {

	cmp	edx, 3
	jge	SHORT $LN5@Assign
	mov	eax, 3
	sub	eax, edx
	movsxd	rcx, eax

; 855  : 			data[idx] = T(0);

	movsxd	rax, edx
	lea	rdi, QWORD PTR [rdi+rax*4]
	xor	eax, eax
	rep stosd
$LN5@Assign:

; 840  : 	}

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
??$Assign@H$$V$0A@@?$Vector@M$02@mathter@@IEAAXHH@Z ENDP ; mathter::Vector<float,3>::Assign<int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Assign@?$Vector@M$02@mathter@@IEAAXH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
?Assign@?$Vector@M$02@mathter@@IEAAXH@Z PROC		; mathter::Vector<float,3>::Assign, COMDAT

; 853  : 	void Assign(int idx) {

$LN11:
	mov	QWORD PTR [rsp+8], rdi
	mov	rdi, rcx

; 854  : 		for (; idx < D; idx++) {

	cmp	edx, 3
	jge	SHORT $LN3@Assign

; 855  : 			data[idx] = T(0);

	mov	eax, 3
	sub	eax, edx
	movsxd	rcx, eax
	movsxd	rax, edx
	lea	rdi, QWORD PTR [rdi+rax*4]
	xor	eax, eax
	rep stosd
$LN3@Assign:

; 856  : 		}
; 857  : 	}

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
?Assign@?$Vector@M$02@mathter@@IEAAXH@Z ENDP		; mathter::Vector<float,3>::Assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@M$$V$0A@@?$Vector@M$03@mathter@@IEAAXHM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
??$Assign@M$$V$0A@@?$Vector@M$03@mathter@@IEAAXHM@Z PROC ; mathter::Vector<float,4>::Assign<float,0>, COMDAT

; 838  : 		data[idx] = head;

	movss	DWORD PTR [rcx+12], xmm2

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@M$$V$0A@@?$Vector@M$03@mathter@@IEAAXHM@Z ENDP ; mathter::Vector<float,4>::Assign<float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
<scalars_3>$dead$ = 56
??$Assign@HHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHH@Z PROC ; mathter::Vector<float,8>::Assign<int,int,int,int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx+12], 1082130432		; 40800000H
	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@HHHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHHH@Z ENDP ; mathter::Vector<float,8>::Assign<int,int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
??$Assign@HHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHH@Z PROC ; mathter::Vector<float,8>::Assign<int,int,int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@HHHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHHH@Z ENDP ; mathter::Vector<float,8>::Assign<int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
??$Assign@HHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHH@Z PROC ; mathter::Vector<float,8>::Assign<int,int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@HHH$0A@@?$Vector@M$07@mathter@@IEAAXHHHH@Z ENDP ; mathter::Vector<float,8>::Assign<int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HH$0A@@?$Vector@M$07@mathter@@IEAAXHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
??$Assign@HH$0A@@?$Vector@M$07@mathter@@IEAAXHHH@Z PROC	; mathter::Vector<float,8>::Assign<int,int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@HH$0A@@?$Vector@M$07@mathter@@IEAAXHHH@Z ENDP	; mathter::Vector<float,8>::Assign<int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@H$$V$0A@@?$Vector@M$07@mathter@@IEAAXHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
??$Assign@H$$V$0A@@?$Vector@M$07@mathter@@IEAAXHH@Z PROC ; mathter::Vector<float,8>::Assign<int,0>, COMDAT

; 838  : 		data[idx] = head;

	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 839  : 		Assign(idx + 1, scalars...);
; 840  : 	}

	ret	0
??$Assign@H$$V$0A@@?$Vector@M$07@mathter@@IEAAXHH@Z ENDP ; mathter::Vector<float,8>::Assign<int,0>
_TEXT	ENDS
END
