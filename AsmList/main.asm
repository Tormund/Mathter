; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	__imp_?rdstate@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__Query_perf_counter:PROC
EXTRN	__imp___std_terminate:PROC
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp__Query_perf_frequency:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	__security_check_cookie:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
$SG4294967239 DB '{', 00H
$SG4294967238 DB 00H
$SG4294967197 DB 00H
$SG4294967237 DB 09H, 00H
$SG4294967193 DB 00H
$SG4294967189 DB 00H
$SG4294967236 DB '}', 0aH, 00H
$SG4294967185 DB 00H
$SG4294967235 DB ' x ', 00H
$SG4294967234 DB ' = ', 00H
$SG4294967233 DB ' & ', 00H
$SG4294967232 DB ' ms', 00H
$SG4294967230 DB ' ms', 00H
$SG4294967231 DB 'time 2x2 x 2x2:', 09H, 00H
$SG4294967181 DB 00H
$SG4294967177 DB 00H
	ORG $+5
$SG4294967229 DB 'time 3x3 x 3x3:', 09H, 00H
	ORG $+3
$SG4294967228 DB ' ms', 00H
$SG4294967227 DB 'time 4x4 x 4x4:', 09H, 00H
	ORG $+3
$SG4294967226 DB ' ms', 00H
$SG4294967225 DB 'time 4x2 x 2x4:', 09H, 00H
	ORG $+3
$SG4294967224 DB ' ms', 00H
$SG4294967223 DB 'time 2x4 x 4x2:', 09H, 00H
	ORG $+3
$SG4294967222 DB ' ms', 00H
$SG4294967221 DB 'time 4x3 x 3x4:', 09H, 00H
	ORG $+3
$SG4294967220 DB ' ms', 00H
$SG4294967219 DB 'time 3x4 x 4x3:', 09H, 00H
	ORG $+3
$SG4294967198 DB '{', 00H
	ORG $+2
$SG4294967196 DB 09H, 00H
	ORG $+2
$SG4294967195 DB '}', 00H
	ORG $+2
$SG4294967194 DB '{', 00H
	ORG $+2
$SG4294967192 DB 09H, 00H
	ORG $+2
$SG4294967191 DB '}', 0aH, 00H
	ORG $+1
$SG4294967190 DB '{', 00H
	ORG $+2
$SG4294967188 DB 09H, 00H
	ORG $+2
$SG4294967187 DB '}', 0aH, 00H
	ORG $+1
$SG4294967186 DB '{', 00H
	ORG $+2
$SG4294967184 DB 09H, 00H
	ORG $+2
$SG4294967183 DB '}', 0aH, 00H
	ORG $+1
$SG4294967182 DB '{', 00H
	ORG $+2
$SG4294967180 DB 09H, 00H
	ORG $+2
$SG4294967179 DB '}', 0aH, 00H
	ORG $+1
$SG4294967178 DB '{', 00H
	ORG $+2
$SG4294967176 DB 09H, 00H
	ORG $+2
$SG4294967175 DB '}', 0aH, 00H
CONST	ENDS
PUBLIC	??$Assign@H$$V$0A@@?$Vector@M$07@@IEAAXHH@Z	; Vector<float,8>::Assign<int,0>
PUBLIC	??$Assign@HH$0A@@?$Vector@M$07@@IEAAXHHH@Z	; Vector<float,8>::Assign<int,int,0>
PUBLIC	??$Assign@HHH$0A@@?$Vector@M$07@@IEAAXHHHH@Z	; Vector<float,8>::Assign<int,int,int,0>
PUBLIC	??$construct@V?$Matrix@M$01$01$00@@$$V@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@@Z ; std::allocator<Matrix<float,2,2,1> >::construct<Matrix<float,2,2,1> >
PUBLIC	??$construct@V?$Matrix@M$02$02$00@@$$V@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@@Z ; std::allocator<Matrix<float,3,3,1> >::construct<Matrix<float,3,3,1> >
PUBLIC	??$construct@V?$Matrix@M$03$03$00@@$$V@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@@Z ; std::allocator<Matrix<float,4,4,1> >::construct<Matrix<float,4,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$01$00@@$$V@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@@Z ; std::allocator<Matrix<float,4,2,1> >::construct<Matrix<float,4,2,1> >
PUBLIC	??$construct@V?$Matrix@M$01$03$00@@$$V@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@@Z ; std::allocator<Matrix<float,2,4,1> >::construct<Matrix<float,2,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$02$00@@$$V@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@@Z ; std::allocator<Matrix<float,4,3,1> >::construct<Matrix<float,4,3,1> >
PUBLIC	??$construct@V?$Matrix@M$02$03$00@@$$V@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@@Z ; std::allocator<Matrix<float,3,4,1> >::construct<Matrix<float,3,4,1> >
PUBLIC	??$Assign@HHHH$0A@@?$Vector@M$07@@IEAAXHHHHH@Z	; Vector<float,8>::Assign<int,int,int,int,0>
PUBLIC	??$construct@V?$Matrix@M$01$01$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$01$01$00@@@1@PEAV?$Matrix@M$01$01$00@@@Z ; std::allocator_traits<std::allocator<Matrix<float,2,2,1> > >::construct<Matrix<float,2,2,1> >
PUBLIC	??$construct@V?$Matrix@M$02$02$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$02$02$00@@@1@PEAV?$Matrix@M$02$02$00@@@Z ; std::allocator_traits<std::allocator<Matrix<float,3,3,1> > >::construct<Matrix<float,3,3,1> >
PUBLIC	??$construct@V?$Matrix@M$03$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$03$00@@@1@PEAV?$Matrix@M$03$03$00@@@Z ; std::allocator_traits<std::allocator<Matrix<float,4,4,1> > >::construct<Matrix<float,4,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$01$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$01$00@@@1@PEAV?$Matrix@M$03$01$00@@@Z ; std::allocator_traits<std::allocator<Matrix<float,4,2,1> > >::construct<Matrix<float,4,2,1> >
PUBLIC	??$construct@V?$Matrix@M$01$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$01$03$00@@@1@PEAV?$Matrix@M$01$03$00@@@Z ; std::allocator_traits<std::allocator<Matrix<float,2,4,1> > >::construct<Matrix<float,2,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$02$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$02$00@@@1@PEAV?$Matrix@M$03$02$00@@@Z ; std::allocator_traits<std::allocator<Matrix<float,4,3,1> > >::construct<Matrix<float,4,3,1> >
PUBLIC	??$construct@V?$Matrix@M$02$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$02$03$00@@@1@PEAV?$Matrix@M$02$03$00@@@Z ; std::allocator_traits<std::allocator<Matrix<float,3,4,1> > >::construct<Matrix<float,3,4,1> >
PUBLIC	??$Assign@HHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHH@Z ; Vector<float,8>::Assign<int,int,int,int,int,0>
PUBLIC	??$Assign@M$$V$0A@@?$Vector@M$03@@IEAAXHM@Z	; Vector<float,4>::Assign<float,0>
PUBLIC	??$construct@V?$Matrix@M$01$01$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::construct<Matrix<float,2,2,1> >
PUBLIC	??$construct@V?$Matrix@M$02$02$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::construct<Matrix<float,3,3,1> >
PUBLIC	??$construct@V?$Matrix@M$03$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::construct<Matrix<float,4,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$01$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::construct<Matrix<float,4,2,1> >
PUBLIC	??$construct@V?$Matrix@M$01$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::construct<Matrix<float,2,4,1> >
PUBLIC	??$construct@V?$Matrix@M$03$02$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::construct<Matrix<float,4,3,1> >
PUBLIC	??$construct@V?$Matrix@M$02$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::construct<Matrix<float,3,4,1> >
PUBLIC	??$Assign@HHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHH@Z ; Vector<float,8>::Assign<int,int,int,int,int,int,0>
PUBLIC	??$Assign@MM$0A@@?$Vector@M$03@@IEAAXHMM@Z	; Vector<float,4>::Assign<float,float,0>
PUBLIC	??$Assign@M$$V$0A@@?$Vector@M$02@@IEAAXHM@Z	; Vector<float,3>::Assign<float,0>
PUBLIC	??$_Unfancy@V?$Matrix@M$01$01$00@@@std@@YAPEAV?$Matrix@M$01$01$00@@PEAV1@@Z ; std::_Unfancy<Matrix<float,2,2,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$02$02$00@@@std@@YAPEAV?$Matrix@M$02$02$00@@PEAV1@@Z ; std::_Unfancy<Matrix<float,3,3,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$03$03$00@@@std@@YAPEAV?$Matrix@M$03$03$00@@PEAV1@@Z ; std::_Unfancy<Matrix<float,4,4,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$03$01$00@@@std@@YAPEAV?$Matrix@M$03$01$00@@PEAV1@@Z ; std::_Unfancy<Matrix<float,4,2,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$01$03$00@@@std@@YAPEAV?$Matrix@M$01$03$00@@PEAV1@@Z ; std::_Unfancy<Matrix<float,2,4,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$03$02$00@@@std@@YAPEAV?$Matrix@M$03$02$00@@PEAV1@@Z ; std::_Unfancy<Matrix<float,4,3,1> >
PUBLIC	??$_Unfancy@V?$Matrix@M$02$03$00@@@std@@YAPEAV?$Matrix@M$02$03$00@@PEAV1@@Z ; std::_Unfancy<Matrix<float,3,4,1> >
PUBLIC	?Assign@?$Vector@M$07@@IEAAXH@Z			; Vector<float,8>::Assign
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$01$01$00@@@std@@PEAV?$Matrix@M$01$01$00@@@std@@YAXPEAV?$Matrix@M$01$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Matrix<float,2,2,1> >,Matrix<float,2,2,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$02$00@@@std@@PEAV?$Matrix@M$02$02$00@@@std@@YAXPEAV?$Matrix@M$02$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Matrix<float,3,3,1> >,Matrix<float,3,3,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$03$00@@@std@@PEAV?$Matrix@M$03$03$00@@@std@@YAXPEAV?$Matrix@M$03$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Matrix<float,4,4,1> >,Matrix<float,4,4,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$01$00@@@std@@PEAV?$Matrix@M$03$01$00@@@std@@YAXPEAV?$Matrix@M$03$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Matrix<float,4,2,1> >,Matrix<float,4,2,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$01$03$00@@@std@@PEAV?$Matrix@M$01$03$00@@@std@@YAXPEAV?$Matrix@M$01$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Matrix<float,2,4,1> >,Matrix<float,2,4,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$02$00@@@std@@PEAV?$Matrix@M$03$02$00@@@std@@YAXPEAV?$Matrix@M$03$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Matrix<float,4,3,1> >,Matrix<float,4,3,1> * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$03$00@@@std@@PEAV?$Matrix@M$02$03$00@@@std@@YAXPEAV?$Matrix@M$02$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Matrix<float,3,4,1> >,Matrix<float,3,4,1> * __ptr64>
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$01$00@@_KV?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,2,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,2,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$02$00@@_KV?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,3,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$03$00@@_KV?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,4,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,4,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$01$00@@_KV?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,4,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,2,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$03$00@@_KV?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,2,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,4,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$02$00@@_KV?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,4,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,3,1> > >
PUBLIC	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$03$00@@_KV?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,3,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,4,1> > >
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$Assign@HH$0A@@?$Vector@M$02@@IEAAXHHH@Z	; Vector<float,3>::Assign<int,int,0>
PUBLIC	??$Assign@HHHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHHH@Z ; Vector<float,8>::Assign<int,int,int,int,int,int,int,0>
PUBLIC	??$Assign@V?$Vector@M$03@@$$V$0A@@?$Vector@M$07@@IEAAXHAEBV?$Vector@M$03@@@Z ; Vector<float,8>::Assign<Vector<float,4>,0>
PUBLIC	??$Assign@MMM$0A@@?$Vector@M$03@@IEAAXHMMM@Z	; Vector<float,4>::Assign<float,float,float,0>
PUBLIC	??$Assign@MM$0A@@?$Vector@M$02@@IEAAXHMM@Z	; Vector<float,3>::Assign<float,float,0>
PUBLIC	??0?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAA@XZ ; std::allocator<Matrix<float,2,2,1> >::allocator<Matrix<float,2,2,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAA@XZ ; std::allocator<Matrix<float,3,3,1> >::allocator<Matrix<float,3,3,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAA@XZ ; std::allocator<Matrix<float,4,4,1> >::allocator<Matrix<float,4,4,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAA@XZ ; std::allocator<Matrix<float,4,2,1> >::allocator<Matrix<float,4,2,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAA@XZ ; std::allocator<Matrix<float,2,4,1> >::allocator<Matrix<float,2,4,1> >
PUBLIC	?GetElement@?$MatrixData@M$03$02$00@@QEBAMHH@Z	; MatrixData<float,4,3,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$03$00@@QEBAMHH@Z	; MatrixData<float,3,4,1>::GetElement
PUBLIC	??0?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAA@XZ ; std::allocator<Matrix<float,4,3,1> >::allocator<Matrix<float,4,3,1> >
PUBLIC	??0?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAA@XZ ; std::allocator<Matrix<float,3,4,1> >::allocator<Matrix<float,3,4,1> >
PUBLIC	?Assign@?$Vector@M$02@@IEAAXH@Z			; Vector<float,3>::Assign
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??Y?$Vector@M$03@@QEAAAEAV0@AEBV0@@Z		; Vector<float,4>::operator+=
PUBLIC	?Assign@?$Vector@M$03@@IEAAXH@Z			; Vector<float,4>::Assign
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >
PUBLIC	??R?$Matrix@M$03$02$00@@QEBAMHH@Z		; Matrix<float,4,3,1>::operator()
PUBLIC	??R?$Matrix@M$02$03$00@@QEBAMHH@Z		; Matrix<float,3,4,1>::operator()
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >
PUBLIC	?Get@?$GetVectorElement@V?$Vector@M$03@@@?$Vector@M$07@@SAMAEBV?$Vector@M$03@@H@Z ; Vector<float,8>::GetVectorElement<Vector<float,4> >::Get
PUBLIC	?Get@?$GetVectorElement@V?$Vector@M$02@@@?$Vector@M$03@@SAMAEBV?$Vector@M$02@@H@Z ; Vector<float,4>::GetVectorElement<Vector<float,3> >::Get
PUBLIC	?Get@?$GetVectorElement@M@?$Vector@M$03@@SAMAEBMH@Z ; Vector<float,4>::GetVectorElement<float>::Get
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$01$01$00@@@std@@PEAV?$Matrix@M$01$01$00@@@std@@YAXPEAV?$Matrix@M$01$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Matrix<float,2,2,1> >,Matrix<float,2,2,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$02$02$00@@@std@@PEAV?$Matrix@M$02$02$00@@@std@@YAXPEAV?$Matrix@M$02$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Matrix<float,3,3,1> >,Matrix<float,3,3,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$03$03$00@@@std@@PEAV?$Matrix@M$03$03$00@@@std@@YAXPEAV?$Matrix@M$03$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Matrix<float,4,4,1> >,Matrix<float,4,4,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$03$01$00@@@std@@PEAV?$Matrix@M$03$01$00@@@std@@YAXPEAV?$Matrix@M$03$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Matrix<float,4,2,1> >,Matrix<float,4,2,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$01$03$00@@@std@@PEAV?$Matrix@M$01$03$00@@@std@@YAXPEAV?$Matrix@M$01$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Matrix<float,2,4,1> >,Matrix<float,2,4,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$03$02$00@@@std@@PEAV?$Matrix@M$03$02$00@@@std@@YAXPEAV?$Matrix@M$03$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Matrix<float,4,3,1> >,Matrix<float,4,3,1> * __ptr64>
PUBLIC	??$_Destroy_range@V?$allocator@V?$Matrix@M$02$03$00@@@std@@PEAV?$Matrix@M$02$03$00@@@std@@YAXPEAV?$Matrix@M$02$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Matrix<float,3,4,1> >,Matrix<float,3,4,1> * __ptr64>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1><>
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$01$01$00@@_KV?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Matrix<float,2,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,2,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$02$02$00@@_KV?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Matrix<float,3,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,3,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$03$00@@_KV?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Matrix<float,4,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,4,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$01$00@@_KV?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Matrix<float,4,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,2,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$01$03$00@@_KV?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Matrix<float,2,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,4,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$02$00@@_KV?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Matrix<float,4,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,3,1> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$02$03$00@@_KV?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Matrix<float,3,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,4,1> > >
PUBLIC	??$?DMM$02$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV?$Matrix@M$02$03$00@@AEBV?$Matrix@M$03$02$00@@@Z ; operator*<float,float,3,4,4,1,1,float,void>
PUBLIC	??$?DMM$03$02$02$00$00MX@@YA?AV?$Matrix@M$02$02$00@@AEBV?$Matrix@M$03$02$00@@AEBV?$Matrix@M$02$03$00@@@Z ; operator*<float,float,4,3,3,1,1,float,void>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?DMM$01$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV0@0@Z ; operator*<float,float,2,2,2,1,1,float,void>
PUBLIC	??$?HM$03@@YA?AV?$Vector@M$03@@AEBV0@0@Z	; operator+<float,4>
PUBLIC	??$Assign@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@IEAAXHAEBMAEBV?$Vector@M$02@@@Z ; Vector<float,4>::Assign<float,Vector<float,3>,0>
PUBLIC	??$Assign@HHH$0A@@?$Vector@M$02@@IEAAXHHHH@Z	; Vector<float,3>::Assign<int,int,int,0>
PUBLIC	??$Assign@V?$Vector@M$02@@$$V$0A@@?$Vector@M$03@@IEAAXHAEBV?$Vector@M$02@@@Z ; Vector<float,4>::Assign<Vector<float,3>,0>
PUBLIC	??$Assign@H$$V$0A@@?$Vector@M$02@@IEAAXHH@Z	; Vector<float,3>::Assign<int,0>
PUBLIC	??$Assign@HHHHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHHHH@Z ; Vector<float,8>::Assign<int,int,int,int,int,int,int,int,0>
PUBLIC	??$Assign@V?$Vector@M$03@@V1@$0A@@?$Vector@M$07@@IEAAXHAEBV?$Vector@M$03@@0@Z ; Vector<float,8>::Assign<Vector<float,4>,Vector<float,4>,0>
PUBLIC	??$Assign@MMMM$0A@@?$Vector@M$03@@IEAAXHMMMM@Z	; Vector<float,4>::Assign<float,float,float,float,0>
PUBLIC	??$Assign@MMM$0A@@?$Vector@M$02@@IEAAXHMMM@Z	; Vector<float,3>::Assign<float,float,float,0>
PUBLIC	?max_size@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEBA_KXZ ; std::allocator<Matrix<float,2,2,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEBA_KXZ ; std::allocator<Matrix<float,3,3,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEBA_KXZ ; std::allocator<Matrix<float,4,4,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEBA_KXZ ; std::allocator<Matrix<float,4,2,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEBA_KXZ ; std::allocator<Matrix<float,2,4,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEBA_KXZ ; std::allocator<Matrix<float,4,3,1> >::max_size
PUBLIC	?max_size@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEBA_KXZ ; std::allocator<Matrix<float,3,4,1> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$01$01$00@@@2@@Z ; std::allocator_traits<std::allocator<Matrix<float,2,2,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$02$02$00@@@2@@Z ; std::allocator_traits<std::allocator<Matrix<float,3,3,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$03$00@@@2@@Z ; std::allocator_traits<std::allocator<Matrix<float,4,4,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$01$00@@@2@@Z ; std::allocator_traits<std::allocator<Matrix<float,4,2,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$01$03$00@@@2@@Z ; std::allocator_traits<std::allocator<Matrix<float,2,4,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$02$00@@@2@@Z ; std::allocator_traits<std::allocator<Matrix<float,4,3,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$02$03$00@@@2@@Z ; std::allocator_traits<std::allocator<Matrix<float,3,4,1> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z ; std::allocator<Matrix<float,2,2,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z ; std::allocator<Matrix<float,2,2,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Get_second
PUBLIC	?_Reset@?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@IEAAXI@Z ; std::linear_congruential<unsigned int,48271,0,2147483647>::_Reset
PUBLIC	?_Init@param_type@?$uniform_real@M@std@@QEAAXMM@Z ; std::uniform_real<float>::param_type::_Init
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z ; std::allocator<Matrix<float,3,3,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z ; std::allocator<Matrix<float,3,3,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z ; std::allocator<Matrix<float,4,4,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z ; std::allocator<Matrix<float,4,4,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z ; std::allocator<Matrix<float,4,2,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z ; std::allocator<Matrix<float,4,2,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z ; std::allocator<Matrix<float,2,4,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z ; std::allocator<Matrix<float,2,4,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z ; std::allocator<Matrix<float,4,3,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z ; std::allocator<Matrix<float,4,3,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z ; std::allocator<Matrix<float,3,4,1> >::deallocate
PUBLIC	?allocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z ; std::allocator<Matrix<float,3,4,1> >::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Get_second
PUBLIC	??A?$Vector@M$02@@QEBAMH@Z			; Vector<float,3>::operator[]
PUBLIC	??A?$Vector@M$03@@QEBAMH@Z			; Vector<float,4>::operator[]
PUBLIC	??A?$Vector@M$01@@QEBAMH@Z			; Vector<float,2>::operator[]
PUBLIC	?max_size@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEBA_KXZ ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$01$01$00@@0@Z ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEBAXXZ ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Get_first
PUBLIC	?seed@?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAAXI@Z ; std::linear_congruential<unsigned int,48271,0,2147483647>::seed
PUBLIC	??0?$_Mul_mod@_KI$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z ; std::_Mul_mod<unsigned __int64,unsigned int,48271,0,2147483647>::_Mul_mod<unsigned __int64,unsigned int,48271,0,2147483647>
PUBLIC	??0param_type@?$uniform_real@M@std@@QEAA@MM@Z	; std::uniform_real<float>::param_type::param_type
PUBLIC	?max_size@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEBA_KXZ ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$02$02$00@@0@Z ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEBAXXZ ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Get_first
PUBLIC	?max_size@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEBA_KXZ ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$03$00@@0@Z ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEBAXXZ ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Get_first
PUBLIC	?max_size@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEBA_KXZ ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$01$00@@0@Z ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEBAXXZ ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Get_first
PUBLIC	?max_size@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEBA_KXZ ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$01$03$00@@0@Z ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEBAXXZ ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Get_first
PUBLIC	?max_size@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEBA_KXZ ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$02$00@@0@Z ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEBAXXZ ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Get_first
PUBLIC	?max_size@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEBA_KXZ ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$02$03$00@@0@Z ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Destroy
PUBLIC	?_Xlen@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEBAXXZ ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAXXZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Get_first
PUBLIC	?zero@?$duration_values@_J@chrono@std@@SA_JXZ	; std::chrono::duration_values<__int64>::zero
PUBLIC	?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero
PUBLIC	?GetElement@?$MatrixData@M$03$03$00@@QEBAMHH@Z	; MatrixData<float,4,4,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$02$00@@QEBAMHH@Z	; MatrixData<float,3,3,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$03$01$00@@QEBAMHH@Z	; MatrixData<float,4,2,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$01$03$00@@QEBAMHH@Z	; MatrixData<float,2,4,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$01$01$00@@QEAAAEAMHH@Z ; MatrixData<float,2,2,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$01$01$00@@QEBAMHH@Z	; MatrixData<float,2,2,1>::GetElement
PUBLIC	?_Buy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAA_N_K@Z ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXXZ ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Mylast
PUBLIC	??0?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z ; std::linear_congruential<unsigned int,48271,0,2147483647>::linear_congruential<unsigned int,48271,0,2147483647>
PUBLIC	??0?$uniform_real@M@std@@QEAA@MM@Z		; std::uniform_real<float>::uniform_real<float>
PUBLIC	?_Buy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAA_N_K@Z ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXXZ ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Mylast
PUBLIC	?_Buy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAA_N_K@Z ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXXZ ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Mylast
PUBLIC	?_Buy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAA_N_K@Z ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXXZ ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Mylast
PUBLIC	?_Buy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAA_N_K@Z ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXXZ ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Mylast
PUBLIC	?GetElement@?$MatrixData@M$03$02$00@@QEAAAEAMHH@Z ; MatrixData<float,4,3,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$03$00@@QEAAAEAMHH@Z ; MatrixData<float,3,4,1>::GetElement
PUBLIC	?_Buy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAA_N_K@Z ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXXZ ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Mylast
PUBLIC	?_Buy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAA_N_K@Z ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Buy
PUBLIC	?_Tidy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXXZ ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Mylast
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??0?$linear_congruential_engine@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z ; std::linear_congruential_engine<unsigned int,48271,0,2147483647>::linear_congruential_engine<unsigned int,48271,0,2147483647>
PUBLIC	??R?$Vector@M$03@@QEBAMH@Z			; Vector<float,4>::operator()
PUBLIC	??X?$Vector@M$03@@QEAAAEAV0@AEBV0@@Z		; Vector<float,4>::operator*=
PUBLIC	??R?$Matrix@M$02$02$00@@QEBAMHH@Z		; Matrix<float,3,3,1>::operator()
PUBLIC	??R?$Matrix@M$03$03$00@@QEBAMHH@Z		; Matrix<float,4,4,1>::operator()
PUBLIC	?Width@?$MatrixData@M$03$03$00@@QEBAHXZ		; MatrixData<float,4,4,1>::Width
PUBLIC	?Height@?$MatrixData@M$03$03$00@@QEBAHXZ	; MatrixData<float,4,4,1>::Height
PUBLIC	?Width@?$MatrixData@M$02$02$00@@QEBAHXZ		; MatrixData<float,3,3,1>::Width
PUBLIC	?Height@?$MatrixData@M$02$02$00@@QEBAHXZ	; MatrixData<float,3,3,1>::Height
PUBLIC	??R?$Matrix@M$03$01$00@@QEBAMHH@Z		; Matrix<float,4,2,1>::operator()
PUBLIC	?Width@?$MatrixData@M$03$01$00@@QEBAHXZ		; MatrixData<float,4,2,1>::Width
PUBLIC	?Height@?$MatrixData@M$03$01$00@@QEBAHXZ	; MatrixData<float,4,2,1>::Height
PUBLIC	??R?$Matrix@M$01$03$00@@QEBAMHH@Z		; Matrix<float,2,4,1>::operator()
PUBLIC	?Width@?$MatrixData@M$01$03$00@@QEBAHXZ		; MatrixData<float,2,4,1>::Width
PUBLIC	?Height@?$MatrixData@M$01$03$00@@QEBAHXZ	; MatrixData<float,2,4,1>::Height
PUBLIC	?add@?$VectorSpec@M$01@@IEAAXAEBV1@@Z		; VectorSpec<float,2>::add
PUBLIC	?mul@?$VectorSpec@M$01@@IEAAXM@Z		; VectorSpec<float,2>::mul
PUBLIC	??R?$Matrix@M$01$01$00@@QEAAAEAMHH@Z		; Matrix<float,2,2,1>::operator()
PUBLIC	??R?$Matrix@M$01$01$00@@QEBAMHH@Z		; Matrix<float,2,2,1>::operator()
PUBLIC	?Width@?$MatrixData@M$01$01$00@@QEBAHXZ		; MatrixData<float,2,2,1>::Width
PUBLIC	?Height@?$MatrixData@M$01$01$00@@QEBAHXZ	; MatrixData<float,2,2,1>::Height
PUBLIC	??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::~vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAAEAV?$Matrix@M$01$01$00@@_K@Z ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::operator[]
PUBLIC	??0?$uniform_real_distribution@M@std@@QEAA@MM@Z	; std::uniform_real_distribution<float>::uniform_real_distribution<float>
PUBLIC	??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::~vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAAEAV?$Matrix@M$02$02$00@@_K@Z ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::operator[]
PUBLIC	??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::~vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$03$00@@_K@Z ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::operator[]
PUBLIC	??0?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::~vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$01$00@@_K@Z ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::operator[]
PUBLIC	??0?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::~vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$01$03$00@@_K@Z ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::operator[]
PUBLIC	??R?$Matrix@M$03$02$00@@QEAAAEAMHH@Z		; Matrix<float,4,3,1>::operator()
PUBLIC	??R?$Matrix@M$02$03$00@@QEAAAEAMHH@Z		; Matrix<float,3,4,1>::operator()
PUBLIC	??0?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::~vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$02$00@@_K@Z ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::operator[]
PUBLIC	??0?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >
PUBLIC	??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::~vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >
PUBLIC	??A?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$02$03$00@@_K@Z ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::operator[]
PUBLIC	??$MatMulSpeedTest@M$02$03$03$02@@YANXZ		; MatMulSpeedTest<float,3,4,4,3>
PUBLIC	??$MatMulSpeedTest@M$03$02$02$03@@YANXZ		; MatMulSpeedTest<float,4,3,3,4>
PUBLIC	??$MatMulSpeedTest@M$01$03$03$01@@YANXZ		; MatMulSpeedTest<float,2,4,4,2>
PUBLIC	??$MatMulSpeedTest@M$03$01$01$03@@YANXZ		; MatMulSpeedTest<float,4,2,2,4>
PUBLIC	??$MatMulSpeedTest@M$03$03$03$03@@YANXZ		; MatMulSpeedTest<float,4,4,4,4>
PUBLIC	??$MatMulSpeedTest@M$02$02$02$02@@YANXZ		; MatMulSpeedTest<float,3,3,3,3>
PUBLIC	??$MatMulSpeedTest@M$01$01$01$01@@YANXZ		; MatMulSpeedTest<float,2,2,2,2>
PUBLIC	??$?DMM$01$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV?$Matrix@M$01$03$00@@AEBV?$Matrix@M$03$01$00@@@Z ; operator*<float,float,2,4,4,1,1,float,void>
PUBLIC	??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@@@Z ; operator<<<float,2,2,1>
PUBLIC	??$?DMM$03$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV?$Matrix@M$03$01$00@@AEBV?$Matrix@M$01$03$00@@@Z ; operator*<float,float,4,2,2,1,1,float,void>
PUBLIC	??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@@@Z ; operator<<<float,2,4,1>
PUBLIC	??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@@@Z ; operator<<<float,4,2,1>
PUBLIC	??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@@@Z ; operator<<<float,3,3,1>
PUBLIC	??$?DMM$02$02$02$00$00MX@@YA?AV?$Matrix@M$02$02$00@@AEBV0@0@Z ; operator*<float,float,3,3,3,1,1,float,void>
PUBLIC	??$?HMM$03$03$00$00M@@YA?AV?$Matrix@M$03$03$00@@AEBV0@0@Z ; operator+<float,float,4,4,1,1,float>
PUBLIC	??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@@@Z ; operator<<<float,4,4,1>
PUBLIC	??$?DMM$03$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV0@0@Z ; operator*<float,float,4,4,4,1,1,float,void>
PUBLIC	??$Set@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@QEAAAEAV0@AEBMAEBV?$Vector@M$02@@@Z ; Vector<float,4>::Set<float,Vector<float,3>,0>
PUBLIC	??$Set@HHH$0A@@?$Vector@M$02@@QEAAAEAV0@HHH@Z	; Vector<float,3>::Set<int,int,int,0>
PUBLIC	??$?0V?$Vector@M$02@@$0A@@?$Vector@M$03@@QEAA@AEBV?$Vector@M$02@@@Z ; Vector<float,4>::Vector<float,4><Vector<float,3>,0>
PUBLIC	??$?0H$0A@@?$Vector@M$02@@QEAA@H@Z		; Vector<float,3>::Vector<float,3><int,0>
PUBLIC	??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@@@Z ; operator<<<float,4>
PUBLIC	??$Set@V?$Vector@M$03@@V1@$0A@@?$Vector@M$07@@QEAAAEAV0@AEBV?$Vector@M$03@@0@Z ; Vector<float,8>::Set<Vector<float,4>,Vector<float,4>,0>
PUBLIC	??$Set@HHHHHHHH$0A@@?$Vector@M$07@@QEAAAEAV0@HHHHHHHH@Z ; Vector<float,8>::Set<int,int,int,int,int,int,int,int,0>
PUBLIC	??$?0V?$Vector@M$03@@V0@$0A@@?$Vector@M$07@@QEAA@AEBV?$Vector@M$03@@0@Z ; Vector<float,8>::Vector<float,8><Vector<float,4>,Vector<float,4>,0>
PUBLIC	??$?DM$03@@YA?AV?$Vector@M$03@@AEBV0@0@Z	; operator*<float,4>
PUBLIC	??$?0MMMM$0A@@?$Vector@M$03@@QEAA@MMMM@Z	; Vector<float,4>::Vector<float,4><float,float,float,float,0>
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	??$?0MMM$0A@@?$Vector@M$02@@QEAA@MMM@Z		; Vector<float,3>::Vector<float,3><float,float,float,0>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??A?$Vector@M$02@@QEAAAEAMH@Z			; Vector<float,3>::operator[]
PUBLIC	??A?$Vector@M$03@@QEAAAEAMH@Z			; Vector<float,4>::operator[]
PUBLIC	??A?$Vector@M$01@@QEAAAEAMH@Z			; Vector<float,2>::operator[]
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?GetElement@?$MatrixData@M$03$03$00@@QEAAAEAMHH@Z ; MatrixData<float,4,4,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$02$02$00@@QEAAAEAMHH@Z ; MatrixData<float,3,3,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$03$01$00@@QEAAAEAMHH@Z ; MatrixData<float,4,2,1>::GetElement
PUBLIC	?GetElement@?$MatrixData@M$01$03$00@@QEAAAEAMHH@Z ; MatrixData<float,2,4,1>::GetElement
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??R?$Matrix@M$02$02$00@@QEAAAEAMHH@Z		; Matrix<float,3,3,1>::operator()
PUBLIC	??R?$Matrix@M$03$03$00@@QEAAAEAMHH@Z		; Matrix<float,4,4,1>::operator()
PUBLIC	??R?$Matrix@M$03$01$00@@QEAAAEAMHH@Z		; Matrix<float,4,2,1>::operator()
PUBLIC	??R?$Matrix@M$01$03$00@@QEAAAEAMHH@Z		; Matrix<float,2,4,1>::operator()
PUBLIC	main
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?Cross@?$VectorSpec@M$02@@SA?AV?$Vector@M$02@@AEBV2@0@Z ; VectorSpec<float,3>::Cross
PUBLIC	?mul@?$VectorSpec@M$03@@IEAAXM@Z		; VectorSpec<float,4>::mul
PUBLIC	?add@?$VectorSpec@M$03@@IEAAXAEBV1@@Z		; VectorSpec<float,4>::add
PUBLIC	?mul@?$VectorSpec@M$03@@IEAAXAEBV1@@Z		; VectorSpec<float,4>::mul
PUBLIC	?mul@?$VectorSpec@M$02@@IEAAXM@Z		; VectorSpec<float,3>::mul
PUBLIC	?add@?$VectorSpec@M$02@@IEAAXAEBV1@@Z		; VectorSpec<float,3>::add
PUBLIC	?mul@Simd4f@@SA?AT1@AEBT1@M@Z			; Simd4f::mul
PUBLIC	?add@Simd4f@@SA?AT1@AEBT1@0@Z			; Simd4f::add
PUBLIC	?mul@Simd4f@@SA?AT1@AEBT1@0@Z			; Simd4f::mul
PUBLIC	?_Deallocate@std@@YAXPEAX_K1@Z			; std::_Deallocate
PUBLIC	?_Allocate@std@@YAPEAX_K0_N@Z			; std::_Allocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?length@?$char_traits@D@std@@SA_KPEBD@Z		; std::char_traits<char>::length
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	__real@3e112e0be826d695
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@40e00000
PUBLIC	__real@41000000
PUBLIC	__real@41100000
PUBLIC	__xmm@4040000040400000400000003f800000
PUBLIC	__xmm@40400000404000004080000040a00000
PUBLIC	__xmm@4080000040400000400000003f800000
PUBLIC	__xmm@408000004080000040a0000040c00000
PUBLIC	__xmm@40a0000040a0000040c0000040e00000
PUBLIC	__xmm@40c000004000000040a000003f800000
PUBLIC	__xmm@40c0000040c0000040a0000040800000
PUBLIC	__xmm@410000004080000040e0000040400000
PUBLIC	__xmm@4100000040e0000040c0000040a00000
PUBLIC	__xmm@41100000411000004100000040e00000
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH:PROC
EXTRN	__std_terminate:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+114
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+114
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+34
	DD	imagerel $unwind$?allocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+111
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+114
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+111
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+111
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+111
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+114
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+34
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+111
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123
	DD	imagerel $LN123+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXXZ DD imagerel $LN108
	DD	imagerel $LN108+146
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123
	DD	imagerel $LN123+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXXZ DD imagerel $LN108
	DD	imagerel $LN108+177
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123
	DD	imagerel $LN123+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXXZ DD imagerel $LN108
	DD	imagerel $LN108+146
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123
	DD	imagerel $LN123+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXXZ DD imagerel $LN108
	DD	imagerel $LN108+146
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123
	DD	imagerel $LN123+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXXZ DD imagerel $LN108
	DD	imagerel $LN108+146
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123
	DD	imagerel $LN123+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXXZ DD imagerel $LN108
	DD	imagerel $LN108+177
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAA_N_K@Z DD imagerel $LN123
	DD	imagerel $LN123+72
	DD	imagerel $unwind$?_Buy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXXZ DD imagerel $LN108
	DD	imagerel $LN108+146
	DD	imagerel $unwind$?_Tidy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z DD imagerel $LN270
	DD	imagerel $LN270+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ DD imagerel $LN111
	DD	imagerel $LN111+146
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z DD imagerel $LN165
	DD	imagerel $LN165+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ DD imagerel $LN111
	DD	imagerel $LN111+177
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z DD imagerel $LN270
	DD	imagerel $LN270+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ DD imagerel $LN111
	DD	imagerel $LN111+146
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@_K@Z DD imagerel $LN270
	DD	imagerel $LN270+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ DD imagerel $LN111
	DD	imagerel $LN111+146
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@_K@Z DD imagerel $LN270
	DD	imagerel $LN270+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ DD imagerel $LN111
	DD	imagerel $LN111+146
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@_K@Z DD imagerel $LN165
	DD	imagerel $LN165+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ DD imagerel $LN111
	DD	imagerel $LN111+177
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@_K@Z DD imagerel $LN270
	DD	imagerel $LN270+89
	DD	imagerel $unwind$??0?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ DD imagerel $LN111
	DD	imagerel $LN111+146
	DD	imagerel $unwind$??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ DD imagerel $LN598
	DD	imagerel $LN598+1083
	DD	imagerel $unwind$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ DD imagerel $LN598
	DD	imagerel $LN598+1106
	DD	imagerel $unwind$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ DD imagerel $LN597
	DD	imagerel $LN597+980
	DD	imagerel $unwind$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ DD imagerel $LN550
	DD	imagerel $LN550+844
	DD	imagerel $unwind$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ DD imagerel $LN601
	DD	imagerel $LN601+1080
	DD	imagerel $unwind$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ DD imagerel $LN595
	DD	imagerel $LN595+1120
	DD	imagerel $unwind$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ DD imagerel $LN591
	DD	imagerel $LN591+956
	DD	imagerel $unwind$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@@@Z DD imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?DMM$03$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV?$Matrix@M$03$01$00@@AEBV?$Matrix@M$01$03$00@@@Z DD imagerel $LN62
	DD	imagerel $LN62+379
	DD	imagerel $unwind$??$?DMM$03$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV?$Matrix@M$03$01$00@@AEBV?$Matrix@M$01$03$00@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@@@Z DD imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@@@Z DD imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@@@Z DD imagerel $LN30
	DD	imagerel $LN30+187
	DD	imagerel $unwind$??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@@@Z DD imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@@@Z DD imagerel $LN13
	DD	imagerel $LN13+158
	DD	imagerel $unwind$??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN114
	DD	imagerel $LN114+455
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+56
	DD	imagerel $unwind$?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+45
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN26
	DD	imagerel $LN26+124
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+72
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN953
	DD	imagerel $LN953+2132
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD imagerel $LN8
	DD	imagerel $LN8+75
	DD	imagerel $unwind$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate@std@@YAXPEAX_K1@Z DD imagerel $LN11
	DD	imagerel $LN11+110
	DD	imagerel $unwind$?_Deallocate@std@@YAXPEAX_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@std@@YAPEAX_K0_N@Z DD imagerel $LN12
	DD	imagerel $LN12+104
	DD	imagerel $unwind$?_Allocate@std@@YAPEAX_K0_N@Z
pdata	ENDS
;	COMDAT __xmm@41100000411000004100000040e00000
CONST	SEGMENT
__xmm@41100000411000004100000040e00000 DB 00H, 00H, 0e0H, '@', 00H, 00H, 00H
	DB	'A', 00H, 00H, 010H, 'A', 00H, 00H, 010H, 'A'
CONST	ENDS
;	COMDAT __xmm@4100000040e0000040c0000040a00000
CONST	SEGMENT
__xmm@4100000040e0000040c0000040a00000 DB 00H, 00H, 0a0H, '@', 00H, 00H, 0c0H
	DB	'@', 00H, 00H, 0e0H, '@', 00H, 00H, 00H, 'A'
CONST	ENDS
;	COMDAT __xmm@410000004080000040e0000040400000
CONST	SEGMENT
__xmm@410000004080000040e0000040400000 DB 00H, 00H, '@@', 00H, 00H, 0e0H, '@'
	DB	00H, 00H, 080H, '@', 00H, 00H, 00H, 'A'
CONST	ENDS
;	COMDAT __xmm@40c0000040c0000040a0000040800000
CONST	SEGMENT
__xmm@40c0000040c0000040a0000040800000 DB 00H, 00H, 080H, '@', 00H, 00H, 0a0H
	DB	'@', 00H, 00H, 0c0H, '@', 00H, 00H, 0c0H, '@'
CONST	ENDS
;	COMDAT __xmm@40c000004000000040a000003f800000
CONST	SEGMENT
__xmm@40c000004000000040a000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 0a0H
	DB	'@', 00H, 00H, 00H, '@', 00H, 00H, 0c0H, '@'
CONST	ENDS
;	COMDAT __xmm@40a0000040a0000040c0000040e00000
CONST	SEGMENT
__xmm@40a0000040a0000040c0000040e00000 DB 00H, 00H, 0e0H, '@', 00H, 00H, 0c0H
	DB	'@', 00H, 00H, 0a0H, '@', 00H, 00H, 0a0H, '@'
CONST	ENDS
;	COMDAT __xmm@408000004080000040a0000040c00000
CONST	SEGMENT
__xmm@408000004080000040a0000040c00000 DB 00H, 00H, 0c0H, '@', 00H, 00H, 0a0H
	DB	'@', 00H, 00H, 080H, '@', 00H, 00H, 080H, '@'
CONST	ENDS
;	COMDAT __xmm@4080000040400000400000003f800000
CONST	SEGMENT
__xmm@4080000040400000400000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	'@', 00H, 00H, '@@', 00H, 00H, 080H, '@'
CONST	ENDS
;	COMDAT __xmm@40400000404000004080000040a00000
CONST	SEGMENT
__xmm@40400000404000004080000040a00000 DB 00H, 00H, 0a0H, '@', 00H, 00H, 080H
	DB	'@', 00H, 00H, '@@', 00H, 00H, '@@'
CONST	ENDS
;	COMDAT __xmm@4040000040400000400000003f800000
CONST	SEGMENT
__xmm@4040000040400000400000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	'@', 00H, 00H, '@@', 00H, 00H, '@@'
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e112e0be826d695
CONST	SEGMENT
__real@3e112e0be826d695 DQ 03e112e0be826d695r	; 1e-09
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@std@@YAPEAX_K0_N@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate@std@@YAXPEAX_K1@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	0154319H
	DD	0109835H
	DD	0118830H
	DD	012782bH
	DD	0136827H
	DD	02fc423H
	DD	02e7423H
	DD	02d6423H
	DD	02c3423H
	DD	0280123H
	DD	0e016f018H
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+39
	DD	00H
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+66
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	0ffffffffH
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+57
	DD	00H
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+110
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0ffffffffH
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+127
	DD	00H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+181
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+195
	DD	02H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+348
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+386
	DD	04H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+406
	DD	05H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+431
	DD	0ffffffffH
	DD	imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	00H
	DD	imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
	DD	04H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	01H
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0bH
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 082219H
	DD	0103422H
	DD	0f00d7211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@@@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@@@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@@@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@@@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@@@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?DMM$03$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV?$Matrix@M$03$01$00@@AEBV?$Matrix@M$01$03$00@@@Z DD 010501H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@@@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ DD imagerel ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ+67
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ+77
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ+688
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ+798
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ DD 0d3919H
	DD	0a682bH
	DD	01c7427H
	DD	01b6423H
	DD	01a341fH
	DD	0160113H
	DD	0e006f008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
	DD	092H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ DD imagerel ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ+73
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ+84
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ+802
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ+933
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ DD 0f3e19H
	DD	0c682cH
	DD	0226428H
	DD	0215424H
	DD	0203420H
	DD	01a0113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	07004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
	DD	0b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ DD imagerel ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ+73
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ+84
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ+802
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ+913
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ DD 0f3e19H
	DD	0d682cH
	DD	0246428H
	DD	0235424H
	DD	0223420H
	DD	01c0113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	07004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ DD imagerel ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ+70
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ+81
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ+559
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ+680
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ DD 0d3b19H
	DD	096829H
	DD	0197425H
	DD	0186421H
	DD	017541dH
	DD	0163419H
	DD	014010cH
	DD	0e005H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
	DD	082H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ DD imagerel ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ+70
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ+81
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ+695
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ+816
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ DD 0d3b19H
	DD	0c6829H
	DD	01f7425H
	DD	01e6421H
	DD	01d541dH
	DD	01c3419H
	DD	01a010cH
	DD	0e005H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
	DD	0b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ DD imagerel ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ+73
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ+84
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ+794
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ+918
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ DD 0f3e19H
	DD	0d682cH
	DD	0246428H
	DD	0235424H
	DD	0223420H
	DD	01c0113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	07004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ DD imagerel ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
	DD	0ffffffffH
	DD	imagerel ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ+73
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ+84
	DD	01H
	DD	imagerel ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ+760
	DD	00H
	DD	imagerel ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ+915
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ DD 0f3e19H
	DD	0e682cH
	DD	0266428H
	DD	0255424H
	DD	0243420H
	DD	01e0113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	07004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
	DD	0d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAA_N_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$dead$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 88   :         (void)_Size;
; 89   :         return _Where;

	mov	rax, rdx

; 90   :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SA_KPEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$char_traits@D@std@@SA_KPEBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [rcx], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	ret	0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

	or	rax, -1
	npad	4
$LL5@length:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL5@length

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	ret	0
?length@?$char_traits@D@std@@SA_KPEBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 594  : 		{	// test for metacharacter equality

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	sete	al

; 595  : 		return (_Left == _Right);
; 596  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 606  : 		return (EOF);

	or	eax, -1

; 607  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 44   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPEAX_K0_N@Z
_TEXT	SEGMENT
_Count$dead$ = 48
_Sz$ = 56
_Try_aligned_allocation$dead$ = 64
?_Allocate@std@@YAPEAX_K0_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

$LN12:
	sub	rsp, 40					; 00000028H
	mov	r8, rdx

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)
; 52   : 		return (_Ptr);
; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	or	rax, -1
	xor	edx, edx
	div	r8
	cmp	rax, 100000				; 000186a0H
	jae	SHORT $LN3@Allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN3@Allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	imul	rcx, r8, 100000				; 000186a0H

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	rax, QWORD PTR [rcx+39]

; 66   : 		if (_Block_size <= _User_size)

	cmp	rax, rcx
	ja	SHORT $LN6@Allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN6@Allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 85   : 		}
; 86   : 	return (_Ptr);

	mov	rax, rcx

; 87   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 87   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN11@Allocate:
?_Allocate@std@@YAPEAX_K0_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPEAX_K1@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Count$ = 56
_Sz$ = 64
?_Deallocate@std@@YAXPEAX_K1@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

$LN11:
	sub	rsp, 40					; 00000028H
	mov	r9, rdx

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	rax, -1
	xor	edx, edx
	div	r8
	cmp	r9, rax
	jbe	SHORT $LN2@Deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2@Deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	imul	r9, r8

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r9, 4096				; 00001000H
	jb	SHORT $LN3@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN4@Deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@Deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN5@Deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN6@Deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@Deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN7@Deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN3@Deallocate:

; 133  : 	}

	add	rsp, 40					; 00000028H

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN10@Deallocate:
?_Deallocate@std@@YAXPEAX_K1@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
;	COMDAT ?mul@Simd4f@@SA?AT1@AEBT1@0@Z
_TEXT	SEGMENT
$T2 = 8
lhs$ = 16
rhs$ = 24
?mul@Simd4f@@SA?AT1@AEBT1@0@Z PROC			; Simd4f::mul, COMDAT

; 12   : 		Simd4f res;
; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rdx]

; 14   : 		return res;

	mov	rax, rcx
	mulps	xmm0, XMMWORD PTR [r8]
	movaps	XMMWORD PTR [rcx], xmm0

; 15   : 	}

	ret	0
?mul@Simd4f@@SA?AT1@AEBT1@0@Z ENDP			; Simd4f::mul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
;	COMDAT ?add@Simd4f@@SA?AT1@AEBT1@0@Z
_TEXT	SEGMENT
$T2 = 8
lhs$ = 16
rhs$ = 24
?add@Simd4f@@SA?AT1@AEBT1@0@Z PROC			; Simd4f::add, COMDAT

; 24   : 		Simd4f res;
; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rdx]

; 26   : 		return res;

	mov	rax, rcx
	addps	xmm0, XMMWORD PTR [r8]
	movaps	XMMWORD PTR [rcx], xmm0

; 27   : 	}

	ret	0
?add@Simd4f@@SA?AT1@AEBT1@0@Z ENDP			; Simd4f::add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
;	COMDAT ?mul@Simd4f@@SA?AT1@AEBT1@M@Z
_TEXT	SEGMENT
$T3 = 8
lhs$ = 16
rhs$ = 24
?mul@Simd4f@@SA?AT1@AEBT1@M@Z PROC			; Simd4f::mul, COMDAT

; 36   : 		Simd4f res;
; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movaps	xmm0, xmm2

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);
; 39   : 		return res;

	mov	rax, rcx
	shufps	xmm0, xmm0, 0
	mulps	xmm0, XMMWORD PTR [rdx]
	movaps	XMMWORD PTR [rcx], xmm0

; 40   : 	}

	ret	0
?mul@Simd4f@@SA?AT1@AEBT1@M@Z ENDP			; Simd4f::mul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?add@?$VectorSpec@M$02@@IEAAXAEBV1@@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
?add@?$VectorSpec@M$02@@IEAAXAEBV1@@Z PROC		; VectorSpec<float,3>::add, COMDAT
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rdx]
	addps	xmm0, XMMWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\vector.hpp

; 404  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rcx], xmm0

; 405  : 	}

	ret	0
?add@?$VectorSpec@M$02@@IEAAXAEBV1@@Z ENDP		; VectorSpec<float,3>::add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?mul@?$VectorSpec@M$02@@IEAAXM@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
?mul@?$VectorSpec@M$02@@IEAAXM@Z PROC			; VectorSpec<float,3>::mul, COMDAT
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, XMMWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\vector.hpp

; 412  : 		simd = Simd4f::mul(simd, rhs);

	movaps	XMMWORD PTR [rcx], xmm0

; 413  : 	}

	ret	0
?mul@?$VectorSpec@M$02@@IEAAXM@Z ENDP			; VectorSpec<float,3>::mul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?mul@?$VectorSpec@M$03@@IEAAXAEBV1@@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
?mul@?$VectorSpec@M$03@@IEAAXAEBV1@@Z PROC		; VectorSpec<float,4>::mul, COMDAT
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rdx]
	mulps	xmm0, XMMWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\vector.hpp

; 458  : 		simd = Simd4f::mul(simd, rhs.simd);

	movaps	XMMWORD PTR [rcx], xmm0

; 459  : 	}

	ret	0
?mul@?$VectorSpec@M$03@@IEAAXAEBV1@@Z ENDP		; VectorSpec<float,4>::mul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?add@?$VectorSpec@M$03@@IEAAXAEBV1@@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
?add@?$VectorSpec@M$03@@IEAAXAEBV1@@Z PROC		; VectorSpec<float,4>::add, COMDAT
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rdx]
	addps	xmm0, XMMWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rcx], xmm0

; 465  : 	}

	ret	0
?add@?$VectorSpec@M$03@@IEAAXAEBV1@@Z ENDP		; VectorSpec<float,4>::add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?mul@?$VectorSpec@M$03@@IEAAXM@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
?mul@?$VectorSpec@M$03@@IEAAXM@Z PROC			; VectorSpec<float,4>::mul, COMDAT
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, XMMWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\vector.hpp

; 472  : 		simd = Simd4f::mul(simd, rhs);

	movaps	XMMWORD PTR [rcx], xmm0

; 473  : 	}

	ret	0
?mul@?$VectorSpec@M$03@@IEAAXM@Z ENDP			; VectorSpec<float,4>::mul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Cross@?$VectorSpec@M$02@@SA?AV?$Vector@M$02@@AEBV2@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
?Cross@?$VectorSpec@M$02@@SA?AV?$Vector@M$02@@AEBV2@0@Z PROC ; VectorSpec<float,3>::Cross, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 973  : 	return Vector<float, 3>(lhs.y * rhs.z - lhs.z * rhs.y,

	mov	rax, rcx

; 974  : 							lhs.z * rhs.x - lhs.x * rhs.z,
; 975  : 							lhs.x * rhs.y - lhs.y * rhs.x);
; 976  : }

	ret	0
?Cross@?$VectorSpec@M$02@@SA?AV?$Vector@M$02@@AEBV2@0@Z ENDP ; VectorSpec<float,3>::Cross
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 48
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT

; 998  : 		{	// get current time

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	cdq
	idiv	rbx
	mov	r8, rax
	imul	rax, rdx, 1000000000			; 3b9aca00H
	imul	rcx, r8, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1005 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rax, rcx

; 243  : 		: _MyDur(_Other)

	mov	QWORD PTR [rdi], rax

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	mov	rax, rdi

; 1005 : 		}

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
;	COMDAT main
_TEXT	SEGMENT
scalarMultiplier$62 = 32
v3$ = 32
mat7$ = 48
$T46 = 48
mat4$ = 48
$T30 = 48
$T17 = 48
mat8$ = 112
mat3$ = 112
mat2$ = 112
$T53 = 176
$T36 = 176
mat1$ = 176
__$ArrayPad$ = 240
main	PROC						; COMDAT

; 132  : int main() {

$LN953:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax+32], r12
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-88]
	sub	rsp, 320				; 00000140H
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8
	movaps	XMMWORD PTR [rax-88], xmm9
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 133  : 	Vector<float, 4> v1{ 1.f, 2.f, 3.f, 4.f };
; 134  : 	Vector<float, 4> v2{ 2.f, 3.f, 4.f, 5.f };
; 135  : 	Vector<float, 4> v3 = v1*v2;
; 136  : 
; 137  : 	Vector<float, 8> v4(v2, v3);
; 138  : 	v4.Set(1, 2, 3, 4, 5, 6, 7, 8);
; 139  : 	v4.Set(v3, v2);
; 140  : 
; 141  : 	cout << v3 << endl << endl;

	mov	r15, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A

; 25   : 	os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967198
	xorps	xmm1, xmm1
	xorps	xmm0, xmm0
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\main.cpp

; 25   : 	os << "{";

	mov	rcx, r15
; File c:\home\programming\mathter\mathter\vector.hpp

; 458  : 		simd = Simd4f::mul(simd, rhs.simd);

	movaps	XMMWORD PTR v3$[rsp], xmm1
; File c:\home\programming\mathter\main.cpp

; 25   : 	os << "{";

	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 26   : 	for (int x = 0; x < D; ++x) {

	xor	edi, edi
	lea	r12, OFFSET FLAT:$SG4294967197
	mov	r14d, edi
	mov	esi, edi
	npad	11
$LL109@main:

; 27   : 		os << v(x) << (x == D - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR v3$[rsp+rsi*4]
	lea	rbx, OFFSET FLAT:$SG4294967196
	cmp	r14d, 3
	mov	rcx, r15
	cmove	rbx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	r14d
	inc	rsi
	cmp	rsi, 4
	jl	SHORT $LL109@main

; 28   : 	}
; 29   : 	os << "}";

	lea	rdx, OFFSET FLAT:$SG4294967195
	mov	rcx, r15
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 133  : 	Vector<float, 4> v1{ 1.f, 2.f, 3.f, 4.f };
; 134  : 	Vector<float, 4> v2{ 2.f, 3.f, 4.f, 5.f };
; 135  : 	Vector<float, 4> v3 = v1*v2;
; 136  : 
; 137  : 	Vector<float, 8> v4(v2, v3);
; 138  : 	v4.Set(1, 2, 3, 4, 5, 6, 7, 8);
; 139  : 	v4.Set(v3, v2);
; 140  : 
; 141  : 	cout << v3 << endl << endl;

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, r15
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	movaps	xmm0, XMMWORD PTR __xmm@4040000040400000400000003f800000
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	mov	rax, rdi
	movaps	xmm1, XMMWORD PTR __xmm@40c0000040c0000040a0000040800000
	movaps	xmm2, XMMWORD PTR __xmm@40400000404000004080000040a00000
	movaps	XMMWORD PTR mat1$[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@41100000411000004100000040e00000
	movaps	XMMWORD PTR mat1$[rbp-240], xmm1
	movaps	xmm1, xmm0
	movaps	xmm1, XMMWORD PTR __xmm@40a0000040a0000040c0000040e00000
	movaps	XMMWORD PTR mat1$[rbp-224], xmm0
	movaps	XMMWORD PTR mat1$[rbp-208], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@408000004080000040a0000040c00000
	movaps	XMMWORD PTR mat2$[rbp-240], xmm0
	movaps	xmm0, xmm1
	movaps	XMMWORD PTR mat2$[rbp-224], xmm1
	movaps	XMMWORD PTR mat2$[rbp-208], xmm1
	movaps	XMMWORD PTR mat2$[rsp], xmm2
	npad	8
$LL393@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR mat1$[rbp+rax-256]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR $T17[rsp+rax], xmm0
	add	rax, 16

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	cmp	rax, 64					; 00000040H
	jl	SHORT $LL393@main

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	mov	ebx, 4
	lea	r9, QWORD PTR mat1$[rbp-252]
	lea	r8, QWORD PTR mat2$[rbp-240]
	lea	r10d, QWORD PTR [rbx-1]
	npad	3
$LL396@main:

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T17[rsp]
	mov	rcx, r9
	mov	rdx, rbx
	npad	5
$LL399@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL399@main

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	add	r8, 16
	add	r9, rbx
	sub	r10, 1
	jne	SHORT $LL396@main
; File c:\home\programming\mathter\main.cpp

; 170  : 	cout << mat1 * mat2 << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, QWORD PTR $T17[rsp]
	call	??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@@@Z ; operator<<<float,4,4,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File c:\home\programming\mathter\mathter\matrix.hpp

; 164  : 	for (int i = 0; i < Rows; ++i) {

	mov	rax, rdi
	npad	12
$LL428@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm1, XMMWORD PTR mat2$[rsp+rax]
	addps	xmm1, XMMWORD PTR mat1$[rbp+rax-256]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 165  : 		result.stripes[i] = lhs.stripes[i] + rhs.stripes[i];

	movaps	XMMWORD PTR $T30[rsp+rax], xmm1
	add	rax, 16

; 164  : 	for (int i = 0; i < Rows; ++i) {

	cmp	rax, 64					; 00000040H
	jl	SHORT $LL428@main
; File c:\home\programming\mathter\main.cpp

; 171  : 	cout << mat1 + mat2 << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, QWORD PTR $T30[rsp]
	call	??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@@@Z ; operator<<<float,4,4,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 178  : 	mat3(0, 0) = 1;		mat3(1, 0) = 2;		mat3(2, 0) = 3;

	movss	xmm0, DWORD PTR __real@3f800000
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	mov	rax, rdi
; File c:\home\programming\mathter\main.cpp

; 178  : 	mat3(0, 0) = 1;		mat3(1, 0) = 2;		mat3(2, 0) = 3;

	movss	DWORD PTR mat3$[rsp], xmm0

; 180  : 	mat3(0, 2) = 7;		mat3(1, 2) = 8;		mat3(2, 2) = 9;

	movss	xmm0, DWORD PTR __real@41100000

; 181  : 
; 182  : 	mat4(0, 0) = 5;		mat4(1, 0) = 4;		mat4(2, 0) = 3;

	mov	DWORD PTR mat4$[rsp], 1084227584	; 40a00000H
	mov	DWORD PTR mat4$[rsp+4], 1082130432	; 40800000H
	mov	DWORD PTR mat4$[rsp+8], 1077936128	; 40400000H
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	movaps	xmm1, XMMWORD PTR mat4$[rsp]
; File c:\home\programming\mathter\main.cpp

; 180  : 	mat3(0, 2) = 7;		mat3(1, 2) = 8;		mat3(2, 2) = 9;

	movss	DWORD PTR mat3$[rbp-216], xmm0
	mov	DWORD PTR mat3$[rsp+4], 1073741824	; 40000000H
	mov	DWORD PTR mat3$[rsp+8], 1077936128	; 40400000H
	mov	DWORD PTR mat3$[rbp-240], 1082130432	; 40800000H
	mov	DWORD PTR mat3$[rbp-236], 1084227584	; 40a00000H
	mov	DWORD PTR mat3$[rbp-232], 1086324736	; 40c00000H
	mov	DWORD PTR mat3$[rbp-224], 1088421888	; 40e00000H
	mov	DWORD PTR mat3$[rbp-220], 1090519040	; 41000000H

; 183  : 	mat4(0, 1) = 6;		mat4(1, 1) = 5;		mat4(2, 1) = 4;

	mov	DWORD PTR mat4$[rsp+16], 1086324736	; 40c00000H
	mov	DWORD PTR mat4$[rsp+20], 1084227584	; 40a00000H
	mov	DWORD PTR mat4$[rsp+24], 1082130432	; 40800000H

; 184  : 	mat4(0, 2) = 7;		mat4(1, 2) = 6;		mat4(2, 2) = 5;

	mov	DWORD PTR mat4$[rsp+32], 1088421888	; 40e00000H
	mov	DWORD PTR mat4$[rsp+36], 1086324736	; 40c00000H
	mov	DWORD PTR mat4$[rsp+40], 1084227584	; 40a00000H
	npad	8
$LL549@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR mat3$[rsp+rax]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR $T36[rbp+rax-256], xmm0
	add	rax, 16

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	cmp	rax, 48					; 00000030H
	jl	SHORT $LL549@main

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR mat3$[rsp+4]
	mov	r10d, 2
	lea	r8, QWORD PTR mat4$[rsp+16]
	npad	4
$LL552@main:

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T36[rbp-256]
	mov	rcx, r9
	mov	edx, 3
	npad	4
$LL555@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rax]
	addps	xmm0, xmm1
; File c:\home\programming\mathter\mathter\vector.hpp

; 404  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL555@main

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	add	r8, 16
	add	r9, rbx
	sub	r10, 1
	jne	SHORT $LL552@main
; File c:\home\programming\mathter\main.cpp

; 186  : 	cout << mat3 * mat4 << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, QWORD PTR $T36[rbp-256]
	call	??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@@@Z ; operator<<<float,3,3,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	movaps	xmm8, XMMWORD PTR __xmm@4080000040400000400000003f800000

; 187  : 
; 188  : 	// correct test mat4x2 & 2x4
; 189  : 	Matrix<float, 4, 2> mat7;
; 190  : 	Matrix<float, 2, 4> mat8;
; 191  : 
; 192  : 	mat7(0, 0) = 1;		mat7(1, 0) = 2;		mat7(2, 0) = 3;		mat7(3, 0) = 4;
; 193  : 	mat7(0, 1) = 5;		mat7(1, 1) = 6;		mat7(2, 1) = 7;		mat7(3, 1) = 8;
; 194  : 
; 195  : 	mat8(0, 0) = 1;		mat8(1, 0) = 5;
; 196  : 	mat8(0, 1) = 2;		mat8(1, 1) = 6;
; 197  : 	mat8(0, 2) = 3;		mat8(1, 2) = 7;
; 198  : 	mat8(0, 3) = 4;		mat8(1, 3) = 8;
; 199  : 
; 200  : 	cout << mat7 << " x " << endl;

	lea	rdx, QWORD PTR mat7$[rsp]
	movaps	xmm9, XMMWORD PTR __xmm@4100000040e0000040c0000040a00000
	movaps	xmm6, XMMWORD PTR __xmm@40c000004000000040a000003f800000
	movaps	xmm7, XMMWORD PTR __xmm@410000004080000040e0000040400000
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	movaps	XMMWORD PTR mat7$[rsp], xmm8
	movaps	XMMWORD PTR mat7$[rsp+16], xmm9
	movups	XMMWORD PTR mat8$[rsp], xmm6
	movups	XMMWORD PTR mat8$[rbp-240], xmm7
	call	??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@@@Z ; operator<<<float,4,2,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967235
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 201  : 	cout << mat8 << " = " << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, QWORD PTR mat8$[rsp]
	call	??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@@@Z ; operator<<<float,2,4,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967234
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movq	QWORD PTR scalarMultiplier$62[rsp], xmm6
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$62[rsp]
	mulss	xmm0, DWORD PTR __real@40a00000

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$62[rsp+4]
	mulss	xmm1, DWORD PTR __real@40a00000
	movss	DWORD PTR scalarMultiplier$62[rsp], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movq	QWORD PTR $T46[rsp], xmm6
; File c:\home\programming\mathter\mathter\vector.hpp

; 164  : 		this->x += rhs.x;

	movss	xmm2, DWORD PTR $T46[rsp]

; 165  : 		this->y += rhs.y;

	movss	xmm3, DWORD PTR $T46[rsp+4]

; 175  : 		this->y *= rhs;

	movss	DWORD PTR scalarMultiplier$62[rsp+4], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	rax, QWORD PTR scalarMultiplier$62[rsp]

; 151  : 			scalarMultiplier = rhs.stripes[x];

	psrldq	xmm6, 8
	movq	QWORD PTR scalarMultiplier$62[rsp], xmm6
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$62[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	QWORD PTR $T46[rsp+8], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$62[rsp+4]
	mulss	xmm1, DWORD PTR __real@40000000

; 164  : 		this->x += rhs.x;

	movss	xmm4, DWORD PTR $T46[rsp+8]
	addss	xmm2, xmm0

; 165  : 		this->y += rhs.y;

	movss	xmm5, DWORD PTR $T46[rsp+12]
	addss	xmm3, xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movq	QWORD PTR scalarMultiplier$62[rsp], xmm6
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$62[rsp]
	mulss	xmm0, DWORD PTR __real@40c00000

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$62[rsp+4]
	mulss	xmm1, DWORD PTR __real@40c00000

; 164  : 		this->x += rhs.x;

	addss	xmm4, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movq	QWORD PTR scalarMultiplier$62[rsp], xmm7
; File c:\home\programming\mathter\mathter\vector.hpp

; 175  : 		this->y *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$62[rsp+4]
	mulss	xmm0, DWORD PTR __real@40400000

; 165  : 		this->y += rhs.y;

	addss	xmm5, xmm1

; 174  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$62[rsp]
	mulss	xmm1, DWORD PTR __real@40400000

; 165  : 		this->y += rhs.y;

	addss	xmm3, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movq	QWORD PTR scalarMultiplier$62[rsp], xmm7
; File c:\home\programming\mathter\mathter\vector.hpp

; 175  : 		this->y *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$62[rsp+4]
	mulss	xmm0, DWORD PTR __real@40e00000

; 164  : 		this->x += rhs.x;

	addss	xmm2, xmm1

; 174  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$62[rsp]
	mulss	xmm1, DWORD PTR __real@40e00000

; 165  : 		this->y += rhs.y;

	addss	xmm5, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	psrldq	xmm7, 8
	movq	QWORD PTR scalarMultiplier$62[rsp], xmm7
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$62[rsp]

; 164  : 		this->x += rhs.x;

	addss	xmm4, xmm1

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$62[rsp+4]
	mulss	xmm0, DWORD PTR __real@40800000
	mulss	xmm1, DWORD PTR __real@40800000
; File c:\home\programming\mathter\main.cpp

; 202  : 	cout << mat7 * mat8 << " & " << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
; File c:\home\programming\mathter\mathter\vector.hpp

; 164  : 		this->x += rhs.x;

	addss	xmm2, xmm0

; 165  : 		this->y += rhs.y;

	addss	xmm3, xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movq	QWORD PTR scalarMultiplier$62[rsp], xmm7
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$62[rsp]
; File c:\home\programming\mathter\main.cpp

; 202  : 	cout << mat7 * mat8 << " & " << endl;

	lea	rdx, QWORD PTR $T46[rsp]
; File c:\home\programming\mathter\mathter\vector.hpp

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$62[rsp+4]
	mulss	xmm0, DWORD PTR __real@41000000
	mulss	xmm1, DWORD PTR __real@41000000

; 164  : 		this->x += rhs.x;

	addss	xmm4, xmm0
	movss	DWORD PTR $T46[rsp], xmm2

; 165  : 		this->y += rhs.y;

	movss	DWORD PTR $T46[rsp+4], xmm3
	addss	xmm5, xmm1
	movss	DWORD PTR $T46[rsp+8], xmm4
	movss	DWORD PTR $T46[rsp+12], xmm5
; File c:\home\programming\mathter\main.cpp

; 202  : 	cout << mat7 * mat8 << " & " << endl;

	call	??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@@@Z ; operator<<<float,2,2,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967233
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	lea	rax, QWORD PTR $T53[rbp-256]
	npad	2
$LL709@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR mat8$[rsp+rdi*8]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR [rax+16]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	inc	rdi
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm0, xmm8
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rax-16], xmm0
	cmp	rdi, rbx
	jl	SHORT $LL709@main

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T53[rbp-256]
	lea	rcx, QWORD PTR mat8$[rsp+4]
	npad	9
$LL715@main:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rax]

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm1, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 8
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm1, xmm1, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm9

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm0, xmm1
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	rbx, 1
	jne	SHORT $LL715@main
; File c:\home\programming\mathter\main.cpp

; 203  : 	cout << mat8 * mat7 << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, QWORD PTR $T53[rbp-256]
	call	??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@@@Z ; operator<<<float,4,4,1>
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 204  : 
; 205  : 
; 206  : 	double elapsed;
; 207  : 	elapsed = MatMulSpeedTest<float, 2, 2, 2, 2>();

	call	??$MatMulSpeedTest@M$01$01$01$01@@YANXZ	; MatMulSpeedTest<float,2,2,2,2>

; 208  : 	cout << "time 2x2 x 2x2:\t" << elapsed * 1000 << " ms" << endl;

	movsd	xmm7, QWORD PTR __real@408f400000000000
	lea	rdx, OFFSET FLAT:$SG4294967231
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967232
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 209  : 	elapsed = MatMulSpeedTest<float, 3, 3, 3, 3>();

	call	??$MatMulSpeedTest@M$02$02$02$02@@YANXZ	; MatMulSpeedTest<float,3,3,3,3>

; 210  : 	cout << "time 3x3 x 3x3:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967229
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967230
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 211  : 	elapsed = MatMulSpeedTest<float, 4, 4, 4, 4>();

	call	??$MatMulSpeedTest@M$03$03$03$03@@YANXZ	; MatMulSpeedTest<float,4,4,4,4>

; 212  : 	cout << "time 4x4 x 4x4:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967227
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967228
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 213  : 	//elapsed = MatMulSpeedTest<float, 8, 8, 8, 8>();
; 214  : 	//cout << "time 8x8 x 8x8:\t" << elapsed * 1000 << " ms" << endl;
; 215  : 	elapsed = MatMulSpeedTest<float, 4, 2, 2, 4>();

	call	??$MatMulSpeedTest@M$03$01$01$03@@YANXZ	; MatMulSpeedTest<float,4,2,2,4>

; 216  : 	cout << "time 4x2 x 2x4:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967225
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967226
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 217  : 	elapsed = MatMulSpeedTest<float, 2, 4, 4, 2>();

	call	??$MatMulSpeedTest@M$01$03$03$01@@YANXZ	; MatMulSpeedTest<float,2,4,4,2>

; 218  : 	cout << "time 2x4 x 4x2:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967223
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967224
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 219  : 	elapsed = MatMulSpeedTest<float, 4, 3, 3, 4>();

	call	??$MatMulSpeedTest@M$03$02$02$03@@YANXZ	; MatMulSpeedTest<float,4,3,3,4>

; 220  : 	cout << "time 4x3 x 3x4:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967221
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967222
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 221  : 	elapsed = MatMulSpeedTest<float, 3, 4, 4, 3>();

	call	??$MatMulSpeedTest@M$02$03$03$02@@YANXZ	; MatMulSpeedTest<float,3,4,4,3>

; 222  : 	cout << "time 3x4 x 4x3:\t" << elapsed * 1000 << " ms" << endl;

	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	lea	rdx, OFFSET FLAT:$SG4294967219
	movaps	xmm6, xmm0
	mulsd	xmm6, xmm7
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	movaps	xmm1, xmm6
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294967220
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 223  : 	
; 224  : 
; 225  : 	return 0;

	xor	eax, eax

; 226  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+320]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rdi, QWORD PTR [r11+48]
	mov	r12, QWORD PTR [r11+56]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$01$03$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$01$03$00@@QEAAAEAMHH@Z PROC		; Matrix<float,2,4,1>::operator(), COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d

; 107  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*2]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 108  : 	}

	ret	0
??R?$Matrix@M$01$03$00@@QEAAAEAMHH@Z ENDP		; Matrix<float,2,4,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$03$01$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$03$01$00@@QEAAAEAMHH@Z PROC		; Matrix<float,4,2,1>::operator(), COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d

; 107  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*4]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 108  : 	}

	ret	0
??R?$Matrix@M$03$01$00@@QEAAAEAMHH@Z ENDP		; Matrix<float,4,2,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$03$03$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$03$03$00@@QEAAAEAMHH@Z PROC		; Matrix<float,4,4,1>::operator(), COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d

; 107  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*4]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 108  : 	}

	ret	0
??R?$Matrix@M$03$03$00@@QEAAAEAMHH@Z ENDP		; Matrix<float,4,4,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$02$02$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$02$02$00@@QEAAAEAMHH@Z PROC		; Matrix<float,3,3,1>::operator(), COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d

; 107  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*4]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 108  : 	}

	ret	0
??R?$Matrix@M$02$02$00@@QEAAAEAMHH@Z ENDP		; Matrix<float,3,3,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 243  : 		: _MyDur(_Other)

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 245  : 		}

	mov	rax, rcx
	ret	0
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$01$03$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$01$03$00@@QEAAAEAMHH@Z PROC	; MatrixData<float,2,4,1>::GetElement, COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d
	lea	rdx, QWORD PTR [rax+r8*2]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 42   : 	}

	ret	0
?GetElement@?$MatrixData@M$01$03$00@@QEAAAEAMHH@Z ENDP	; MatrixData<float,2,4,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$03$01$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$03$01$00@@QEAAAEAMHH@Z PROC	; MatrixData<float,4,2,1>::GetElement, COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d
	lea	rdx, QWORD PTR [rax+r8*4]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 42   : 	}

	ret	0
?GetElement@?$MatrixData@M$03$01$00@@QEAAAEAMHH@Z ENDP	; MatrixData<float,4,2,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$02$02$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$02$02$00@@QEAAAEAMHH@Z PROC	; MatrixData<float,3,3,1>::GetElement, COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d
	lea	rdx, QWORD PTR [rax+r8*4]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 42   : 	}

	ret	0
?GetElement@?$MatrixData@M$02$02$00@@QEAAAEAMHH@Z ENDP	; MatrixData<float,3,3,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$03$03$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$03$03$00@@QEAAAEAMHH@Z PROC	; MatrixData<float,4,4,1>::GetElement, COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d
	lea	rdx, QWORD PTR [rax+r8*4]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 42   : 	}

	ret	0
?GetElement@?$MatrixData@M$03$03$00@@QEAAAEAMHH@Z ENDP	; MatrixData<float,4,4,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 142  : 			return (_Ok);

	movzx	eax, BYTE PTR [rcx+8]

; 143  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 130  : 			{	// destroy the object

$LN13:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T3[rsp], -2
	mov	rbx, rcx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	npad	1
	test	al, al
	jne	SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN2@sentry:

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	rcx, QWORD PTR [rcx+rdx+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 107  : 			if (_Myostr.rdbuf() != 0)

	test	rcx, rcx
	je	SHORT $LN12@sentry

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN12@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 123  : 			{	// construct locking and testing stream

$LN26:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T8[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	rbx, rdx
	mov	rdi, rcx

; 99   : 			: _Myostr(_Ostr)

	mov	QWORD PTR [rcx], rdx

; 101  : 			if (_Myostr.rdbuf() != 0)

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	rcx, QWORD PTR [r8+rdx+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	rcx, rcx
	je	SHORT $LN6@sentry

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN6@sentry:

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [rcx+rbx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN2@sentry
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

	mov	rcx, QWORD PTR [rcx+rbx+80]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	rcx, rcx
	je	SHORT $LN2@sentry
	cmp	rcx, rbx
	je	SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN2@sentry:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [rcx+rbx+16], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR [rdi+8], al

; 127  : 			}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??A?$Vector@M$01@@QEAAAEAMH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??A?$Vector@M$01@@QEAAAEAMH@Z PROC			; Vector<float,2>::operator[], COMDAT

; 684  : 		return data[idx];

	movsxd	rax, edx
	lea	rax, QWORD PTR [rcx+rax*4]

; 685  : 	}

	ret	0
??A?$Vector@M$01@@QEAAAEAMH@Z ENDP			; Vector<float,2>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??A?$Vector@M$03@@QEAAAEAMH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??A?$Vector@M$03@@QEAAAEAMH@Z PROC			; Vector<float,4>::operator[], COMDAT

; 684  : 		return data[idx];

	movsxd	rax, edx
	lea	rax, QWORD PTR [rcx+rax*4]

; 685  : 	}

	ret	0
??A?$Vector@M$03@@QEAAAEAMH@Z ENDP			; Vector<float,4>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??A?$Vector@M$02@@QEAAAEAMH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??A?$Vector@M$02@@QEAAAEAMH@Z PROC			; Vector<float,3>::operator[], COMDAT

; 684  : 		return data[idx];

	movsxd	rax, edx
	lea	rax, QWORD PTR [rcx+rax*4]

; 685  : 	}

	ret	0
??A?$Vector@M$02@@QEAAAEAMH@Z ENDP			; Vector<float,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 106  : 			{	// destroy after unlocking

$LN8:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T3[rsp], -2

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	rdx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rdx+72]
	test	rcx, rcx
	je	SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 109  : 			}

	add	rsp, 56					; 00000038H
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 100  : 			{	// lock the stream buffer, if there

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H

; 99   : 			: _Myostr(_Ostr)

	mov	QWORD PTR [rcx], rdx

; 100  : 			{	// lock the stream buffer, if there

	mov	rbx, rcx

; 101  : 			if (_Myostr.rdbuf() != 0)

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [r8+rdx+72]
	test	rcx, rcx
	je	SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
$LN8@Sentry_bas:

; 103  : 			}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 780  : 	{	// insert NTBS into char stream

$LN114:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T27[rsp], -2
	mov	QWORD PTR [rsp+128], rbx
	mov	r15, rdx
	mov	rsi, rcx

; 781  : 	typedef char _Elem;
; 782  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 783  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR _State$[rsp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [rdx], bl
	jne	SHORT $LN26@operator
	xor	r14d, r14d
	jmp	SHORT $LN27@operator
$LN26@operator:
	or	r14, -1
	npad	5
$LL108@operator:
	inc	r14
	cmp	BYTE PTR [rdx+r14], bl
	jne	SHORT $LL108@operator
$LN27@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	mov	rax, QWORD PTR [rcx]
	movsxd	rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	rdi, QWORD PTR [rcx+rsi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	test	rdi, rdi
	jle	SHORT $LN17@operator
	cmp	rdi, r14
	jle	SHORT $LN17@operator
	sub	rdi, r14
	jmp	SHORT $LN18@operator
$LN17@operator:
	xor	edi, edi
$LN18@operator:

; 99   : 			: _Myostr(_Ostr)

	mov	r12, rsi
	mov	QWORD PTR _Ok$[rsp], rsi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	rcx, QWORD PTR [rcx+rsi+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	rcx, rcx
	je	SHORT $LN39@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN39@operator:

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [rcx+rsi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN35@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

	mov	rcx, QWORD PTR [rcx+rsi+80]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	rcx, rcx
	je	SHORT $LN35@operator
	cmp	rcx, rsi
	je	SHORT $LN35@operator

; 125  : 				_Ostr.tie()->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN35@operator:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [rcx+rsi+16], 0
	sete	al
	mov	BYTE PTR _Ok$[rsp+8], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 789  : 	if (!_Ok)

	test	al, al
	jne	SHORT $LN8@operator

; 790  : 		_State |= ios_base::badbit;

	mov	ebx, 4

; 791  : 	else

	jmp	$LN22@operator
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [rcx+rsi+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 794  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN105@operator
$LL4@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	rdi, rdi
	jle	SHORT $LN3@operator

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	je	SHORT $LN112@operator

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	dec	rdi
	jmp	SHORT $LL4@operator
$LN3@operator:
	test	ebx, ebx

; 800  : 					break;
; 801  : 					}
; 802  : 
; 803  : 		if (_State == ios_base::goodbit
; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	jne	SHORT $LN6@operator
$LN105@operator:
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	r8, r14
	mov	rdx, r15
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	cmp	rax, r14
	jne	SHORT $LN112@operator
$LL109@operator:

; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	rdi, rdi
	jle	SHORT $LN6@operator

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	jne	SHORT $LN5@operator

; 810  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 811  : 					{	// insertion failed, quit
; 812  : 					_State |= ios_base::badbit;

	or	ebx, 4

; 813  : 					break;

	jmp	SHORT $LN111@operator
$LN5@operator:

; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	dec	rdi
	jmp	SHORT $LL109@operator
$LN112@operator:

; 805  : 			_State |= ios_base::badbit;

	mov	ebx, 4
$LN111@operator:

; 797  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 798  : 					{	// insertion failed, quit
; 799  : 					_State |= ios_base::badbit;

	mov	DWORD PTR _State$[rsp], ebx
$LN6@operator:

; 814  : 					}
; 815  : 		_Ostr.width(0);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	QWORD PTR [rcx+rsi+40], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
	jmp	SHORT $LN22@operator
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	rsi, QWORD PTR _Ostr$[rsp]
	mov	ebx, DWORD PTR _State$[rsp]
	mov	r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 819  : 	_Ostr.setstate(_State);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, ebx
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1

; 132  : 			if (!_XSTD uncaught_exception())

	call	QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN88@operator

; 133  : 				this->_Myostr._Osfx();

	mov	rcx, r12
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN88@operator:

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	rax, QWORD PTR [r12]
	movsxd	rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	rcx, QWORD PTR [rcx+r12+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 107  : 			if (_Myostr.rdbuf() != 0)

	test	rcx, rcx
	je	SHORT $LN92@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN92@operator:

; 820  : 	return (_Ostr);

	mov	rax, rsi

; 821  : 	}

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$8

; 816  : 		_CATCH_IO_(_Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	lea	rax, $LN23@catch$8
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$8

; 816  : 		_CATCH_IO_(_Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	lea	rax, $LN23@catch$8
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$8@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 991  : 	{	// insert newline and flush stream

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 992  : 	_Ostr.put(_Ostr.widen('\n'));

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	dl, 10
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
	movzx	edx, al
	mov	rcx, rbx
	call	QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 993  : 	_Ostr.flush();

	mov	rcx, rbx
	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 994  : 	return (_Ostr);

	mov	rax, rbx

; 995  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0MMM$0A@@?$Vector@M$02@@QEAA@MMM@Z
_TEXT	SEGMENT
this$ = 8
<scalars_0>$ = 16
<scalars_1>$ = 24
<scalars_2>$ = 32
??$?0MMM$0A@@?$Vector@M$02@@QEAA@MMM@Z PROC		; Vector<float,3>::Vector<float,3><float,float,float,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 642  : 		static_assert(SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 643  : 		Assign(0, scalars...);
; 644  : 	}

	mov	rax, rcx
	ret	0
??$?0MMM$0A@@?$Vector@M$02@@QEAA@MMM@Z ENDP		; Vector<float,3>::Vector<float,3><float,float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>, COMDAT

; 116  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 118  : 		}

	mov	rax, rcx
	ret	0
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0MMMM$0A@@?$Vector@M$03@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
<scalars_0>$ = 16
<scalars_1>$ = 24
<scalars_2>$ = 32
<scalars_3>$ = 40
??$?0MMMM$0A@@?$Vector@M$03@@QEAA@MMMM@Z PROC		; Vector<float,4>::Vector<float,4><float,float,float,float,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 642  : 		static_assert(SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 643  : 		Assign(0, scalars...);
; 644  : 	}

	mov	rax, rcx
	ret	0
??$?0MMMM$0A@@?$Vector@M$03@@QEAA@MMMM@Z ENDP		; Vector<float,4>::Vector<float,4><float,float,float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?DM$03@@YA?AV?$Vector@M$03@@AEBV0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??$?DM$03@@YA?AV?$Vector@M$03@@AEBV0@0@Z PROC		; operator*<float,4>, COMDAT

; 874  : 	auto tmp = lhs;

	movaps	xmm1, XMMWORD PTR [rdx]

; 875  : 	tmp *= rhs;
; 876  : 	return tmp;

	mov	rax, rcx
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm1, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\vector.hpp

; 458  : 		simd = Simd4f::mul(simd, rhs.simd);

	movaps	XMMWORD PTR [rcx], xmm1

; 877  : }

	ret	0
??$?DM$03@@YA?AV?$Vector@M$03@@AEBV0@0@Z ENDP		; operator*<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0V?$Vector@M$03@@V0@$0A@@?$Vector@M$07@@QEAA@AEBV?$Vector@M$03@@0@Z
_TEXT	SEGMENT
this$ = 8
<mixed_0>$ = 16
<mixed_1>$ = 24
??$?0V?$Vector@M$03@@V0@$0A@@?$Vector@M$07@@QEAA@AEBV?$Vector@M$03@@0@Z PROC ; Vector<float,8>::Vector<float,8><Vector<float,4>,Vector<float,4>,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 649  : 		static_assert(SumDimensions<Mixed...>::value <= D, "Arguments exceed vector dimension.");
; 650  : 		Assign(0, mixed...);
; 651  : 	}

	mov	rax, rcx
	ret	0
??$?0V?$Vector@M$03@@V0@$0A@@?$Vector@M$07@@QEAA@AEBV?$Vector@M$03@@0@Z ENDP ; Vector<float,8>::Vector<float,8><Vector<float,4>,Vector<float,4>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Set@HHHHHHHH$0A@@?$Vector@M$07@@QEAAAEAV0@HHHHHHHH@Z
_TEXT	SEGMENT
this$ = 8
<scalars_0>$dead$ = 16
<scalars_1>$dead$ = 24
<scalars_2>$dead$ = 32
<scalars_3>$dead$ = 40
<scalars_4>$dead$ = 48
<scalars_5>$dead$ = 56
<scalars_6>$dead$ = 64
<scalars_7>$dead$ = 72
??$Set@HHHHHHHH$0A@@?$Vector@M$07@@QEAAAEAV0@HHHHHHHH@Z PROC ; Vector<float,8>::Set<int,int,int,int,int,int,int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx], 1065353216		; 3f800000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+12], 1082130432		; 40800000H
	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 656  : 		static_assert(SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 657  : 		Assign(0, scalars...);
; 658  : 		return *this;

	mov	rax, rcx

; 659  : 	}

	ret	0
??$Set@HHHHHHHH$0A@@?$Vector@M$07@@QEAAAEAV0@HHHHHHHH@Z ENDP ; Vector<float,8>::Set<int,int,int,int,int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Set@V?$Vector@M$03@@V1@$0A@@?$Vector@M$07@@QEAAAEAV0@AEBV?$Vector@M$03@@0@Z
_TEXT	SEGMENT
this$ = 8
<mixed_0>$ = 16
<mixed_1>$ = 24
??$Set@V?$Vector@M$03@@V1@$0A@@?$Vector@M$07@@QEAAAEAV0@AEBV?$Vector@M$03@@0@Z PROC ; Vector<float,8>::Set<Vector<float,4>,Vector<float,4>,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 664  : 		static_assert(SumDimensions<Mixed...>::value <= D, "Arguments exceed vector dimension.");
; 665  : 		Assign(0, mixed...);
; 666  : 		return *this;

	mov	rax, rcx

; 667  : 	}

	ret	0
??$Set@V?$Vector@M$03@@V1@$0A@@?$Vector@M$07@@QEAAAEAV0@AEBV?$Vector@M$03@@0@Z ENDP ; Vector<float,8>::Set<Vector<float,4>,Vector<float,4>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@@@Z
_TEXT	SEGMENT
os$ = 64
v$ = 72
??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@@@Z PROC ; operator<<<float,4>, COMDAT

; 24   : std::ostream& operator<<(std::ostream& os, const Vector<T, D>& v) {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r14, rdx
	mov	rbp, rcx

; 25   : 	os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967198
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 26   : 	for (int x = 0; x < D; ++x) {

	xor	esi, esi
	lea	r15, OFFSET FLAT:$SG4294967197
	mov	edi, esi
	npad	11
$LL4@operator:

; 27   : 		os << v(x) << (x == D - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [r14+rdi*4]
	lea	rbx, OFFSET FLAT:$SG4294967196
	cmp	esi, 3
	mov	rcx, rbp
	cmove	rbx, r15
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	inc	rdi
	cmp	rdi, 4
	jl	SHORT $LL4@operator

; 28   : 	}
; 29   : 	os << "}";

	lea	rdx, OFFSET FLAT:$SG4294967195
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 30   : 	return os;
; 31   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
??$?6M$03@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Vector@M$03@@@Z ENDP ; operator<<<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0H$0A@@?$Vector@M$02@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 8
<scalars_0>$dead$ = 16
??$?0H$0A@@?$Vector@M$02@@QEAA@H@Z PROC			; Vector<float,3>::Vector<float,3><int,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 642  : 		static_assert(SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 643  : 		Assign(0, scalars...);
; 644  : 	}

	mov	rax, rcx
	ret	0
??$?0H$0A@@?$Vector@M$02@@QEAA@H@Z ENDP			; Vector<float,3>::Vector<float,3><int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?0V?$Vector@M$02@@$0A@@?$Vector@M$03@@QEAA@AEBV?$Vector@M$02@@@Z
_TEXT	SEGMENT
this$ = 8
<mixed_0>$dead$ = 16
??$?0V?$Vector@M$02@@$0A@@?$Vector@M$03@@QEAA@AEBV?$Vector@M$02@@@Z PROC ; Vector<float,4>::Vector<float,4><Vector<float,3>,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 649  : 		static_assert(SumDimensions<Mixed...>::value <= D, "Arguments exceed vector dimension.");
; 650  : 		Assign(0, mixed...);
; 651  : 	}

	mov	rax, rcx
	ret	0
??$?0V?$Vector@M$02@@$0A@@?$Vector@M$03@@QEAA@AEBV?$Vector@M$02@@@Z ENDP ; Vector<float,4>::Vector<float,4><Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Set@HHH$0A@@?$Vector@M$02@@QEAAAEAV0@HHH@Z
_TEXT	SEGMENT
this$ = 8
<scalars_0>$dead$ = 16
<scalars_1>$dead$ = 24
<scalars_2>$dead$ = 32
??$Set@HHH$0A@@?$Vector@M$02@@QEAAAEAV0@HHH@Z PROC	; Vector<float,3>::Set<int,int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx], 1065353216		; 3f800000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 656  : 		static_assert(SumDimensions<Scalars...>::value <= D, "Arguments exceed vector dimension.");
; 657  : 		Assign(0, scalars...);
; 658  : 		return *this;

	mov	rax, rcx

; 659  : 	}

	ret	0
??$Set@HHH$0A@@?$Vector@M$02@@QEAAAEAV0@HHH@Z ENDP	; Vector<float,3>::Set<int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Set@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@QEAAAEAV0@AEBMAEBV?$Vector@M$02@@@Z
_TEXT	SEGMENT
this$ = 8
<mixed_0>$ = 16
<mixed_1>$ = 24
??$Set@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@QEAAAEAV0@AEBMAEBV?$Vector@M$02@@@Z PROC ; Vector<float,4>::Set<float,Vector<float,3>,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 664  : 		static_assert(SumDimensions<Mixed...>::value <= D, "Arguments exceed vector dimension.");
; 665  : 		Assign(0, mixed...);
; 666  : 		return *this;

	mov	rax, rcx

; 667  : 	}

	ret	0
??$Set@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@QEAAAEAV0@AEBMAEBV?$Vector@M$02@@@Z ENDP ; Vector<float,4>::Set<float,Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?DMM$03$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??$?DMM$03$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV0@0@Z PROC ; operator*<float,float,4,4,4,1,1,float,void>, COMDAT

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	mov	r10, rdx
	mov	r11, rcx
	sub	r10, rcx
	mov	rax, rcx
	mov	r9d, 4
$LL4@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm1, DWORD PTR [r10+rax]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR [rax+16]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm1, xmm1, 0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm0, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rax-16], xmm1
	sub	r9, 1
	jne	SHORT $LL4@operator

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR [rdx+4]
	mov	r10d, 3
	lea	rdx, QWORD PTR [r8+16]
	npad	1
$LL7@operator:

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	mov	rax, r11
	mov	rcx, r9
	mov	r8d, 4
	npad	4
$LL10@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	r8, 1
	jne	SHORT $LL10@operator

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	add	rdx, 16
	add	r9, 4
	sub	r10, 1
	jne	SHORT $LL7@operator

; 152  : 			scalarMultiplier.mul(lhs(x, y));
; 153  : 			static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]).add(scalarMultiplier);
; 154  : 		}
; 155  : 	}
; 156  : 
; 157  : 	return result;

	mov	rax, r11

; 158  : }

	ret	0
??$?DMM$03$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV0@0@Z ENDP ; operator*<float,float,4,4,4,1,1,float,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@@@Z
_TEXT	SEGMENT
os$ = 64
mat$ = 72
??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@@@Z PROC ; operator<<<float,4,4,1>, COMDAT

; 12   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 13   : 	for (int y = 0; y < mat.Height(); ++y) {

	lea	r12, OFFSET FLAT:$SG4294967193
	mov	rbp, rcx
	mov	r15d, 4
$LL4@operator:

; 14   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967194
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 15   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	esi, esi
	lea	r14d, QWORD PTR [rsi+4]
	npad	10
$LL7@operator:

; 16   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rdi]
	lea	rbx, OFFSET FLAT:$SG4294967192
	cmp	esi, 3
	mov	rcx, rbp
	cmove	rbx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	add	rdi, 4
	sub	r14, 1
	jne	SHORT $LL7@operator

; 17   : 		}
; 18   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967191
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	sub	r15, 1
	jne	SHORT $LL4@operator

; 19   : 	}
; 20   : 	return os;
; 21   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
??$?6M$03$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$03$00@@@Z ENDP ; operator<<<float,4,4,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?HMM$03$03$00$00M@@YA?AV?$Matrix@M$03$03$00@@AEBV0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??$?HMM$03$03$00$00M@@YA?AV?$Matrix@M$03$03$00@@AEBV0@0@Z PROC ; operator+<float,float,4,4,1,1,float>, COMDAT

; 163  : 	Matrix<U, Columns, Rows, Order1> result;
; 164  : 	for (int i = 0; i < Rows; ++i) {

	sub	rdx, r8
	mov	r9, rcx
	sub	r9, r8
	mov	eax, 4
	npad	2
$LL4@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [r8]
	addps	xmm0, XMMWORD PTR [rdx+r8]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 165  : 		result.stripes[i] = lhs.stripes[i] + rhs.stripes[i];

	movaps	XMMWORD PTR [r9+r8], xmm0
	add	r8, 16
	sub	rax, 1
	jne	SHORT $LL4@operator

; 166  : 	}
; 167  : 	return result;

	mov	rax, rcx

; 168  : }

	ret	0
??$?HMM$03$03$00$00M@@YA?AV?$Matrix@M$03$03$00@@AEBV0@0@Z ENDP ; operator+<float,float,4,4,1,1,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?DMM$02$02$02$00$00MX@@YA?AV?$Matrix@M$02$02$00@@AEBV0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??$?DMM$02$02$02$00$00MX@@YA?AV?$Matrix@M$02$02$00@@AEBV0@0@Z PROC ; operator*<float,float,3,3,3,1,1,float,void>, COMDAT

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	mov	r10, rdx
	mov	r11, rcx
	sub	r10, rcx
	mov	rax, rcx
	mov	r9d, 3
$LL4@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm1, DWORD PTR [r10+rax]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR [rax+16]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm1, xmm1, 0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm0, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rax-16], xmm1
	sub	r9, 1
	jne	SHORT $LL4@operator

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR [rdx+4]
	mov	r10d, 2
	lea	rdx, QWORD PTR [r8+16]
	npad	1
$LL7@operator:

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	mov	rax, r11
	mov	rcx, r9
	mov	r8d, 3
	npad	4
$LL10@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 404  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	r8, 1
	jne	SHORT $LL10@operator

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	add	rdx, 16
	add	r9, 4
	sub	r10, 1
	jne	SHORT $LL7@operator

; 152  : 			scalarMultiplier.mul(lhs(x, y));
; 153  : 			static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]).add(scalarMultiplier);
; 154  : 		}
; 155  : 	}
; 156  : 
; 157  : 	return result;

	mov	rax, r11

; 158  : }

	ret	0
??$?DMM$02$02$02$00$00MX@@YA?AV?$Matrix@M$02$02$00@@AEBV0@0@Z ENDP ; operator*<float,float,3,3,3,1,1,float,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@@@Z
_TEXT	SEGMENT
os$ = 80
mat$ = 88
??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@@@Z PROC ; operator<<<float,3,3,1>, COMDAT

; 12   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r15, rdx

; 13   : 	for (int y = 0; y < mat.Height(); ++y) {

	lea	r13, OFFSET FLAT:$SG4294967189
	mov	rbp, rcx
	mov	r12d, 3
	npad	1
$LL4@operator:

; 14   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967190
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 15   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	edi, edi
	mov	rsi, r15
	lea	r14d, QWORD PTR [rdi+3]
	npad	8
$LL7@operator:

; 16   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rsi]
	lea	rbx, OFFSET FLAT:$SG4294967188
	cmp	edi, 2
	mov	rcx, rbp
	cmove	rbx, r13
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	edi
	lea	rsi, QWORD PTR [rsi+4]
	sub	r14, 1
	jne	SHORT $LL7@operator

; 17   : 		}
; 18   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967187
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	add	r15, 16
	sub	r12, 1
	jne	SHORT $LL4@operator

; 19   : 	}
; 20   : 	return os;
; 21   : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
??$?6M$02$02$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$02$02$00@@@Z ENDP ; operator<<<float,3,3,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@@@Z
_TEXT	SEGMENT
os$ = 64
mat$ = 72
??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@@@Z PROC ; operator<<<float,4,2,1>, COMDAT

; 12   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 13   : 	for (int y = 0; y < mat.Height(); ++y) {

	lea	r12, OFFSET FLAT:$SG4294967185
	mov	rbp, rcx
	mov	r15d, 2
$LL4@operator:

; 14   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967186
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 15   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	esi, esi
	lea	r14d, QWORD PTR [rsi+4]
	npad	10
$LL7@operator:

; 16   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rdi]
	lea	rbx, OFFSET FLAT:$SG4294967184
	cmp	esi, 3
	mov	rcx, rbp
	cmove	rbx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	add	rdi, 4
	sub	r14, 1
	jne	SHORT $LL7@operator

; 17   : 		}
; 18   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967183
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	sub	r15, 1
	jne	SHORT $LL4@operator

; 19   : 	}
; 20   : 	return os;
; 21   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
??$?6M$03$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$03$01$00@@@Z ENDP ; operator<<<float,4,2,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@@@Z
_TEXT	SEGMENT
os$ = 64
mat$ = 72
??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@@@Z PROC ; operator<<<float,2,4,1>, COMDAT

; 12   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 13   : 	for (int y = 0; y < mat.Height(); ++y) {

	lea	r12, OFFSET FLAT:$SG4294967181
	mov	rbp, rcx
	mov	r15d, 4
$LL4@operator:

; 14   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967182
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 15   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	esi, esi
	lea	r14d, QWORD PTR [rsi+2]
	npad	10
$LL7@operator:

; 16   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rdi]
	lea	rbx, OFFSET FLAT:$SG4294967180
	cmp	esi, 1
	mov	rcx, rbp
	cmove	rbx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	add	rdi, 4
	sub	r14, 1
	jne	SHORT $LL7@operator

; 17   : 		}
; 18   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967179
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	sub	r15, 1
	jne	SHORT $LL4@operator

; 19   : 	}
; 20   : 	return os;
; 21   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
??$?6M$01$03$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$03$00@@@Z ENDP ; operator<<<float,2,4,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?DMM$03$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV?$Matrix@M$03$01$00@@AEBV?$Matrix@M$01$03$00@@@Z
_TEXT	SEGMENT
scalarMultiplier$ = 16
__$ReturnUdt$ = 16
lhs$ = 24
rhs$ = 32
??$?DMM$03$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV?$Matrix@M$03$01$00@@AEBV?$Matrix@M$01$03$00@@@Z PROC ; operator*<float,float,4,2,2,1,1,float,void>, COMDAT

; 138  : {

$LN62:
	push	rbp
	mov	rbp, rsp

; 139  : 	using ResultT = Matrix<V, Columns2, Rows1, Order1>;
; 140  : 
; 141  : 	ResultT result;
; 142  : 
; 143  : 	VectorSpec<V, Columns2> scalarMultiplier;
; 144  : 	for (int y = 0; y < Rows1; ++y) {
; 145  : 		scalarMultiplier = rhs.stripes[0];

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR scalarMultiplier$[rbp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$[rbp]
	mulss	xmm0, DWORD PTR [rdx]

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rbp+4]
	mulss	xmm1, DWORD PTR [rdx]
	movss	DWORD PTR scalarMultiplier$[rbp], xmm0
	movss	DWORD PTR scalarMultiplier$[rbp+4], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	rax, QWORD PTR scalarMultiplier$[rbp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR scalarMultiplier$[rbp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rbp+4]
	mulss	xmm1, DWORD PTR [rdx+16]
	movss	xmm0, DWORD PTR scalarMultiplier$[rbp]
	mulss	xmm0, DWORD PTR [rdx+16]
	movss	DWORD PTR scalarMultiplier$[rbp+4], xmm1
	movss	DWORD PTR scalarMultiplier$[rbp], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	rax, QWORD PTR scalarMultiplier$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 151  : 			scalarMultiplier = rhs.stripes[x];

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR scalarMultiplier$[rbp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rbp]
	mulss	xmm1, DWORD PTR [rdx+4]

; 175  : 		this->y *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$[rbp+4]
	mulss	xmm2, DWORD PTR [rdx+4]

; 164  : 		this->x += rhs.x;

	addss	xmm1, DWORD PTR [rcx]

; 165  : 		this->y += rhs.y;

	addss	xmm2, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR scalarMultiplier$[rbp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rbp]
	mulss	xmm1, DWORD PTR [rdx+20]

; 175  : 		this->y *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$[rbp+4]
	mulss	xmm2, DWORD PTR [rdx+20]

; 164  : 		this->x += rhs.x;

	addss	xmm1, DWORD PTR [rcx+8]
	movss	DWORD PTR [rcx+8], xmm1

; 165  : 		this->y += rhs.y;

	addss	xmm2, DWORD PTR [rcx+12]
	movss	DWORD PTR [rcx+12], xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR scalarMultiplier$[rbp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rbp]
	mulss	xmm1, DWORD PTR [rdx+8]

; 175  : 		this->y *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$[rbp+4]
	mulss	xmm2, DWORD PTR [rdx+8]

; 164  : 		this->x += rhs.x;

	addss	xmm1, DWORD PTR [rcx]
	movss	DWORD PTR [rcx], xmm1

; 165  : 		this->y += rhs.y;

	addss	xmm2, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx+4], xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR scalarMultiplier$[rbp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rbp]
	mulss	xmm1, DWORD PTR [rdx+24]

; 175  : 		this->y *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$[rbp+4]
	mulss	xmm2, DWORD PTR [rdx+24]

; 164  : 		this->x += rhs.x;

	addss	xmm1, DWORD PTR [rcx+8]
	movss	DWORD PTR [rcx+8], xmm1

; 165  : 		this->y += rhs.y;

	addss	xmm2, DWORD PTR [rcx+12]
	movss	DWORD PTR [rcx+12], xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	mov	rax, QWORD PTR [r8+24]
	mov	QWORD PTR scalarMultiplier$[rbp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rbp]
	mulss	xmm1, DWORD PTR [rdx+12]

; 175  : 		this->y *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$[rbp+4]
	mulss	xmm2, DWORD PTR [rdx+12]

; 164  : 		this->x += rhs.x;

	addss	xmm1, DWORD PTR [rcx]
	movss	DWORD PTR [rcx], xmm1

; 165  : 		this->y += rhs.y;

	addss	xmm2, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx+4], xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	mov	rax, QWORD PTR [r8+24]
	mov	QWORD PTR scalarMultiplier$[rbp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rbp]
	mulss	xmm1, DWORD PTR [rdx+28]

; 175  : 		this->y *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$[rbp+4]
	mulss	xmm2, DWORD PTR [rdx+28]

; 164  : 		this->x += rhs.x;

	addss	xmm1, DWORD PTR [rcx+8]
	movss	DWORD PTR [rcx+8], xmm1

; 165  : 		this->y += rhs.y;

	addss	xmm2, DWORD PTR [rcx+12]
	movss	DWORD PTR [rcx+12], xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 157  : 	return result;

	mov	rax, rcx

; 158  : }

	pop	rbp
	ret	0
??$?DMM$03$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV?$Matrix@M$03$01$00@@AEBV?$Matrix@M$01$03$00@@@Z ENDP ; operator*<float,float,4,2,2,1,1,float,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@@@Z
_TEXT	SEGMENT
os$ = 64
mat$ = 72
??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@@@Z PROC ; operator<<<float,2,2,1>, COMDAT

; 12   : std::ostream& operator<<(std::ostream& os, const Matrix<T, Columns, Rows, Order>& mat) {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 13   : 	for (int y = 0; y < mat.Height(); ++y) {

	lea	r12, OFFSET FLAT:$SG4294967177
	mov	rbp, rcx
	mov	r15d, 2
$LL4@operator:

; 14   : 		os << "{";

	lea	rdx, OFFSET FLAT:$SG4294967178
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 15   : 		for (int x = 0; x < mat.Width(); ++x) {

	xor	esi, esi
	lea	r14d, QWORD PTR [rsi+2]
	npad	10
$LL7@operator:

; 16   : 			os << mat(x, y) << (x == mat.Width() - 1 ? "" : "\t");

	movss	xmm1, DWORD PTR [rdi]
	lea	rbx, OFFSET FLAT:$SG4294967176
	cmp	esi, 1
	mov	rcx, rbp
	cmove	rbx, r12
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	add	rdi, 4
	sub	r14, 1
	jne	SHORT $LL7@operator

; 17   : 		}
; 18   : 		os << "}\n";

	lea	rdx, OFFSET FLAT:$SG4294967175
	mov	rcx, rbp
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	sub	r15, 1
	jne	SHORT $LL4@operator

; 19   : 	}
; 20   : 	return os;
; 21   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
??$?6M$01$01$00@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV01@AEBV?$Matrix@M$01$01$00@@@Z ENDP ; operator<<<float,2,2,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?DMM$01$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV?$Matrix@M$01$03$00@@AEBV?$Matrix@M$03$01$00@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??$?DMM$01$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV?$Matrix@M$01$03$00@@AEBV?$Matrix@M$03$01$00@@@Z PROC ; operator*<float,float,2,4,4,1,1,float,void>, COMDAT

; 138  : {

	mov	r10, rcx

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	xor	eax, eax
	mov	r9, rcx
	npad	8
$LL4@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm1, DWORD PTR [rdx+rax*8]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	lea	r9, QWORD PTR [r9+16]

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm0, XMMWORD PTR [r8]
	inc	rax
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm1, xmm1, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [r9-16], xmm1
	cmp	rax, 4
	jl	SHORT $LL4@operator

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rcx, QWORD PTR [rdx+4]
	mov	rax, r10
	mov	edx, 4
	npad	2
$LL10@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 8

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r8+16]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rax]
	addps	xmm0, xmm1
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL10@operator

; 152  : 			scalarMultiplier.mul(lhs(x, y));
; 153  : 			static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]).add(scalarMultiplier);
; 154  : 		}
; 155  : 	}
; 156  : 
; 157  : 	return result;

	mov	rax, r10

; 158  : }

	ret	0
??$?DMM$01$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV?$Matrix@M$01$03$00@@AEBV?$Matrix@M$03$01$00@@@Z ENDP ; operator*<float,float,2,4,4,1,1,float,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$01$01$01$01@@YANXZ
_TEXT	SEGMENT
scalarMultiplier$146 = 32
$T147 = 40
result$ = 48
right$ = 72
left$ = 96
$T22 = 120
__$ArrayPad$ = 144
??$MatMulSpeedTest@M$01$01$01$01@@YANXZ PROC		; MatMulSpeedTest<float,2,2,2,2>, COMDAT

; 88   : double MatMulSpeedTest() {

$LN591:
	mov	rax, rsp
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 176				; 000000b0H
	mov	QWORD PTR $T147[rbp-105], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	movaps	XMMWORD PTR [rax-40], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rbp-105]
	call	??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >
	npad	1

; 95   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rbp-105]
	call	??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >
	npad	1

; 96   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rbp-105]
	call	??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	rsi, QWORD PTR right$[rbp-105]
	mov	rcx, rsi

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	r14, QWORD PTR left$[rbp-105]
	mov	rdi, r14
	sub	rdi, rsi

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r8d, 100000				; 000186a0H
	npad	3
$LL4@MatMulSpee:

; 102  : 		LeftT& l = left[i];

	lea	rdx, QWORD PTR [rdi+rcx]

; 103  : 		RightT& r = right[i];
; 104  : 
; 105  : 		for (int x = 0; x < Col1; ++x) {

	xor	eax, eax
	npad	10
$LL7@MatMulSpee:

; 106  : 			for (int y = 0; y < Row1; ++y) {
; 107  : 				l(x, y) = 2;

	mov	DWORD PTR [rdx+rax*8], 1073741824	; 40000000H
	mov	DWORD PTR [rdx+rax*8+4], 1073741824	; 40000000H

; 103  : 		RightT& r = right[i];
; 104  : 
; 105  : 		for (int x = 0; x < Col1; ++x) {

	inc	rax
	cmp	rax, 2
	jl	SHORT $LL7@MatMulSpee

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	xor	eax, eax
	npad	6
$LL13@MatMulSpee:

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	DWORD PTR [rcx+rax*8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax*8+4], 1073741824	; 40000000H

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	inc	rax
	cmp	rax, 2
	jl	SHORT $LL13@MatMulSpee

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	add	rcx, 16
	sub	r8, 1
	jne	SHORT $LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	mov	r15, QWORD PTR result$[rbp-105]
	mov	r10, r15
	sub	r10, rsi

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	r9d, 100				; 00000064H
	npad	3
$LL19@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 122  : 		for (int i = 0; i < iterationCount; ++i) {

	lea	rdx, QWORD PTR [rsi+8]
	mov	r8d, 100000				; 000186a0H
	npad	6
$LL22@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	mov	rax, QWORD PTR [rdx-8]
	mov	QWORD PTR scalarMultiplier$146[rbp-105], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$146[rbp-105]
	mulss	xmm0, DWORD PTR [rdi+rdx-8]
	movss	DWORD PTR scalarMultiplier$146[rbp-105], xmm0

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$146[rbp-101]
	mulss	xmm1, DWORD PTR [rdi+rdx-8]
	movss	DWORD PTR scalarMultiplier$146[rbp-101], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	rcx, QWORD PTR scalarMultiplier$146[rbp-105]
	mov	QWORD PTR $T22[rbp-105], rcx

; 145  : 		scalarMultiplier = rhs.stripes[0];

	mov	QWORD PTR scalarMultiplier$146[rbp-105], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$146[rbp-105]
	mulss	xmm0, DWORD PTR [rdx+rdi]
	movss	DWORD PTR scalarMultiplier$146[rbp-105], xmm0

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$146[rbp-101]
	mulss	xmm1, DWORD PTR [rdx+rdi]
	movss	DWORD PTR scalarMultiplier$146[rbp-101], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	rax, QWORD PTR scalarMultiplier$146[rbp-105]
	mov	QWORD PTR $T22[rbp-97], rax

; 151  : 			scalarMultiplier = rhs.stripes[x];

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR scalarMultiplier$146[rbp-105], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$146[rbp-105]
	mulss	xmm2, DWORD PTR [rdi+rdx-4]

; 175  : 		this->y *= rhs;

	movss	xmm3, DWORD PTR scalarMultiplier$146[rbp-101]
	mulss	xmm3, DWORD PTR [rdi+rdx-4]

; 164  : 		this->x += rhs.x;

	movss	xmm1, DWORD PTR $T22[rbp-105]
	addss	xmm1, xmm2
	movss	DWORD PTR $T22[rbp-105], xmm1

; 165  : 		this->y += rhs.y;

	movss	xmm0, DWORD PTR $T22[rbp-101]
	addss	xmm0, xmm3
	movss	DWORD PTR $T22[rbp-101], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	mov	QWORD PTR scalarMultiplier$146[rbp-105], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$146[rbp-105]
	mulss	xmm2, DWORD PTR [rdi+rdx+4]

; 175  : 		this->y *= rhs;

	movss	xmm3, DWORD PTR scalarMultiplier$146[rbp-101]
	mulss	xmm3, DWORD PTR [rdi+rdx+4]

; 164  : 		this->x += rhs.x;

	movss	xmm0, DWORD PTR $T22[rbp-97]
	addss	xmm0, xmm2
	movss	DWORD PTR $T22[rbp-97], xmm0

; 165  : 		this->y += rhs.y;

	movss	xmm1, DWORD PTR $T22[rbp-93]
	addss	xmm1, xmm3
	movss	DWORD PTR $T22[rbp-93], xmm1
; File c:\home\programming\mathter\main.cpp

; 123  : 			result[i] = left[i] * right[i];

	movups	xmm0, XMMWORD PTR $T22[rbp-105]
	movups	XMMWORD PTR [r10+rdx-8], xmm0

; 122  : 		for (int i = 0; i < iterationCount; ++i) {

	add	rdx, 16
	sub	r8, 1
	jne	$LL22@MatMulSpee

; 113  : 			}
; 114  : 		}
; 115  : 	}
; 116  : 
; 117  : 	std::chrono::high_resolution_clock::time_point startTime;
; 118  : 	std::chrono::high_resolution_clock::time_point endTime;
; 119  : 
; 120  : 	startTime = std::chrono::high_resolution_clock::now();
; 121  : 	for (int j = 0; j < 100; ++j) {

	sub	r9, 1
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, rbx
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 1152921504606846975		; 0fffffffffffffffH
	test	r15, r15
	je	SHORT $LN218@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR result$[rbp-89]
	sub	rax, r15
	sar	rax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN285@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN285@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN286@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r15b, 31
	je	SHORT $LN287@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN287@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r15-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r15
	jb	SHORT $LN288@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN288@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r15, rax
	cmp	r15, 8
	jae	SHORT $LN289@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN289@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r15, 39					; 00000027H
	jbe	SHORT $LN290@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN290@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r15, rax
$LN286@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r15
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN218@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rsi, rsi
	je	SHORT $LN328@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR right$[rbp-89]
	sub	rax, rsi
	sar	rax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN395@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN395@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN396@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	sil, 31
	je	SHORT $LN397@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN397@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rsi-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rsi
	jb	SHORT $LN398@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN398@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rsi, rax
	cmp	rsi, 8
	jae	SHORT $LN399@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN399@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rsi, 39					; 00000027H
	jbe	SHORT $LN400@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN400@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rsi, rax
$LN396@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rsi
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN328@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r14, r14
	je	SHORT $LN437@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR left$[rbp-89]
	sub	rax, r14
	sar	rax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN504@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN504@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN505@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r14b, 31
	je	SHORT $LN506@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN506@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r14-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r14
	jb	SHORT $LN507@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN507@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r14, rax
	cmp	r14, 8
	jae	SHORT $LN508@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN508@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r14, 39					; 00000027H
	jbe	SHORT $LN509@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN509@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r14, rax
$LN505@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r14
	call	??3@YAXPEAX@Z				; operator delete
$LN437@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 129  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rdi, QWORD PTR [r11+48]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN590@MatMulSpee:
??$MatMulSpeedTest@M$01$01$01$01@@YANXZ ENDP		; MatMulSpeedTest<float,2,2,2,2>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
scalarMultiplier$146 = 32
$T147 = 40
result$ = 48
right$ = 72
left$ = 96
$T22 = 120
__$ArrayPad$ = 144
?dtor$0@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::~vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$0
scalarMultiplier$146 = 32
$T147 = 40
result$ = 48
right$ = 72
left$ = 96
$T22 = 120
__$ArrayPad$ = 144
?dtor$1@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::~vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
scalarMultiplier$146 = 32
$T147 = 40
result$ = 48
right$ = 72
left$ = 96
$T22 = 120
__$ArrayPad$ = 144
?dtor$0@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::~vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
scalarMultiplier$146 = 32
$T147 = 40
result$ = 48
right$ = 72
left$ = 96
$T22 = 120
__$ArrayPad$ = 144
?dtor$1@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::~vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$01$01$01$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,2,2,2>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$02$02$02$02@@YANXZ
_TEXT	SEGMENT
tv1922 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 176
??$MatMulSpeedTest@M$02$02$02$02@@YANXZ PROC		; MatMulSpeedTest<float,3,3,3,3>, COMDAT

; 88   : double MatMulSpeedTest() {

$LN595:
	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 208				; 000000d0H
	mov	QWORD PTR $T157[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >
	npad	1

; 95   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >
	npad	1

; 96   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r14, QWORD PTR left$[rsp]
	mov	r9, r14

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	rsi, r14
	mov	r13, QWORD PTR right$[rsp]
	sub	rsi, r13
	mov	rbx, r13
	sub	rbx, r14
	mov	rdi, r14
	neg	rdi

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r11d, 100000				; 000186a0H
	npad	13
$LL4@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rcx, QWORD PTR [rbx+8]
	add	rcx, r9
	lea	rax, QWORD PTR [rcx+rsi]
; File c:\home\programming\mathter\main.cpp

; 107  : 				l(x, y) = 2;

	lea	r10, QWORD PTR [rdi+r9]
	mov	rdx, r9
	sub	rdx, r10
	sub	rdx, r14
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	r8d, 3
	npad	2
$LL7@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 107  : 				l(x, y) = 2;

	mov	DWORD PTR [rdx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rdx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H

; 102  : 		LeftT& l = left[i];
; 103  : 		RightT& r = right[i];
; 104  : 
; 105  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	r8, 1
	jne	SHORT $LL7@MatMulSpee

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	rax, rbx
	sub	rax, r10
	sub	rax, r13
	lea	rdx, QWORD PTR [rax+r9]
	lea	r8, QWORD PTR [rax+r9]

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	mov	eax, 3
$LL13@MatMulSpee:

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	DWORD PTR [r8+rcx-8], 1073741824	; 40000000H
	mov	DWORD PTR [rdx+rcx-4], 1073741824	; 40000000H
	mov	DWORD PTR [rcx], 1073741824		; 40000000H

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	lea	rcx, QWORD PTR [rcx+16]
	sub	rax, 1
	jne	SHORT $LL13@MatMulSpee

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	add	r9, 48					; 00000030H
	sub	r11, 1
	jne	$LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	lea	r14, QWORD PTR [r13+16]
	lea	r15, QWORD PTR [rsi-12]
	lea	rax, QWORD PTR $T26[rsp]
	sub	rsi, rax
	mov	r12, QWORD PTR result$[rsp]
	mov	rdi, r12
	sub	rdi, r13

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	QWORD PTR tv1922[rsp], 100		; 00000064H
	npad	9
$LL19@MatMulSpee:
	mov	r10, r14
	mov	ebp, 100000				; 000186a0H
	npad	8
$LL22@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rcx, QWORD PTR $T26[rsp]
	mov	edx, 3
	npad	3
$LL130@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm1, XMMWORD PTR [r10-16]
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	lea	rax, QWORD PTR [rsi+r10]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rax+rcx-16]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rcx], xmm1

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rcx, QWORD PTR [rcx+16]
	sub	rdx, 1
	jne	SHORT $LL130@MatMulSpee

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR [r15+r10]
	mov	r8, r10
	lea	r11d, QWORD PTR [rdx+2]
	npad	2
$LL133@MatMulSpee:

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T26[rsp]
	mov	rcx, r9
	mov	edx, 3
$LL136@MatMulSpee:

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 404  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16
	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL136@MatMulSpee

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	add	r8, 16
	add	r9, 4
	sub	r11, 1
	jne	SHORT $LL133@MatMulSpee
; File c:\home\programming\mathter\main.cpp

; 123  : 			result[i] = left[i] * right[i];

	movaps	xmm0, XMMWORD PTR $T26[rsp]
	movaps	XMMWORD PTR [rdi+r10-16], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+16]
	movaps	XMMWORD PTR [rdi+r10], xmm1
	movaps	xmm0, XMMWORD PTR $T26[rsp+32]
	movaps	XMMWORD PTR [rdi+r10+16], xmm0

; 122  : 		for (int i = 0; i < iterationCount; ++i) {

	add	r10, 48					; 00000030H
	sub	rbp, 1
	jne	$LL22@MatMulSpee

; 113  : 			}
; 114  : 		}
; 115  : 	}
; 116  : 
; 117  : 	std::chrono::high_resolution_clock::time_point startTime;
; 118  : 	std::chrono::high_resolution_clock::time_point endTime;
; 119  : 
; 120  : 	startTime = std::chrono::high_resolution_clock::now();
; 121  : 	for (int j = 0; j < 100; ++j) {

	sub	QWORD PTR tv1922[rsp], 1
	lea	r14, QWORD PTR [r13+16]
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, rbx
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rdi, 384307168202282325			; 0555555555555555H
	test	r12, r12
	mov	r14, QWORD PTR left$[rsp]
	je	SHORT $LN224@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR result$[rsp+16]
	sub	rcx, r12
	mov	rax, rbx
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rdx, rdi
	jbe	SHORT $LN291@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN291@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN292@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r12b, 31
	je	SHORT $LN293@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r12-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r12
	jb	SHORT $LN294@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN294@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r12, rax
	cmp	r12, 8
	jae	SHORT $LN295@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r12, 39					; 00000027H
	jbe	SHORT $LN296@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN296@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r12, rax
$LN292@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r12
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN224@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r13, r13
	je	SHORT $LN334@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR right$[rsp+16]
	sub	rcx, r13
	mov	rax, rbx
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rdx, rdi
	jbe	SHORT $LN401@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN401@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN402@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r13b, 31
	je	SHORT $LN403@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN403@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r13-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r13
	jb	SHORT $LN404@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r13, rax
	cmp	r13, 8
	jae	SHORT $LN405@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN405@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r13, 39					; 00000027H
	jbe	SHORT $LN406@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN406@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r13, rax
$LN402@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r13
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN334@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r14, r14
	je	SHORT $LN443@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR left$[rsp+16]
	sub	rcx, r14
	mov	rax, rbx
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rdx, rdi
	jbe	SHORT $LN510@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN510@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN511@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r14b, 31
	je	SHORT $LN512@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN512@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r14-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r14
	jb	SHORT $LN513@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN513@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r14, rax
	cmp	r14, 8
	jae	SHORT $LN514@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN514@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r14, 39					; 00000027H
	jbe	SHORT $LN515@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN515@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r14, rax
$LN511@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r14
	call	??3@YAXPEAX@Z				; operator delete
$LN443@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 129  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN594@MatMulSpee:
??$MatMulSpeedTest@M$02$02$02$02@@YANXZ ENDP		; MatMulSpeedTest<float,3,3,3,3>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv1922 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 176
?dtor$0@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::~vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$0
tv1922 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 176
?dtor$1@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::~vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1922 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 176
?dtor$0@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::~vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1922 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 176
?dtor$1@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::~vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$02$02$02$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,3,3,3>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$03$03$03$03@@YANXZ
_TEXT	SEGMENT
tv2195 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 192
??$MatMulSpeedTest@M$03$03$03$03@@YANXZ PROC		; MatMulSpeedTest<float,4,4,4,4>, COMDAT

; 88   : double MatMulSpeedTest() {

$LN601:
	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H
	mov	QWORD PTR $T157[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >
	npad	1

; 95   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >
	npad	1

; 96   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r14, QWORD PTR left$[rsp]
	mov	r9, r14

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	rsi, r14
	mov	r13, QWORD PTR right$[rsp]
	sub	rsi, r13
	mov	rbx, r13
	sub	rbx, r14
	mov	rdi, r14
	neg	rdi

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r11d, 100000				; 000186a0H
	npad	13
$LL4@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rcx, QWORD PTR [rbx+8]
	add	rcx, r9
	lea	rax, QWORD PTR [rcx+rsi]
; File c:\home\programming\mathter\main.cpp

; 107  : 				l(x, y) = 2;

	lea	r10, QWORD PTR [rdi+r9]
	mov	rdx, r9
	sub	rdx, r10
	sub	rdx, r14
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	r8d, 4
	npad	2
$LL7@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 107  : 				l(x, y) = 2;

	mov	DWORD PTR [rdx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rdx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H
	mov	DWORD PTR [rax+4], 1073741824		; 40000000H

; 102  : 		LeftT& l = left[i];
; 103  : 		RightT& r = right[i];
; 104  : 
; 105  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	r8, 1
	jne	SHORT $LL7@MatMulSpee

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	rax, rbx
	sub	rax, r10
	sub	rax, r13
	lea	rdx, QWORD PTR [rax+r9]
	lea	r8, QWORD PTR [rax+r9]

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	mov	eax, 4
	npad	3
$LL13@MatMulSpee:

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	DWORD PTR [r8+rcx-8], 1073741824	; 40000000H
	mov	DWORD PTR [rdx+rcx-4], 1073741824	; 40000000H
	mov	DWORD PTR [rcx], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	lea	rcx, QWORD PTR [rcx+16]
	sub	rax, 1
	jne	SHORT $LL13@MatMulSpee

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	add	r9, 64					; 00000040H
	sub	r11, 1
	jne	$LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	lea	r14, QWORD PTR [r13+16]
	lea	r15, QWORD PTR [rsi-12]
	lea	rax, QWORD PTR $T26[rsp]
	sub	rsi, rax
	mov	r12, QWORD PTR result$[rsp]
	mov	rdi, r12
	sub	rdi, r13

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	QWORD PTR tv2195[rsp], 100		; 00000064H
	npad	8
$LL19@MatMulSpee:
	mov	r10, r14
	mov	ebp, 100000				; 000186a0H
	npad	8
$LL22@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rcx, QWORD PTR $T26[rsp]
	mov	edx, 4
	npad	3
$LL130@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm1, XMMWORD PTR [r10-16]
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rsi]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rax+r10-16]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rcx], xmm1

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rcx, QWORD PTR [rcx+16]
	sub	rdx, 1
	jne	SHORT $LL130@MatMulSpee

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR [r15+r10]
	mov	r8, r10
	lea	r11d, QWORD PTR [rdx+3]
	npad	1
$LL133@MatMulSpee:

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T26[rsp]
	mov	rcx, r9
	mov	edx, 4
$LL136@MatMulSpee:

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16
	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL136@MatMulSpee

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	add	r8, 16
	add	r9, 4
	sub	r11, 1
	jne	SHORT $LL133@MatMulSpee
; File c:\home\programming\mathter\main.cpp

; 123  : 			result[i] = left[i] * right[i];

	movaps	xmm0, XMMWORD PTR $T26[rsp]
	movaps	XMMWORD PTR [rdi+r10-16], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+16]
	movaps	XMMWORD PTR [rdi+r10], xmm1
	movaps	xmm0, XMMWORD PTR $T26[rsp+32]
	movaps	XMMWORD PTR [rdi+r10+16], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+48]
	movaps	XMMWORD PTR [rdi+r10+32], xmm1

; 122  : 		for (int i = 0; i < iterationCount; ++i) {

	add	r10, 64					; 00000040H
	sub	rbp, 1
	jne	$LL22@MatMulSpee

; 113  : 			}
; 114  : 		}
; 115  : 	}
; 116  : 
; 117  : 	std::chrono::high_resolution_clock::time_point startTime;
; 118  : 	std::chrono::high_resolution_clock::time_point endTime;
; 119  : 
; 120  : 	startTime = std::chrono::high_resolution_clock::now();
; 121  : 	for (int j = 0; j < 100; ++j) {

	sub	QWORD PTR tv2195[rsp], 1
	lea	r14, QWORD PTR [r13+16]
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, rbx
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 288230376151711743			; 03ffffffffffffffH
	test	r12, r12
	mov	r14, QWORD PTR left$[rsp]
	je	SHORT $LN224@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR result$[rsp+16]
	sub	rax, r12
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN291@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN291@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN292@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r12b, 31
	je	SHORT $LN293@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r12-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r12
	jb	SHORT $LN294@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN294@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r12, rax
	cmp	r12, 8
	jae	SHORT $LN295@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r12, 39					; 00000027H
	jbe	SHORT $LN296@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN296@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r12, rax
$LN292@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r12
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN224@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r13, r13
	je	SHORT $LN334@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR right$[rsp+16]
	sub	rax, r13
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN401@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN401@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN402@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r13b, 31
	je	SHORT $LN403@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN403@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r13-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r13
	jb	SHORT $LN404@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r13, rax
	cmp	r13, 8
	jae	SHORT $LN405@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN405@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r13, 39					; 00000027H
	jbe	SHORT $LN406@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN406@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r13, rax
$LN402@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r13
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN334@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r14, r14
	je	SHORT $LN443@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR left$[rsp+16]
	sub	rax, r14
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN510@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN510@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN511@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r14b, 31
	je	SHORT $LN512@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN512@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r14-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r14
	jb	SHORT $LN513@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN513@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r14, rax
	cmp	r14, 8
	jae	SHORT $LN514@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN514@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r14, 39					; 00000027H
	jbe	SHORT $LN515@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN515@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r14, rax
$LN511@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r14
	call	??3@YAXPEAX@Z				; operator delete
$LN443@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 129  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN600@MatMulSpee:
??$MatMulSpeedTest@M$03$03$03$03@@YANXZ ENDP		; MatMulSpeedTest<float,4,4,4,4>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv2195 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 192
?dtor$0@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::~vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$0
tv2195 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 192
?dtor$1@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::~vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2195 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 192
?dtor$0@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::~vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2195 = 32
left$ = 40
$T157 = 64
result$ = 72
right$ = 96
$T26 = 128
__$ArrayPad$ = 192
?dtor$1@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::~vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$03$03$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,4,4,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$03$01$01$03@@YANXZ
_TEXT	SEGMENT
$T145 = 32
result$ = 40
right$ = 64
left$ = 88
$T25 = 112
__$ArrayPad$ = 128
??$MatMulSpeedTest@M$03$01$01$03@@YANXZ PROC		; MatMulSpeedTest<float,4,2,2,4>, COMDAT

; 88   : double MatMulSpeedTest() {

$LN550:
	mov	rax, rsp
	push	r14
	sub	rsp, 160				; 000000a0H
	mov	QWORD PTR $T145[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >
	npad	1

; 95   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >
	npad	1

; 96   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	rsi, QWORD PTR left$[rsp]
	lea	rdx, QWORD PTR [rsi+8]

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	r14, QWORD PTR right$[rsp]
	mov	rdi, r14
	sub	rdi, rsi

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r10, -8
	sub	r10, rsi
	mov	r9d, 100000				; 000186a0H
	npad	1
$LL4@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	rax, rdx
; File c:\home\programming\mathter\main.cpp

; 107  : 				l(x, y) = 2;

	mov	rcx, -8
	sub	rcx, r10
	sub	rcx, rsi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	r8d, 2
	npad	10
$LL7@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 107  : 				l(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H
	mov	DWORD PTR [rax+4], 1073741824		; 40000000H

; 102  : 		LeftT& l = left[i];
; 103  : 		RightT& r = right[i];
; 104  : 
; 105  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	r8, 1
	jne	SHORT $LL7@MatMulSpee

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	xor	ecx, ecx
	npad	7
$LL13@MatMulSpee:
	lea	rax, QWORD PTR [rdi+rcx*8]

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	DWORD PTR [rax+rdx-8], 1073741824	; 40000000H

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [rdi+rcx*8]

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	DWORD PTR [rax+rdx-4], 1073741824	; 40000000H

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	inc	rcx
	cmp	rcx, 4
	jl	SHORT $LL13@MatMulSpee

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	add	rdx, 32					; 00000020H
	sub	r9, 1
	jne	SHORT $LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	r11d, 100				; 00000064H
	mov	rbp, QWORD PTR result$[rsp]
	npad	15
$LL19@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 122  : 		for (int i = 0; i < iterationCount; ++i) {

	mov	r9, rbp
	mov	rdx, rsi
	mov	r10d, 100000				; 000186a0H
	npad	4
$LL22@MatMulSpee:

; 123  : 			result[i] = left[i] * right[i];

	lea	r8, QWORD PTR [rdx+rdi]
	lea	rcx, QWORD PTR $T25[rsp]
	call	??$?DMM$03$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV?$Matrix@M$03$01$00@@AEBV?$Matrix@M$01$03$00@@@Z ; operator*<float,float,4,2,2,1,1,float,void>
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [r9], xmm0

; 122  : 		for (int i = 0; i < iterationCount; ++i) {

	add	rdx, 32					; 00000020H
	lea	r9, QWORD PTR [r9+16]
	sub	r10, 1
	jne	SHORT $LL22@MatMulSpee

; 113  : 			}
; 114  : 		}
; 115  : 	}
; 116  : 
; 117  : 	std::chrono::high_resolution_clock::time_point startTime;
; 118  : 	std::chrono::high_resolution_clock::time_point endTime;
; 119  : 
; 120  : 	startTime = std::chrono::high_resolution_clock::now();
; 121  : 	for (int j = 0; j < 100; ++j) {

	sub	r11, 1
	jne	SHORT $LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, rbx
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rbp, rbp
	je	SHORT $LN189@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR result$[rsp+16]
	sub	rax, rbp
	sar	rax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rcx, 1152921504606846975		; 0fffffffffffffffH
	cmp	rax, rcx
	jbe	SHORT $LN256@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN256@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN257@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	bpl, 31
	je	SHORT $LN258@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN258@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rbp-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rbp
	jb	SHORT $LN259@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN259@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rbp, rax
	cmp	rbp, 8
	jae	SHORT $LN260@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN260@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rbp, 39					; 00000027H
	jbe	SHORT $LN261@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN261@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rbp, rax
$LN257@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rbp
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN189@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 576460752303423487			; 07ffffffffffffffH
	test	r14, r14
	je	SHORT $LN299@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR right$[rsp+16]
	sub	rax, r14
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN366@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN366@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN367@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r14b, 31
	je	SHORT $LN368@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN368@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r14-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r14
	jb	SHORT $LN369@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN369@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r14, rax
	cmp	r14, 8
	jae	SHORT $LN370@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN370@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r14, 39					; 00000027H
	jbe	SHORT $LN371@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN371@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r14, rax
$LN367@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r14
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN299@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rsi, rsi
	je	SHORT $LN408@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR left$[rsp+16]
	sub	rax, rsi
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN475@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN475@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN476@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	sil, 31
	je	SHORT $LN477@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN477@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rsi-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rsi
	jb	SHORT $LN478@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN478@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rsi, rax
	cmp	rsi, 8
	jae	SHORT $LN479@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN479@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rsi, 39					; 00000027H
	jbe	SHORT $LN480@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN480@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rsi, rax
$LN476@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rsi
	call	??3@YAXPEAX@Z				; operator delete
$LN408@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 129  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r14
	ret	0
$LN549@MatMulSpee:
??$MatMulSpeedTest@M$03$01$01$03@@YANXZ ENDP		; MatMulSpeedTest<float,4,2,2,4>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T145 = 32
result$ = 40
right$ = 64
left$ = 88
$T25 = 112
__$ArrayPad$ = 128
?dtor$0@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::~vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$0
$T145 = 32
result$ = 40
right$ = 64
left$ = 88
$T25 = 112
__$ArrayPad$ = 128
?dtor$1@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::~vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T145 = 32
result$ = 40
right$ = 64
left$ = 88
$T25 = 112
__$ArrayPad$ = 128
?dtor$0@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::~vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T145 = 32
result$ = 40
right$ = 64
left$ = 88
$T25 = 112
__$ArrayPad$ = 128
?dtor$1@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::~vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$01$01$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,2,2,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$01$03$03$01@@YANXZ
_TEXT	SEGMENT
$T157 = 32
result$ = 40
right$ = 64
left$ = 88
$T26 = 112
__$ArrayPad$ = 176
??$MatMulSpeedTest@M$01$03$03$01@@YANXZ PROC		; MatMulSpeedTest<float,2,4,4,2>, COMDAT

; 88   : double MatMulSpeedTest() {

$LN597:
	mov	rax, rsp
	push	r14
	sub	rsp, 208				; 000000d0H
	mov	QWORD PTR $T157[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >
	npad	1

; 95   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >
	npad	1

; 96   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r14, QWORD PTR right$[rsp]
	lea	rdx, QWORD PTR [r14+8]

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	rbp, QWORD PTR left$[rsp]
	mov	r9, rbp
	sub	r9, r14

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r11, -8
	sub	r11, r14
	mov	r10d, 100000				; 000186a0H
	npad	1
$LL4@MatMulSpee:

; 102  : 		LeftT& l = left[i];
; 103  : 		RightT& r = right[i];
; 104  : 
; 105  : 		for (int x = 0; x < Col1; ++x) {

	xor	ecx, ecx
	npad	14
$LL7@MatMulSpee:
	lea	rax, QWORD PTR [r9+rdx]

; 106  : 			for (int y = 0; y < Row1; ++y) {
; 107  : 				l(x, y) = 2;

	mov	DWORD PTR [rax+rcx*8-8], 1073741824	; 40000000H

; 102  : 		LeftT& l = left[i];
; 103  : 		RightT& r = right[i];
; 104  : 
; 105  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [r9+rdx]

; 106  : 			for (int y = 0; y < Row1; ++y) {
; 107  : 				l(x, y) = 2;

	mov	DWORD PTR [rax+rcx*8-4], 1073741824	; 40000000H

; 102  : 		LeftT& l = left[i];
; 103  : 		RightT& r = right[i];
; 104  : 
; 105  : 		for (int x = 0; x < Col1; ++x) {

	inc	rcx
	cmp	rcx, 4
	jl	SHORT $LL7@MatMulSpee

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	mov	rax, rdx

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	rcx, -8
	sub	rcx, r11
	sub	rcx, r14

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	mov	r8d, 2
	npad	9
$LL13@MatMulSpee:

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H
	mov	DWORD PTR [rax+4], 1073741824		; 40000000H

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	r8, 1
	jne	SHORT $LL13@MatMulSpee

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	add	rdx, 32					; 00000020H
	sub	r10, 1
	jne	$LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	mov	r10, r14
	sub	r10, rbp

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	edi, 100				; 00000064H
	mov	rsi, QWORD PTR result$[rsp]
$LL19@MatMulSpee:
	mov	r8, rsi
	mov	rcx, rbp
	mov	r11d, 100000				; 000186a0H
	npad	4
$LL22@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rdx, QWORD PTR $T26[rsp]
	npad	9
$LL130@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm1, XMMWORD PTR [r10+rcx]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx+rax*8]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rdx], xmm1

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	inc	rax
	lea	rdx, QWORD PTR [rdx+16]
	cmp	rax, 4
	jl	SHORT $LL130@MatMulSpee

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T26[rsp]
	lea	rdx, QWORD PTR [rcx+4]
	mov	r9d, 4
$LL136@MatMulSpee:

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [r10+rcx+16]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rdx]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rdx, 8
	add	rax, 16
	sub	r9, 1
	jne	SHORT $LL136@MatMulSpee
; File c:\home\programming\mathter\main.cpp

; 123  : 			result[i] = left[i] * right[i];

	movaps	xmm0, XMMWORD PTR $T26[rsp]
	movaps	XMMWORD PTR [r8], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+16]
	movaps	XMMWORD PTR [r8+16], xmm1
	movaps	xmm0, XMMWORD PTR $T26[rsp+32]
	movaps	XMMWORD PTR [r8+32], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+48]
	movaps	XMMWORD PTR [r8+48], xmm1

; 122  : 		for (int i = 0; i < iterationCount; ++i) {

	add	rcx, 32					; 00000020H
	add	r8, 64					; 00000040H
	sub	r11, 1
	jne	$LL22@MatMulSpee

; 113  : 			}
; 114  : 		}
; 115  : 	}
; 116  : 
; 117  : 	std::chrono::high_resolution_clock::time_point startTime;
; 118  : 	std::chrono::high_resolution_clock::time_point endTime;
; 119  : 
; 120  : 	startTime = std::chrono::high_resolution_clock::now();
; 121  : 	for (int j = 0; j < 100; ++j) {

	sub	rdi, 1
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, rbx
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rsi, rsi
	je	SHORT $LN224@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR result$[rsp+16]
	sub	rax, rsi
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rcx, 288230376151711743			; 03ffffffffffffffH
	cmp	rax, rcx
	jbe	SHORT $LN291@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN291@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN292@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	sil, 31
	je	SHORT $LN293@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rsi-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rsi
	jb	SHORT $LN294@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN294@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rsi, rax
	cmp	rsi, 8
	jae	SHORT $LN295@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rsi, 39					; 00000027H
	jbe	SHORT $LN296@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN296@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rsi, rax
$LN292@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rsi
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN224@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 576460752303423487			; 07ffffffffffffffH
	test	r14, r14
	je	SHORT $LN334@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR right$[rsp+16]
	sub	rax, r14
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN401@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN401@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN402@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r14b, 31
	je	SHORT $LN403@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN403@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r14-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r14
	jb	SHORT $LN404@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r14, rax
	cmp	r14, 8
	jae	SHORT $LN405@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN405@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r14, 39					; 00000027H
	jbe	SHORT $LN406@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN406@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r14, rax
$LN402@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r14
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN334@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rbp, rbp
	je	SHORT $LN443@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR left$[rsp+16]
	sub	rax, rbp
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN510@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN510@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN511@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	bpl, 31
	je	SHORT $LN512@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN512@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rbp-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rbp
	jb	SHORT $LN513@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN513@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rbp, rax
	cmp	rbp, 8
	jae	SHORT $LN514@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN514@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rbp, 39					; 00000027H
	jbe	SHORT $LN515@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN515@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rbp, rax
$LN511@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rbp
	call	??3@YAXPEAX@Z				; operator delete
$LN443@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 129  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r14
	ret	0
$LN596@MatMulSpee:
??$MatMulSpeedTest@M$01$03$03$01@@YANXZ ENDP		; MatMulSpeedTest<float,2,4,4,2>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T157 = 32
result$ = 40
right$ = 64
left$ = 88
$T26 = 112
__$ArrayPad$ = 176
?dtor$0@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::~vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$0
$T157 = 32
result$ = 40
right$ = 64
left$ = 88
$T26 = 112
__$ArrayPad$ = 176
?dtor$1@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::~vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T157 = 32
result$ = 40
right$ = 64
left$ = 88
$T26 = 112
__$ArrayPad$ = 176
?dtor$0@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::~vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T157 = 32
result$ = 40
right$ = 64
left$ = 88
$T26 = 112
__$ArrayPad$ = 176
?dtor$1@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::~vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$01$03$03$01@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,2,4,4,2>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$03$02$02$03@@YANXZ
_TEXT	SEGMENT
tv1997 = 32
tv2001 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 192
??$MatMulSpeedTest@M$03$02$02$03@@YANXZ PROC		; MatMulSpeedTest<float,4,3,3,4>, COMDAT

; 88   : double MatMulSpeedTest() {

$LN598:
	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H
	mov	QWORD PTR $T157[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >
	npad	1

; 95   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >
	npad	1

; 96   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r15, QWORD PTR right$[rsp]
	mov	r8, r15
	mov	r12, QWORD PTR left$[rsp]
	mov	r9, r12

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	r11, r12
	neg	r11
	mov	rbx, r15
	neg	rbx

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r10d, 100000				; 000186a0H
$LL4@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rax, QWORD PTR [r9+8]
; File c:\home\programming\mathter\main.cpp

; 107  : 				l(x, y) = 2;

	lea	rcx, QWORD PTR [r11+r12]
	neg	rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	edx, 3
$LL7@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 107  : 				l(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H
	mov	DWORD PTR [rax+4], 1073741824		; 40000000H

; 102  : 		LeftT& l = left[i];
; 103  : 		RightT& r = right[i];
; 104  : 
; 105  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	rdx, 1
	jne	SHORT $LL7@MatMulSpee

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [r8+8]

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	lea	rcx, QWORD PTR [rbx+r15]
	neg	rcx

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	mov	edx, 4
	npad	9
$LL13@MatMulSpee:

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	rdx, 1
	jne	SHORT $LL13@MatMulSpee

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	add	r9, 48					; 00000030H
	add	r8, 64					; 00000040H
	sub	r10, 1
	jne	SHORT $LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	mov	QWORD PTR startTime$1$[rsp], rbx
	lea	rcx, QWORD PTR $T26[rsp]
	mov	rax, r12
	sub	rax, rcx
	mov	QWORD PTR tv2001[rsp], rax
	lea	rbx, QWORD PTR [r12+4]

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	QWORD PTR tv1997[rsp], 100		; 00000064H
	mov	r13, QWORD PTR result$[rsp]
	mov	r12, rax
	npad	9
$LL19@MatMulSpee:
	mov	rsi, r13
	mov	r11, r15
	mov	rdi, r12
	mov	rbp, rbx
	mov	r14d, 100000				; 000186a0H
$LL22@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rax, QWORD PTR $T26[rsp]
	mov	ecx, 3
	npad	1
$LL130@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm1, XMMWORD PTR [r11]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rdi+rax]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rax], xmm1

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR [rax+16]
	sub	rcx, 1
	jne	SHORT $LL130@MatMulSpee

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	mov	r9, rbp
	lea	rdx, QWORD PTR [r11+16]
	lea	r10d, QWORD PTR [rcx+3]
	npad	8
$LL133@MatMulSpee:

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T26[rsp]
	mov	rcx, r9
	mov	r8d, 3
$LL136@MatMulSpee:

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 404  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16
	add	rax, 16
	sub	r8, 1
	jne	SHORT $LL136@MatMulSpee

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	add	rdx, 16
	add	r9, 4
	sub	r10, 1
	jne	SHORT $LL133@MatMulSpee
; File c:\home\programming\mathter\main.cpp

; 123  : 			result[i] = left[i] * right[i];

	movaps	xmm0, XMMWORD PTR $T26[rsp]
	movaps	XMMWORD PTR [rsi], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+16]
	movaps	XMMWORD PTR [rsi+16], xmm1
	movaps	xmm0, XMMWORD PTR $T26[rsp+32]
	movaps	XMMWORD PTR [rsi+32], xmm0

; 122  : 		for (int i = 0; i < iterationCount; ++i) {

	add	r11, 64					; 00000040H
	add	rbp, 48					; 00000030H
	add	rdi, 48					; 00000030H
	add	rsi, 48					; 00000030H
	sub	r14, 1
	jne	$LL22@MatMulSpee

; 113  : 			}
; 114  : 		}
; 115  : 	}
; 116  : 
; 117  : 	std::chrono::high_resolution_clock::time_point startTime;
; 118  : 	std::chrono::high_resolution_clock::time_point endTime;
; 119  : 
; 120  : 	startTime = std::chrono::high_resolution_clock::now();
; 121  : 	for (int j = 0; j < 100; ++j) {

	sub	QWORD PTR tv1997[rsp], 1
	mov	r12, QWORD PTR tv2001[rsp]
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, QWORD PTR startTime$1$[rsp]
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rdi, 384307168202282325			; 0555555555555555H
	test	r13, r13
	mov	r12, QWORD PTR left$[rsp]
	je	SHORT $LN224@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR result$[rsp+16]
	sub	rcx, r13
	mov	rax, rbx
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rdx, rdi
	jbe	SHORT $LN291@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN291@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN292@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r13b, 31
	je	SHORT $LN293@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r13-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r13
	jb	SHORT $LN294@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN294@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r13, rax
	cmp	r13, 8
	jae	SHORT $LN295@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r13, 39					; 00000027H
	jbe	SHORT $LN296@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN296@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r13, rax
$LN292@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r13
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN224@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r15, r15
	je	SHORT $LN334@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR right$[rsp+16]
	sub	rax, r15
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rcx, 288230376151711743			; 03ffffffffffffffH
	cmp	rax, rcx
	jbe	SHORT $LN401@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN401@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN402@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r15b, 31
	je	SHORT $LN403@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN403@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r15-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r15
	jb	SHORT $LN404@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r15, rax
	cmp	r15, 8
	jae	SHORT $LN405@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN405@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r15, 39					; 00000027H
	jbe	SHORT $LN406@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN406@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r15, rax
$LN402@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r15
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN334@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r12, r12
	je	SHORT $LN443@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR left$[rsp+16]
	sub	rcx, r12
	mov	rax, rbx
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rdx, rdi
	jbe	SHORT $LN510@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN510@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN511@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r12b, 31
	je	SHORT $LN512@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN512@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r12-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r12
	jb	SHORT $LN513@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN513@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r12, rax
	cmp	r12, 8
	jae	SHORT $LN514@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN514@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r12, 39					; 00000027H
	jbe	SHORT $LN515@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN515@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r12, rax
$LN511@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r12
	call	??3@YAXPEAX@Z				; operator delete
$LN443@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 129  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN597@MatMulSpee:
??$MatMulSpeedTest@M$03$02$02$03@@YANXZ ENDP		; MatMulSpeedTest<float,4,3,3,4>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv1997 = 32
tv2001 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 192
?dtor$0@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::~vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$0
tv1997 = 32
tv2001 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 192
?dtor$1@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::~vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1997 = 32
tv2001 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 192
?dtor$0@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::~vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv1997 = 32
tv2001 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 192
?dtor$1@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::~vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$03$02$02$03@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,4,3,3,4>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
; File c:\home\programming\mathter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\home\programming\mathter\main.cpp
;	COMDAT ??$MatMulSpeedTest@M$02$03$03$02@@YANXZ
_TEXT	SEGMENT
tv2014 = 32
tv2017 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 208
??$MatMulSpeedTest@M$02$03$03$02@@YANXZ PROC		; MatMulSpeedTest<float,3,4,4,3>, COMDAT

; 88   : double MatMulSpeedTest() {

$LN598:
	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 240				; 000000f0H
	mov	QWORD PTR $T157[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	lea	rcx, QWORD PTR left$[rsp]
	call	??0?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >
	npad	1

; 95   : 	std::vector<RightT> right(iterationCount);

	lea	rcx, QWORD PTR right$[rsp]
	call	??0?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >
	npad	1

; 96   : 	std::vector<ResultT> result(iterationCount);

	lea	rcx, QWORD PTR result$[rsp]
	call	??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r15, QWORD PTR right$[rsp]
	mov	r8, r15
	mov	r12, QWORD PTR left$[rsp]
	mov	r9, r12

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	mov	r11, r12
	neg	r11
	mov	rbx, r15
	neg	rbx

; 89   : 	using LeftT = Matrix<T, Col1, Row1>;
; 90   : 	using RightT = Matrix<T, Col2, Row2>;
; 91   : 	using ResultT = typename decltype(LeftT()*RightT());
; 92   : 
; 93   : 	constexpr int iterationCount = 100'000;
; 94   : 	std::vector<LeftT> left(iterationCount);

	mov	r10d, 100000				; 000186a0H
$LL4@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rax, QWORD PTR [r9+8]
; File c:\home\programming\mathter\main.cpp

; 107  : 				l(x, y) = 2;

	lea	rcx, QWORD PTR [r11+r12]
	neg	rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	edx, 4
$LL7@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 107  : 				l(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H

; 102  : 		LeftT& l = left[i];
; 103  : 		RightT& r = right[i];
; 104  : 
; 105  : 		for (int x = 0; x < Col1; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	rdx, 1
	jne	SHORT $LL7@MatMulSpee

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [r8+8]

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	lea	rcx, QWORD PTR [rbx+r15]
	neg	rcx

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	mov	edx, 3
$LL13@MatMulSpee:

; 111  : 			for (int y = 0; y < Row2; ++y) {
; 112  : 				r(x, y) = 2;

	mov	DWORD PTR [rcx+rax-8], 1073741824	; 40000000H
	mov	DWORD PTR [rcx+rax-4], 1073741824	; 40000000H
	mov	DWORD PTR [rax], 1073741824		; 40000000H
	mov	DWORD PTR [rax+4], 1073741824		; 40000000H

; 108  : 			}
; 109  : 		}
; 110  : 		for (int x = 0; x < Col2; ++x) {

	lea	rax, QWORD PTR [rax+16]
	sub	rdx, 1
	jne	SHORT $LL13@MatMulSpee

; 97   : 
; 98   : 	std::minstd_rand rne;
; 99   : 	std::uniform_real_distribution<T> rng;
; 100  : 
; 101  : 	for (int i = 0; i < iterationCount; ++i) {

	add	r9, 64					; 00000040H
	add	r8, 48					; 00000030H
	sub	r10, 1
	jne	SHORT $LL4@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	lea	rbx, QWORD PTR [rax+rcx]
	mov	QWORD PTR startTime$1$[rsp], rbx
	lea	rcx, QWORD PTR $T26[rsp]
	mov	rax, r12
	sub	rax, rcx
	mov	QWORD PTR tv2017[rsp], rax
	lea	rbx, QWORD PTR [r12+4]

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	mov	QWORD PTR tv2014[rsp], 100		; 00000064H
	mov	r13, QWORD PTR result$[rsp]
	mov	r12, rax
	npad	2
$LL19@MatMulSpee:
	mov	rdi, r13
	mov	r11, r15
	mov	rsi, r12
	mov	rbp, rbx
	mov	r14d, 100000				; 000186a0H
$LL22@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rax, QWORD PTR $T26[rsp]
	mov	ecx, 4
	npad	1
$LL130@MatMulSpee:
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm1, XMMWORD PTR [r11]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rsi+rax]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rax], xmm1

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR [rax+16]
	sub	rcx, 1
	jne	SHORT $LL130@MatMulSpee

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	mov	r9, rbp
	lea	rdx, QWORD PTR [r11+16]
	lea	r10d, QWORD PTR [rcx+2]
	npad	8
$LL133@MatMulSpee:

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR $T26[rsp]
	mov	rcx, r9
	mov	r8d, 4
$LL136@MatMulSpee:

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16
	add	rax, 16
	sub	r8, 1
	jne	SHORT $LL136@MatMulSpee

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	add	rdx, 16
	add	r9, 4
	sub	r10, 1
	jne	SHORT $LL133@MatMulSpee
; File c:\home\programming\mathter\main.cpp

; 123  : 			result[i] = left[i] * right[i];

	movaps	xmm0, XMMWORD PTR $T26[rsp]
	movaps	XMMWORD PTR [rdi], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+16]
	movaps	XMMWORD PTR [rdi+16], xmm1
	movaps	xmm0, XMMWORD PTR $T26[rsp+32]
	movaps	XMMWORD PTR [rdi+32], xmm0
	movaps	xmm1, XMMWORD PTR $T26[rsp+48]
	movaps	XMMWORD PTR [rdi+48], xmm1

; 122  : 		for (int i = 0; i < iterationCount; ++i) {

	add	r11, 48					; 00000030H
	add	rbp, 64					; 00000040H
	add	rsi, 64					; 00000040H
	add	rdi, 64					; 00000040H
	sub	r14, 1
	jne	$LL22@MatMulSpee

; 113  : 			}
; 114  : 		}
; 115  : 	}
; 116  : 
; 117  : 	std::chrono::high_resolution_clock::time_point startTime;
; 118  : 	std::chrono::high_resolution_clock::time_point endTime;
; 119  : 
; 120  : 	startTime = std::chrono::high_resolution_clock::now();
; 121  : 	for (int j = 0; j < 100; ++j) {

	sub	QWORD PTR tv2014[rsp], 1
	mov	r12, QWORD PTR tv2017[rsp]
	jne	$LL19@MatMulSpee
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono

; 999  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 1000 : 		const long long _Ctr = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 1001 : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 1002 : 		const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rdi
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 1003 : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 1004 : 		return (time_point(duration(_Whole + _Part)));

	add	rcx, rax

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sub	rcx, QWORD PTR startTime$1$[rsp]
	xorps	xmm6, xmm6
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	cvtsi2sd xmm6, rcx
	mulsd	xmm6, QWORD PTR __real@3e112e0be826d695
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, 288230376151711743			; 03ffffffffffffffH
	test	r13, r13
	mov	r12, QWORD PTR left$[rsp]
	je	SHORT $LN224@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR result$[rsp+16]
	sub	rax, r13
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN291@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN291@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN292@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r13b, 31
	je	SHORT $LN293@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r13-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r13
	jb	SHORT $LN294@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN294@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r13, rax
	cmp	r13, 8
	jae	SHORT $LN295@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r13, 39					; 00000027H
	jbe	SHORT $LN296@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN296@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r13, rax
$LN292@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r13
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN224@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r15, r15
	je	$LN334@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rcx, QWORD PTR right$[rsp+16]
	sub	rcx, r15
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	rdx, rax
	jbe	SHORT $LN401@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN401@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN402@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r15b, 31
	je	SHORT $LN403@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN403@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r15-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r15
	jb	SHORT $LN404@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r15, rax
	cmp	r15, 8
	jae	SHORT $LN405@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN405@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r15, 39					; 00000027H
	jbe	SHORT $LN406@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN406@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r15, rax
$LN402@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r15
	call	??3@YAXPEAX@Z				; operator delete
	npad	1
$LN334@MatMulSpee:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r12, r12
	je	SHORT $LN443@MatMulSpee

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR left$[rsp+16]
	sub	rax, r12
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbx
	jbe	SHORT $LN510@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN510@MatMulSpee:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN511@MatMulSpee

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r12b, 31
	je	SHORT $LN512@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN512@MatMulSpee:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r12-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r12
	jb	SHORT $LN513@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN513@MatMulSpee:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r12, rax
	cmp	r12, 8
	jae	SHORT $LN514@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN514@MatMulSpee:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r12, 39					; 00000027H
	jbe	SHORT $LN515@MatMulSpee
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN515@MatMulSpee:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r12, rax
$LN511@MatMulSpee:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r12
	call	??3@YAXPEAX@Z				; operator delete
$LN443@MatMulSpee:
; File c:\home\programming\mathter\main.cpp

; 128  : 	return chrono::duration_cast<chrono::nanoseconds>(endTime - startTime).count() * 1e-9;

	movaps	xmm0, xmm6

; 129  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+240]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN597@MatMulSpee:
??$MatMulSpeedTest@M$02$03$03$02@@YANXZ ENDP		; MatMulSpeedTest<float,3,4,4,3>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
tv2014 = 32
tv2017 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 208
?dtor$0@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::~vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$0
tv2014 = 32
tv2017 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 208
?dtor$1@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::~vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2014 = 32
tv2017 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 208
?dtor$0@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$0
	lea	rcx, QWORD PTR left$[rdx]
	jmp	??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::~vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >
?dtor$0@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2014 = 32
tv2017 = 40
startTime$1$ = 48
left$ = 56
$T157 = 80
result$ = 88
right$ = 112
$T26 = 144
__$ArrayPad$ = 208
?dtor$1@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA PROC ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$1
	lea	rcx, QWORD PTR right$[rdx]
	jmp	??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::~vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >
?dtor$1@?0???$MatMulSpeedTest@M$02$03$03$02@@YANXZ@4HA ENDP ; `MatMulSpeedTest<float,3,4,4,3>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$02$03$00@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$02$03$00@@_K@Z PROC ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::operator[], COMDAT

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	shl	rdx, 6
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1243 : 		}

	ret	0
??A?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$02$03$00@@_K@Z ENDP ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ PROC ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::~vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >, COMDAT

; 975  : 		{	// destroy the object

$LN111:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdx, 288230376151711743			; 03ffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	rax, rcx
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdx
	jbe	SHORT $LN71@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@vector:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN72@vector

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN73@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@vector:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN74@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@vector:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN75@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN75@vector:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN76@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN76@vector:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN72@vector:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 976  : 		_Tidy();
; 977  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN110@vector:
??1?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::~vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
??0?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@_K@Z PROC ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >, COMDAT

; 717  : 		{	// construct from _Count * value_type()

$LN270:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax

; 717  : 		{	// construct from _Count * value_type()

	mov	rbx, rcx

; 1562 : 		this->_Myfirst() = pointer();

	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 6400039				; 0061a827H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 6400000				; 0061a800H
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$03$00@@_KV?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,3,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,4,1> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 723  : 			this->_Mylast() += _Count;

	add	QWORD PTR [rbx+8], 6400000		; 0061a800H

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@_K@Z ENDP ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$02$00@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$02$00@@_K@Z PROC ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::operator[], COMDAT

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4
	add	rax, QWORD PTR [rcx]

; 1243 : 		}

	ret	0
??A?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$02$00@@_K@Z ENDP ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ PROC ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::~vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >, COMDAT

; 975  : 		{	// destroy the object

$LN111:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	$LN4@vector

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rdx, QWORD PTR [rbx+16]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, rcx
	imul	rdx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	rdx, rax
	jbe	SHORT $LN71@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@vector:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN72@vector

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN73@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@vector:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN74@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@vector:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN75@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN75@vector:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN76@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN76@vector:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN72@vector:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 976  : 		_Tidy();
; 977  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN110@vector:
??1?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::~vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
??0?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@_K@Z PROC ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >, COMDAT

; 717  : 		{	// construct from _Count * value_type()

$LN165:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax

; 717  : 		{	// construct from _Count * value_type()

	mov	rbx, rcx

; 1562 : 		this->_Myfirst() = pointer();

	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 4800039				; 00493e27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 4800000				; 00493e00H
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$02$00@@_KV?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,4,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,3,1> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 723  : 			this->_Mylast() += _Count;

	add	QWORD PTR [rbx+8], 4800000		; 00493e00H

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@_K@Z ENDP ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$02$03$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$02$03$00@@QEAAAEAMHH@Z PROC		; Matrix<float,3,4,1>::operator(), COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d

; 107  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*4]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 108  : 	}

	ret	0
??R?$Matrix@M$02$03$00@@QEAAAEAMHH@Z ENDP		; Matrix<float,3,4,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$03$02$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$03$02$00@@QEAAAEAMHH@Z PROC		; Matrix<float,4,3,1>::operator(), COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d

; 107  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*4]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 108  : 	}

	ret	0
??R?$Matrix@M$03$02$00@@QEAAAEAMHH@Z ENDP		; Matrix<float,4,3,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$01$03$00@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$01$03$00@@_K@Z PROC ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::operator[], COMDAT

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	shl	rdx, 5
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1243 : 		}

	ret	0
??A?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$01$03$00@@_K@Z ENDP ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ PROC ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::~vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >, COMDAT

; 975  : 		{	// destroy the object

$LN111:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdx, 576460752303423487			; 07ffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	rax, rcx
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdx
	jbe	SHORT $LN71@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@vector:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN72@vector

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN73@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@vector:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN74@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@vector:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN75@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN75@vector:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN76@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN76@vector:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN72@vector:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 976  : 		_Tidy();
; 977  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN110@vector:
??1?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::~vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
??0?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@_K@Z PROC ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >, COMDAT

; 717  : 		{	// construct from _Count * value_type()

$LN270:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax

; 717  : 		{	// construct from _Count * value_type()

	mov	rbx, rcx

; 1562 : 		this->_Myfirst() = pointer();

	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 3200039				; 0030d427H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 3200000				; 0030d400H
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$03$00@@_KV?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,2,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,4,1> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 723  : 			this->_Mylast() += _Count;

	add	QWORD PTR [rbx+8], 3200000		; 0030d400H

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@_K@Z ENDP ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$01$00@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$01$00@@_K@Z PROC ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::operator[], COMDAT

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	shl	rdx, 5
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1243 : 		}

	ret	0
??A?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$01$00@@_K@Z ENDP ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ PROC ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::~vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >, COMDAT

; 975  : 		{	// destroy the object

$LN111:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdx, 576460752303423487			; 07ffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	rax, rcx
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdx
	jbe	SHORT $LN71@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@vector:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN72@vector

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN73@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@vector:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN74@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@vector:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN75@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN75@vector:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN76@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN76@vector:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN72@vector:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 976  : 		_Tidy();
; 977  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN110@vector:
??1?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::~vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
??0?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@_K@Z PROC ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >, COMDAT

; 717  : 		{	// construct from _Count * value_type()

$LN270:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax

; 717  : 		{	// construct from _Count * value_type()

	mov	rbx, rcx

; 1562 : 		this->_Myfirst() = pointer();

	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 3200039				; 0030d427H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 3200000				; 0030d400H
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$01$00@@_KV?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,4,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,2,1> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 723  : 			this->_Mylast() += _Count;

	add	QWORD PTR [rbx+8], 3200000		; 0030d400H

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@_K@Z ENDP ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$03$00@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$03$00@@_K@Z PROC ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::operator[], COMDAT

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	shl	rdx, 6
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1243 : 		}

	ret	0
??A?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAAEAV?$Matrix@M$03$03$00@@_K@Z ENDP ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ PROC ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::~vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >, COMDAT

; 975  : 		{	// destroy the object

$LN111:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdx, 288230376151711743			; 03ffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	rax, rcx
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdx
	jbe	SHORT $LN71@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@vector:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN72@vector

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN73@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@vector:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN74@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@vector:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN75@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN75@vector:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN76@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN76@vector:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN72@vector:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 976  : 		_Tidy();
; 977  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN110@vector:
??1?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::~vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z PROC ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >, COMDAT

; 717  : 		{	// construct from _Count * value_type()

$LN270:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax

; 717  : 		{	// construct from _Count * value_type()

	mov	rbx, rcx

; 1562 : 		this->_Myfirst() = pointer();

	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 6400039				; 0061a827H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 6400000				; 0061a800H
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$03$00@@_KV?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,4,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,4,1> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 723  : 			this->_Mylast() += _Count;

	add	QWORD PTR [rbx+8], 6400000		; 0061a800H

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@_K@Z ENDP ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAAEAV?$Matrix@M$02$02$00@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAAEAV?$Matrix@M$02$02$00@@_K@Z PROC ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::operator[], COMDAT

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4
	add	rax, QWORD PTR [rcx]

; 1243 : 		}

	ret	0
??A?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAAEAV?$Matrix@M$02$02$00@@_K@Z ENDP ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ PROC ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::~vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >, COMDAT

; 975  : 		{	// destroy the object

$LN111:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	$LN4@vector

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rdx, QWORD PTR [rbx+16]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, rcx
	imul	rdx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	rdx, rax
	jbe	SHORT $LN71@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@vector:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN72@vector

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN73@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@vector:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN74@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@vector:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN75@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN75@vector:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN76@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN76@vector:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN72@vector:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 976  : 		_Tidy();
; 977  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN110@vector:
??1?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::~vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z PROC ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >, COMDAT

; 717  : 		{	// construct from _Count * value_type()

$LN165:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax

; 717  : 		{	// construct from _Count * value_type()

	mov	rbx, rcx

; 1562 : 		this->_Myfirst() = pointer();

	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 4800039				; 00493e27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 4800000				; 00493e00H
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$02$00@@_KV?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,3,1> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 723  : 			this->_Mylast() += _Count;

	add	QWORD PTR [rbx+8], 4800000		; 00493e00H

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@_K@Z ENDP ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\random
;	COMDAT ??0?$uniform_real_distribution@M@std@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
??0?$uniform_real_distribution@M@std@@QEAA@MM@Z PROC	; std::uniform_real_distribution<float>::uniform_real_distribution<float>, COMDAT

; 3252 : 			_Min = _Min0;

	movss	DWORD PTR [rcx], xmm1

; 3405 : 		}

	mov	rax, rcx

; 3253 : 			_Max = _Max0;

	movss	DWORD PTR [rcx+4], xmm2

; 3405 : 		}

	ret	0
??0?$uniform_real_distribution@M@std@@QEAA@MM@Z ENDP	; std::uniform_real_distribution<float>::uniform_real_distribution<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAAEAV?$Matrix@M$01$01$00@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAAEAV?$Matrix@M$01$01$00@@_K@Z PROC ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::operator[], COMDAT

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	shl	rdx, 4
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1243 : 		}

	ret	0
??A?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAAEAV?$Matrix@M$01$01$00@@_K@Z ENDP ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ PROC ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::~vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >, COMDAT

; 975  : 		{	// destroy the object

$LN111:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdx, 1152921504606846975		; 0fffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	rax, rcx
	sar	rax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdx
	jbe	SHORT $LN71@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@vector:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN72@vector

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN73@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@vector:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN74@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@vector:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN75@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN75@vector:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN76@vector
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN76@vector:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN72@vector:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 976  : 		_Tidy();
; 977  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN110@vector:
??1?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::~vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z PROC ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >, COMDAT

; 717  : 		{	// construct from _Count * value_type()

$LN270:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax

; 717  : 		{	// construct from _Count * value_type()

	mov	rbx, rcx

; 1562 : 		this->_Myfirst() = pointer();

	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 1600039				; 00186a27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 1600000				; 00186a00H
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$01$00@@_KV?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,2,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,2,1> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 723  : 			this->_Mylast() += _Count;

	add	QWORD PTR [rbx+8], 1600000		; 00186a00H

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@_K@Z ENDP ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Height@?$MatrixData@M$01$01$00@@QEBAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?Height@?$MatrixData@M$01$01$00@@QEBAHXZ PROC		; MatrixData<float,2,2,1>::Height, COMDAT

; 30   : 		return Rows;

	mov	eax, 2

; 31   : 	}

	ret	0
?Height@?$MatrixData@M$01$01$00@@QEBAHXZ ENDP		; MatrixData<float,2,2,1>::Height
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Width@?$MatrixData@M$01$01$00@@QEBAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?Width@?$MatrixData@M$01$01$00@@QEBAHXZ PROC		; MatrixData<float,2,2,1>::Width, COMDAT

; 27   : 		return Columns;

	mov	eax, 2

; 28   : 	}

	ret	0
?Width@?$MatrixData@M$01$01$00@@QEBAHXZ ENDP		; MatrixData<float,2,2,1>::Width
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$01$01$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$01$01$00@@QEBAMHH@Z PROC			; Matrix<float,2,2,1>::operator(), COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 110  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*2]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 111  : 	}

	ret	0
??R?$Matrix@M$01$01$00@@QEBAMHH@Z ENDP			; Matrix<float,2,2,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$01$01$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$01$01$00@@QEAAAEAMHH@Z PROC		; Matrix<float,2,2,1>::operator(), COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d

; 107  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*2]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 108  : 	}

	ret	0
??R?$Matrix@M$01$01$00@@QEAAAEAMHH@Z ENDP		; Matrix<float,2,2,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?mul@?$VectorSpec@M$01@@IEAAXM@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
?mul@?$VectorSpec@M$01@@IEAAXM@Z PROC			; VectorSpec<float,2>::mul, COMDAT

; 174  : 		this->x *= rhs;

	movaps	xmm0, xmm1

; 175  : 		this->y *= rhs;

	mulss	xmm1, DWORD PTR [rcx+4]
	mulss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [rcx+4], xmm1
	movss	DWORD PTR [rcx], xmm0

; 176  : 	}

	ret	0
?mul@?$VectorSpec@M$01@@IEAAXM@Z ENDP			; VectorSpec<float,2>::mul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?add@?$VectorSpec@M$01@@IEAAXAEBV1@@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
?add@?$VectorSpec@M$01@@IEAAXAEBV1@@Z PROC		; VectorSpec<float,2>::add, COMDAT

; 164  : 		this->x += rhs.x;

	movss	xmm0, DWORD PTR [rdx]

; 165  : 		this->y += rhs.y;

	movss	xmm1, DWORD PTR [rdx+4]
	addss	xmm0, DWORD PTR [rcx]
	addss	xmm1, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 166  : 	}

	ret	0
?add@?$VectorSpec@M$01@@IEAAXAEBV1@@Z ENDP		; VectorSpec<float,2>::add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Height@?$MatrixData@M$01$03$00@@QEBAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?Height@?$MatrixData@M$01$03$00@@QEBAHXZ PROC		; MatrixData<float,2,4,1>::Height, COMDAT

; 30   : 		return Rows;

	mov	eax, 4

; 31   : 	}

	ret	0
?Height@?$MatrixData@M$01$03$00@@QEBAHXZ ENDP		; MatrixData<float,2,4,1>::Height
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Width@?$MatrixData@M$01$03$00@@QEBAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?Width@?$MatrixData@M$01$03$00@@QEBAHXZ PROC		; MatrixData<float,2,4,1>::Width, COMDAT

; 27   : 		return Columns;

	mov	eax, 2

; 28   : 	}

	ret	0
?Width@?$MatrixData@M$01$03$00@@QEBAHXZ ENDP		; MatrixData<float,2,4,1>::Width
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$01$03$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$01$03$00@@QEBAMHH@Z PROC			; Matrix<float,2,4,1>::operator(), COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 110  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*2]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 111  : 	}

	ret	0
??R?$Matrix@M$01$03$00@@QEBAMHH@Z ENDP			; Matrix<float,2,4,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Height@?$MatrixData@M$03$01$00@@QEBAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?Height@?$MatrixData@M$03$01$00@@QEBAHXZ PROC		; MatrixData<float,4,2,1>::Height, COMDAT

; 30   : 		return Rows;

	mov	eax, 2

; 31   : 	}

	ret	0
?Height@?$MatrixData@M$03$01$00@@QEBAHXZ ENDP		; MatrixData<float,4,2,1>::Height
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Width@?$MatrixData@M$03$01$00@@QEBAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?Width@?$MatrixData@M$03$01$00@@QEBAHXZ PROC		; MatrixData<float,4,2,1>::Width, COMDAT

; 27   : 		return Columns;

	mov	eax, 4

; 28   : 	}

	ret	0
?Width@?$MatrixData@M$03$01$00@@QEBAHXZ ENDP		; MatrixData<float,4,2,1>::Width
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$03$01$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$03$01$00@@QEBAMHH@Z PROC			; Matrix<float,4,2,1>::operator(), COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 110  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*4]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 111  : 	}

	ret	0
??R?$Matrix@M$03$01$00@@QEBAMHH@Z ENDP			; Matrix<float,4,2,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Height@?$MatrixData@M$02$02$00@@QEBAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?Height@?$MatrixData@M$02$02$00@@QEBAHXZ PROC		; MatrixData<float,3,3,1>::Height, COMDAT

; 30   : 		return Rows;

	mov	eax, 3

; 31   : 	}

	ret	0
?Height@?$MatrixData@M$02$02$00@@QEBAHXZ ENDP		; MatrixData<float,3,3,1>::Height
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Width@?$MatrixData@M$02$02$00@@QEBAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?Width@?$MatrixData@M$02$02$00@@QEBAHXZ PROC		; MatrixData<float,3,3,1>::Width, COMDAT

; 27   : 		return Columns;

	mov	eax, 3

; 28   : 	}

	ret	0
?Width@?$MatrixData@M$02$02$00@@QEBAHXZ ENDP		; MatrixData<float,3,3,1>::Width
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Height@?$MatrixData@M$03$03$00@@QEBAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?Height@?$MatrixData@M$03$03$00@@QEBAHXZ PROC		; MatrixData<float,4,4,1>::Height, COMDAT

; 30   : 		return Rows;

	mov	eax, 4

; 31   : 	}

	ret	0
?Height@?$MatrixData@M$03$03$00@@QEBAHXZ ENDP		; MatrixData<float,4,4,1>::Height
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?Width@?$MatrixData@M$03$03$00@@QEBAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?Width@?$MatrixData@M$03$03$00@@QEBAHXZ PROC		; MatrixData<float,4,4,1>::Width, COMDAT

; 27   : 		return Columns;

	mov	eax, 4

; 28   : 	}

	ret	0
?Width@?$MatrixData@M$03$03$00@@QEBAHXZ ENDP		; MatrixData<float,4,4,1>::Width
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$03$03$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$03$03$00@@QEBAMHH@Z PROC			; Matrix<float,4,4,1>::operator(), COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 110  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*4]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 111  : 	}

	ret	0
??R?$Matrix@M$03$03$00@@QEBAMHH@Z ENDP			; Matrix<float,4,4,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$02$02$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$02$02$00@@QEBAMHH@Z PROC			; Matrix<float,3,3,1>::operator(), COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 110  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*4]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 111  : 	}

	ret	0
??R?$Matrix@M$02$02$00@@QEBAMHH@Z ENDP			; Matrix<float,3,3,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??X?$Vector@M$03@@QEAAAEAV0@AEBV0@@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
??X?$Vector@M$03@@QEAAAEAV0@AEBV0@@Z PROC		; Vector<float,4>::operator*=, COMDAT
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\vector.hpp

; 747  : 		return *this;

	mov	rax, rcx
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 13   : 		res.reg = _mm_mul_ps(lhs.reg, rhs.reg);

	mulps	xmm0, XMMWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\vector.hpp

; 458  : 		simd = Simd4f::mul(simd, rhs.simd);

	movaps	XMMWORD PTR [rcx], xmm0

; 748  : 	}

	ret	0
??X?$Vector@M$03@@QEAAAEAV0@AEBV0@@Z ENDP		; Vector<float,4>::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??R?$Vector@M$03@@QEBAMH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??R?$Vector@M$03@@QEBAMH@Z PROC				; Vector<float,4>::operator(), COMDAT

; 688  : 		return data[idx];

	movsxd	rax, edx
	movss	xmm0, DWORD PTR [rcx+rax*4]

; 689  : 	}

	ret	0
??R?$Vector@M$03@@QEBAMH@Z ENDP				; Vector<float,4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\random
;	COMDAT ??0?$linear_congruential_engine@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z
_TEXT	SEGMENT
this$ = 8
_X0$dead$ = 16
??0?$linear_congruential_engine@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z PROC ; std::linear_congruential_engine<unsigned int,48271,0,2147483647>::linear_congruential_engine<unsigned int,48271,0,2147483647>, COMDAT

; 551  : 		_Imp._Prev = _Mx != 0 ? _X0 % _Mx : _X0;

	mov	DWORD PTR [rcx], 1

; 629  : 		}

	mov	rax, rcx
	ret	0
??0?$linear_congruential_engine@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z ENDP ; std::linear_congruential_engine<unsigned int,48271,0,2147483647>::linear_congruential_engine<unsigned int,48271,0,2147483647>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 116  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	QWORD PTR [rcx], 0

; 240  : 		}

	mov	rax, rcx
	ret	0
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT

; 135  : 		return (_MyRep);

	mov	rax, QWORD PTR [rcx]

; 136  : 		}

	ret	0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Mylast, COMDAT

; 653  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Myfirst, COMDAT

; 643  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Getal, COMDAT

; 623  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 521  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXXZ PROC ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Tidy, COMDAT

; 1636 : 		{	// free all storage

$LN108:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdx, 288230376151711743			; 03ffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	rax, rcx
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdx
	jbe	SHORT $LN69@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN69@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN70@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN71@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN72@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN72@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN73@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN74@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN70@Tidy:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN107@Tidy:
?_Tidy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXXZ ENDP ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$dead$ = 56
?_Buy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAA_N_K@Z PROC ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Buy, COMDAT

; 1561 : 		{	// allocate array with _Capacity elements

$LN123:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 6400039				; 0061a827H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 6400000				; 0061a800H
	mov	QWORD PTR [rbx+16], rax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1

; 1577 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Buy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAA_N_K@Z ENDP ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Mylast, COMDAT

; 653  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Myfirst, COMDAT

; 643  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Getal, COMDAT

; 623  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 521  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXXZ PROC ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Tidy, COMDAT

; 1636 : 		{	// free all storage

$LN108:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	$LN2@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rdx, QWORD PTR [rbx+16]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, rcx
	imul	rdx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	rdx, rax
	jbe	SHORT $LN69@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN69@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN70@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN71@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN72@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN72@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN73@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN74@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN70@Tidy:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN107@Tidy:
?_Tidy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXXZ ENDP ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$dead$ = 56
?_Buy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAA_N_K@Z PROC ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Buy, COMDAT

; 1561 : 		{	// allocate array with _Capacity elements

$LN123:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 4800039				; 00493e27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 4800000				; 00493e00H
	mov	QWORD PTR [rbx+16], rax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1

; 1577 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Buy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAA_N_K@Z ENDP ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$02$03$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$02$03$00@@QEAAAEAMHH@Z PROC	; MatrixData<float,3,4,1>::GetElement, COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d
	lea	rdx, QWORD PTR [rax+r8*4]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 42   : 	}

	ret	0
?GetElement@?$MatrixData@M$02$03$00@@QEAAAEAMHH@Z ENDP	; MatrixData<float,3,4,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$03$02$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$03$02$00@@QEAAAEAMHH@Z PROC	; MatrixData<float,4,3,1>::GetElement, COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d
	lea	rdx, QWORD PTR [rax+r8*4]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 42   : 	}

	ret	0
?GetElement@?$MatrixData@M$03$02$00@@QEAAAEAMHH@Z ENDP	; MatrixData<float,4,3,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Mylast, COMDAT

; 653  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Myfirst, COMDAT

; 643  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Getal, COMDAT

; 623  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 521  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXXZ PROC ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Tidy, COMDAT

; 1636 : 		{	// free all storage

$LN108:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdx, 576460752303423487			; 07ffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	rax, rcx
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdx
	jbe	SHORT $LN69@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN69@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN70@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN71@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN72@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN72@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN73@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN74@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN70@Tidy:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN107@Tidy:
?_Tidy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXXZ ENDP ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$dead$ = 56
?_Buy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAA_N_K@Z PROC ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Buy, COMDAT

; 1561 : 		{	// allocate array with _Capacity elements

$LN123:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 3200039				; 0030d427H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 3200000				; 0030d400H
	mov	QWORD PTR [rbx+16], rax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1

; 1577 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Buy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAA_N_K@Z ENDP ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Mylast, COMDAT

; 653  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Myfirst, COMDAT

; 643  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Getal, COMDAT

; 623  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 521  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXXZ PROC ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Tidy, COMDAT

; 1636 : 		{	// free all storage

$LN108:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdx, 576460752303423487			; 07ffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	rax, rcx
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdx
	jbe	SHORT $LN69@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN69@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN70@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN71@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN72@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN72@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN73@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN74@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN70@Tidy:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN107@Tidy:
?_Tidy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXXZ ENDP ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$dead$ = 56
?_Buy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAA_N_K@Z PROC ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Buy, COMDAT

; 1561 : 		{	// allocate array with _Capacity elements

$LN123:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 3200039				; 0030d427H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 3200000				; 0030d400H
	mov	QWORD PTR [rbx+16], rax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1

; 1577 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Buy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAA_N_K@Z ENDP ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Mylast, COMDAT

; 653  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Myfirst, COMDAT

; 643  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Getal, COMDAT

; 623  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 521  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXXZ PROC ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Tidy, COMDAT

; 1636 : 		{	// free all storage

$LN108:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdx, 288230376151711743			; 03ffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	rax, rcx
	sar	rax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdx
	jbe	SHORT $LN69@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN69@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN70@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN71@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN72@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN72@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN73@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN74@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN70@Tidy:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN107@Tidy:
?_Tidy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXXZ ENDP ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$dead$ = 56
?_Buy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAA_N_K@Z PROC ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Buy, COMDAT

; 1561 : 		{	// allocate array with _Capacity elements

$LN123:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 6400039				; 0061a827H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 6400000				; 0061a800H
	mov	QWORD PTR [rbx+16], rax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1

; 1577 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Buy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAA_N_K@Z ENDP ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Mylast, COMDAT

; 653  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Myfirst, COMDAT

; 643  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Getal, COMDAT

; 623  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 521  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXXZ PROC ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Tidy, COMDAT

; 1636 : 		{	// free all storage

$LN108:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	$LN2@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rdx, QWORD PTR [rbx+16]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, rcx
	imul	rdx
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	rdx, rax
	jbe	SHORT $LN69@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN69@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN70@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN71@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN72@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN72@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN73@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN74@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN70@Tidy:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN107@Tidy:
?_Tidy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXXZ ENDP ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$dead$ = 56
?_Buy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAA_N_K@Z PROC ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Buy, COMDAT

; 1561 : 		{	// allocate array with _Capacity elements

$LN123:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 4800039				; 00493e27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 4800000				; 00493e00H
	mov	QWORD PTR [rbx+16], rax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1

; 1577 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Buy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAA_N_K@Z ENDP ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\random
;	COMDAT ??0?$uniform_real@M@std@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
??0?$uniform_real@M@std@@QEAA@MM@Z PROC			; std::uniform_real<float>::uniform_real<float>, COMDAT

; 3252 : 			_Min = _Min0;

	movss	DWORD PTR [rcx], xmm1

; 3264 : 		}

	mov	rax, rcx

; 3253 : 			_Max = _Max0;

	movss	DWORD PTR [rcx+4], xmm2

; 3264 : 		}

	ret	0
??0?$uniform_real@M@std@@QEAA@MM@Z ENDP			; std::uniform_real<float>::uniform_real<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\random
;	COMDAT ??0?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z
_TEXT	SEGMENT
this$ = 8
_X0$dead$ = 16
??0?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z PROC ; std::linear_congruential<unsigned int,48271,0,2147483647>::linear_congruential<unsigned int,48271,0,2147483647>, COMDAT

; 551  : 		_Imp._Prev = _Mx != 0 ? _X0 % _Mx : _X0;

	mov	DWORD PTR [rcx], 1

; 478  : 		{	// construct from initial value
; 479  : 		seed(_X0);
; 480  : 		}

	mov	rax, rcx
	ret	0
??0?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z ENDP ; std::linear_congruential<unsigned int,48271,0,2147483647>::linear_congruential<unsigned int,48271,0,2147483647>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Mylast, COMDAT

; 653  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Myfirst, COMDAT

; 643  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Getal, COMDAT

; 623  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 521  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXXZ PROC ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Tidy, COMDAT

; 1636 : 		{	// free all storage

$LN108:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdx, 1152921504606846975		; 0fffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	rax, rcx
	sar	rax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdx
	jbe	SHORT $LN69@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN69@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN70@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN71@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN71@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN72@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN72@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN73@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN74@Tidy
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN70@Tidy:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN107@Tidy:
?_Tidy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXXZ ENDP ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$dead$ = 56
?_Buy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAA_N_K@Z PROC ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Buy, COMDAT

; 1561 : 		{	// allocate array with _Capacity elements

$LN123:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 1600039				; 00186a27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rdx, QWORD PTR [rax+39]
	and	rdx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdx-8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rdx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rdx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	rax, QWORD PTR [rbx]
	add	rax, 1600000				; 00186a00H
	mov	QWORD PTR [rbx+16], rax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1

; 1577 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Buy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAA_N_K@Z ENDP ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$01$01$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$01$01$00@@QEBAMHH@Z PROC	; MatrixData<float,2,2,1>::GetElement, COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 45   : 		return stripes[row][col];

	lea	rdx, QWORD PTR [rax+r8*2]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 46   : 	}

	ret	0
?GetElement@?$MatrixData@M$01$01$00@@QEBAMHH@Z ENDP	; MatrixData<float,2,2,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$01$01$00@@QEAAAEAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$01$01$00@@QEAAAEAMHH@Z PROC	; MatrixData<float,2,2,1>::GetElement, COMDAT
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 41   : 		return stripes[row][col];

	movsxd	r8, r8d
	lea	rdx, QWORD PTR [rax+r8*2]
; File c:\home\programming\mathter\mathter\vector.hpp

; 684  : 		return data[idx];

	lea	rax, QWORD PTR [rcx+rdx*4]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 42   : 	}

	ret	0
?GetElement@?$MatrixData@M$01$01$00@@QEAAAEAMHH@Z ENDP	; MatrixData<float,2,2,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$01$03$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$01$03$00@@QEBAMHH@Z PROC	; MatrixData<float,2,4,1>::GetElement, COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 45   : 		return stripes[row][col];

	lea	rdx, QWORD PTR [rax+r8*2]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 46   : 	}

	ret	0
?GetElement@?$MatrixData@M$01$03$00@@QEBAMHH@Z ENDP	; MatrixData<float,2,4,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$03$01$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$03$01$00@@QEBAMHH@Z PROC	; MatrixData<float,4,2,1>::GetElement, COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 45   : 		return stripes[row][col];

	lea	rdx, QWORD PTR [rax+r8*4]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 46   : 	}

	ret	0
?GetElement@?$MatrixData@M$03$01$00@@QEBAMHH@Z ENDP	; MatrixData<float,4,2,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$02$02$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$02$02$00@@QEBAMHH@Z PROC	; MatrixData<float,3,3,1>::GetElement, COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 45   : 		return stripes[row][col];

	lea	rdx, QWORD PTR [rax+r8*4]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 46   : 	}

	ret	0
?GetElement@?$MatrixData@M$02$02$00@@QEBAMHH@Z ENDP	; MatrixData<float,3,3,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$03$03$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$03$03$00@@QEBAMHH@Z PROC	; MatrixData<float,4,4,1>::GetElement, COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 45   : 		return stripes[row][col];

	lea	rdx, QWORD PTR [rax+r8*4]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 46   : 	}

	ret	0
?GetElement@?$MatrixData@M$03$03$00@@QEBAMHH@Z ENDP	; MatrixData<float,4,4,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 8
?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero, COMDAT

; 116  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	QWORD PTR [rcx], 0

; 208  : 		return (_Myt(duration_values<_Rep>::zero()));

	mov	rax, rcx

; 209  : 		}

	ret	0
?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ?zero@?$duration_values@_J@chrono@std@@SA_JXZ
_TEXT	SEGMENT
?zero@?$duration_values@_J@chrono@std@@SA_JXZ PROC	; std::chrono::duration_values<__int64>::zero, COMDAT

; 40   : 		return (_Rep(0));

	xor	eax, eax

; 41   : 		}

	ret	0
?zero@?$duration_values@_J@chrono@std@@SA_JXZ ENDP	; std::chrono::duration_values<__int64>::zero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::deallocate, COMDAT

; 986  : 		{	// deallocate object at _Ptr, ignore size

$LN17:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN10@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN11@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::allocate, COMDAT

; 975  : 		{	// allocate array of _Count elements

$LN18:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 6400039				; 0061a827H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rax, rcx

; 977  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Myend, COMDAT

; 663  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$03$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Get_data, COMDAT

; 633  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Orphan_all, COMDAT

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEBAXXZ PROC ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Xlen, COMDAT

; 1764 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEBAXXZ ENDP ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$02$03$00@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$02$03$00@@0@Z PROC ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Destroy, COMDAT

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	0
?_Destroy@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$02$03$00@@0@Z ENDP ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::max_size, COMDAT

; 1185 : 		return (this->_Getal().max_size());

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::deallocate, COMDAT

; 986  : 		{	// deallocate object at _Ptr, ignore size

$LN17:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	r8, rax
	jbe	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [r8+r8*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN10@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN11@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::allocate, COMDAT

; 975  : 		{	// allocate array of _Count elements

$LN18:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 4800039				; 00493e27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rax, rcx

; 977  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Myend, COMDAT

; 663  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$02$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Get_data, COMDAT

; 633  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Orphan_all, COMDAT

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEBAXXZ PROC ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Xlen, COMDAT

; 1764 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEBAXXZ ENDP ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$02$00@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$02$00@@0@Z PROC ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Destroy, COMDAT

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	0
?_Destroy@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$02$00@@0@Z ENDP ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::max_size, COMDAT

; 1185 : 		return (this->_Getal().max_size());

	mov	rax, 384307168202282325			; 0555555555555555H

; 1186 : 		}

	ret	0
?max_size@?$vector@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::deallocate, COMDAT

; 986  : 		{	// deallocate object at _Ptr, ignore size

$LN17:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN10@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN11@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::allocate, COMDAT

; 975  : 		{	// allocate array of _Count elements

$LN18:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 3200039				; 0030d427H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rax, rcx

; 977  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Myend, COMDAT

; 663  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$03$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Get_data, COMDAT

; 633  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Orphan_all, COMDAT

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEBAXXZ PROC ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Xlen, COMDAT

; 1764 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEBAXXZ ENDP ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$01$03$00@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$01$03$00@@0@Z PROC ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Destroy, COMDAT

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	0
?_Destroy@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$01$03$00@@0@Z ENDP ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::max_size, COMDAT

; 1185 : 		return (this->_Getal().max_size());

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::deallocate, COMDAT

; 986  : 		{	// deallocate object at _Ptr, ignore size

$LN17:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN10@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN11@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::allocate, COMDAT

; 975  : 		{	// allocate array of _Count elements

$LN18:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 3200039				; 0030d427H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rax, rcx

; 977  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Myend, COMDAT

; 663  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$01$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Get_data, COMDAT

; 633  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Orphan_all, COMDAT

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEBAXXZ PROC ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Xlen, COMDAT

; 1764 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEBAXXZ ENDP ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$01$00@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$01$00@@0@Z PROC ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Destroy, COMDAT

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	0
?_Destroy@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$01$00@@0@Z ENDP ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::max_size, COMDAT

; 1185 : 		return (this->_Getal().max_size());

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::deallocate, COMDAT

; 986  : 		{	// deallocate object at _Ptr, ignore size

$LN17:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN10@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN11@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::allocate, COMDAT

; 975  : 		{	// allocate array of _Count elements

$LN18:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 6400039				; 0061a827H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rax, rcx

; 977  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Myend, COMDAT

; 663  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$03$03$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Get_data, COMDAT

; 633  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Orphan_all, COMDAT

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEBAXXZ PROC ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Xlen, COMDAT

; 1764 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEBAXXZ ENDP ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$03$00@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$03$00@@0@Z PROC ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Destroy, COMDAT

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	0
?_Destroy@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$03$03$00@@0@Z ENDP ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::max_size, COMDAT

; 1185 : 		return (this->_Getal().max_size());

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::deallocate, COMDAT

; 986  : 		{	// deallocate object at _Ptr, ignore size

$LN17:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	r8, rax
	jbe	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [r8+r8*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN10@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN11@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::allocate, COMDAT

; 975  : 		{	// allocate array of _Count elements

$LN18:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 4800039				; 00493e27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rax, rcx

; 977  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Myend, COMDAT

; 663  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$02$02$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Get_data, COMDAT

; 633  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Orphan_all, COMDAT

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEBAXXZ PROC ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Xlen, COMDAT

; 1764 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEBAXXZ ENDP ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$02$02$00@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$02$02$00@@0@Z PROC ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Destroy, COMDAT

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	0
?_Destroy@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$02$02$00@@0@Z ENDP ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::max_size, COMDAT

; 1185 : 		return (this->_Getal().max_size());

	mov	rax, 384307168202282325			; 0555555555555555H

; 1186 : 		}

	ret	0
?max_size@?$vector@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\random
;	COMDAT ??0param_type@?$uniform_real@M@std@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
??0param_type@?$uniform_real@M@std@@QEAA@MM@Z PROC	; std::uniform_real<float>::param_type::param_type, COMDAT

; 3252 : 			_Min = _Min0;

	movss	DWORD PTR [rcx], xmm1

; 3222 : 			_Ty _Max0 = _Ty(1))
; 3223 : 			{	// construct from parameters
; 3224 : 			_Init(_Min0, _Max0);
; 3225 : 			}

	mov	rax, rcx

; 3253 : 			_Max = _Max0;

	movss	DWORD PTR [rcx+4], xmm2

; 3222 : 			_Ty _Max0 = _Ty(1))
; 3223 : 			{	// construct from parameters
; 3224 : 			_Init(_Min0, _Max0);
; 3225 : 			}

	ret	0
??0param_type@?$uniform_real@M@std@@QEAA@MM@Z ENDP	; std::uniform_real<float>::param_type::param_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\random
;	COMDAT ??0?$_Mul_mod@_KI$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z
_TEXT	SEGMENT
this$ = 8
_Val$dead$ = 16
??0?$_Mul_mod@_KI$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z PROC ; std::_Mul_mod<unsigned __int64,unsigned int,48271,0,2147483647>::_Mul_mod<unsigned __int64,unsigned int,48271,0,2147483647>, COMDAT

; 348  : 		: _Prev(_Val)

	mov	DWORD PTR [rcx], 0

; 350  : 		}

	mov	rax, rcx
	ret	0
??0?$_Mul_mod@_KI$0LMIP@$0A@$0HPPPPPPP@@std@@QEAA@I@Z ENDP ; std::_Mul_mod<unsigned __int64,unsigned int,48271,0,2147483647>::_Mul_mod<unsigned __int64,unsigned int,48271,0,2147483647>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\random
;	COMDAT ?seed@?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
_X0$dead$ = 16
?seed@?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAAXI@Z PROC ; std::linear_congruential<unsigned int,48271,0,2147483647>::seed, COMDAT

; 551  : 		_Imp._Prev = _Mx != 0 ? _X0 % _Mx : _X0;

	mov	DWORD PTR [rcx], 1

; 491  : 		_Reset(_X0);
; 492  : 		}

	ret	0
?seed@?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@QEAAXI@Z ENDP ; std::linear_congruential<unsigned int,48271,0,2147483647>::seed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::deallocate, COMDAT

; 986  : 		{	// deallocate object at _Ptr, ignore size

$LN17:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN10@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN11@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::allocate, COMDAT

; 975  : 		{	// allocate array of _Count elements

$LN18:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 1600039				; 00186a27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rax, rcx

; 977  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Myend, COMDAT

; 663  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAPEAV?$Matrix@M$01$01$00@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Get_data, COMDAT

; 633  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Orphan_all, COMDAT

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEBAXXZ PROC ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Xlen, COMDAT

; 1764 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEBAXXZ ENDP ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$01$01$00@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$01$01$00@@0@Z PROC ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Destroy, COMDAT

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	0
?_Destroy@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@IEAAXPEAV?$Matrix@M$01$01$00@@0@Z ENDP ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::max_size, COMDAT

; 1185 : 		return (this->_Getal().max_size());

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??A?$Vector@M$01@@QEBAMH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??A?$Vector@M$01@@QEBAMH@Z PROC				; Vector<float,2>::operator[], COMDAT

; 680  : 		return data[idx];

	movsxd	rax, edx
	movss	xmm0, DWORD PTR [rcx+rax*4]

; 681  : 	}

	ret	0
??A?$Vector@M$01@@QEBAMH@Z ENDP				; Vector<float,2>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??A?$Vector@M$03@@QEBAMH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??A?$Vector@M$03@@QEBAMH@Z PROC				; Vector<float,4>::operator[], COMDAT

; 680  : 		return data[idx];

	movsxd	rax, edx
	movss	xmm0, DWORD PTR [rcx+rax*4]

; 681  : 	}

	ret	0
??A?$Vector@M$03@@QEBAMH@Z ENDP				; Vector<float,4>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??A?$Vector@M$02@@QEBAMH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??A?$Vector@M$02@@QEBAMH@Z PROC				; Vector<float,3>::operator[], COMDAT

; 680  : 		return data[idx];

	movsxd	rax, edx
	movss	xmm0, DWORD PTR [rcx+rax*4]

; 681  : 	}

	ret	0
??A?$Vector@M$02@@QEBAMH@Z ENDP				; Vector<float,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Getal, COMDAT

; 628  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$03$00@@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,4,1>,std::allocator<Matrix<float,3,4,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z PROC ; std::allocator<Matrix<float,3,4,1> >::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 6400039				; 0061a827H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	rax, rcx

; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAPEAV?$Matrix@M$02$03$00@@_K@Z ENDP ; std::allocator<Matrix<float,3,4,1> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z PROC ; std::allocator<Matrix<float,3,4,1> >::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@_K@Z ENDP ; std::allocator<Matrix<float,3,4,1> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 384307168202282325			; 0555555555555555H

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Getal, COMDAT

; 628  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$02$00@@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,3,1>,std::allocator<Matrix<float,4,3,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z PROC ; std::allocator<Matrix<float,4,3,1> >::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 4800039				; 00493e27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	rax, rcx

; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAPEAV?$Matrix@M$03$02$00@@_K@Z ENDP ; std::allocator<Matrix<float,4,3,1> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z PROC ; std::allocator<Matrix<float,4,3,1> >::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [r8+r8*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@_K@Z ENDP ; std::allocator<Matrix<float,4,3,1> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Getal, COMDAT

; 628  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$03$00@@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,4,1>,std::allocator<Matrix<float,2,4,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z PROC ; std::allocator<Matrix<float,2,4,1> >::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 3200039				; 0030d427H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	rax, rcx

; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAPEAV?$Matrix@M$01$03$00@@_K@Z ENDP ; std::allocator<Matrix<float,2,4,1> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z PROC ; std::allocator<Matrix<float,2,4,1> >::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@_K@Z ENDP ; std::allocator<Matrix<float,2,4,1> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Getal, COMDAT

; 628  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$01$00@@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,2,1>,std::allocator<Matrix<float,4,2,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z PROC ; std::allocator<Matrix<float,4,2,1> >::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 3200039				; 0030d427H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	rax, rcx

; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAPEAV?$Matrix@M$03$01$00@@_K@Z ENDP ; std::allocator<Matrix<float,4,2,1> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z PROC ; std::allocator<Matrix<float,4,2,1> >::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@_K@Z ENDP ; std::allocator<Matrix<float,4,2,1> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Getal, COMDAT

; 628  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$03$03$00@@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,4,4,1>,std::allocator<Matrix<float,4,4,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z PROC ; std::allocator<Matrix<float,4,4,1> >::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 6400039				; 0061a827H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	rax, rcx

; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAPEAV?$Matrix@M$03$03$00@@_K@Z ENDP ; std::allocator<Matrix<float,4,4,1> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z PROC ; std::allocator<Matrix<float,4,4,1> >::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 6

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@_K@Z ENDP ; std::allocator<Matrix<float,4,4,1> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 384307168202282325			; 0555555555555555H

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Getal, COMDAT

; 628  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$02$02$00@@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,3,3,1>,std::allocator<Matrix<float,3,3,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z PROC ; std::allocator<Matrix<float,3,3,1> >::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 4800039				; 00493e27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	rax, rcx

; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAPEAV?$Matrix@M$02$02$00@@_K@Z ENDP ; std::allocator<Matrix<float,3,3,1> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z PROC ; std::allocator<Matrix<float,3,3,1> >::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [r8+r8*2]
	shl	rax, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@_K@Z ENDP ; std::allocator<Matrix<float,3,3,1> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\random
;	COMDAT ?_Init@param_type@?$uniform_real@M@std@@QEAAXMM@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
?_Init@param_type@?$uniform_real@M@std@@QEAAXMM@Z PROC	; std::uniform_real<float>::param_type::_Init, COMDAT

; 3249 : 			_RNG_ASSERT(_Min0 <= _Max0 && (0 <= _Min0
; 3250 : 				|| _Max0 <= _Min0 + (numeric_limits<_Ty>::max)()),
; 3251 : 				"invalid min and max arguments for uniform_real");
; 3252 : 			_Min = _Min0;

	movss	DWORD PTR [rcx], xmm1

; 3253 : 			_Max = _Max0;

	movss	DWORD PTR [rcx+4], xmm2

; 3254 : 			}

	ret	0
?_Init@param_type@?$uniform_real@M@std@@QEAAXMM@Z ENDP	; std::uniform_real<float>::param_type::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\random
;	COMDAT ?_Reset@?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@IEAAXI@Z
_TEXT	SEGMENT
this$ = 8
_X0$dead$ = 16
?_Reset@?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@IEAAXI@Z PROC ; std::linear_congruential<unsigned int,48271,0,2147483647>::_Reset, COMDAT

; 551  : 		_Imp._Prev = _Mx != 0 ? _X0 % _Mx : _X0;

	mov	DWORD PTR [rcx], 1

; 552  : 		if (_Imp._Prev == 0 && _Cx == 0)
; 553  : 			_Imp._Prev = 1;
; 554  : 		}

	ret	0
?_Reset@?$linear_congruential@I$0LMIP@$0A@$0HPPPPPPP@@std@@IEAAXI@Z ENDP ; std::linear_congruential<unsigned int,48271,0,2147483647>::_Reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Getal, COMDAT

; 628  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$Matrix@M$01$01$00@@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Matrix<float,2,2,1>,std::allocator<Matrix<float,2,2,1> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z PROC ; std::allocator<Matrix<float,2,2,1> >::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	ecx, 1600039				; 00186a27H
	call	??2@YAPEAX_K@Z				; operator new

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	rax, rcx

; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAPEAV?$Matrix@M$01$01$00@@_K@Z ENDP ; std::allocator<Matrix<float,2,2,1> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z PROC ; std::allocator<Matrix<float,2,2,1> >::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 4

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@_K@Z ENDP ; std::allocator<Matrix<float,2,2,1> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$02$03$00@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$02$03$00@@@2@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,3,4,1> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$02$03$00@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,3,4,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$02$00@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$02$00@@@2@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,4,3,1> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 384307168202282325			; 0555555555555555H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$02$00@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,4,3,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$01$03$00@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$01$03$00@@@2@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,2,4,1> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$01$03$00@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,2,4,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$01$00@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$01$00@@@2@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,4,2,1> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$01$00@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,4,2,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$03$00@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$03$00@@@2@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,4,4,1> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$03$03$00@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,4,4,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$02$02$00@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$02$02$00@@@2@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,3,3,1> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 384307168202282325			; 0555555555555555H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$02$02$00@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,3,3,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$01$01$00@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$01$01$00@@@2@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,2,2,1> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@SA_KAEBV?$allocator@V?$Matrix@M$01$01$00@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,2,2,1> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEBA_KXZ PROC ; std::allocator<Matrix<float,3,4,1> >::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEBA_KXZ ENDP ; std::allocator<Matrix<float,3,4,1> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEBA_KXZ PROC ; std::allocator<Matrix<float,4,3,1> >::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 384307168202282325			; 0555555555555555H

; 750  : 		}

	ret	0
?max_size@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEBA_KXZ ENDP ; std::allocator<Matrix<float,4,3,1> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEBA_KXZ PROC ; std::allocator<Matrix<float,2,4,1> >::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEBA_KXZ ENDP ; std::allocator<Matrix<float,2,4,1> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEBA_KXZ PROC ; std::allocator<Matrix<float,4,2,1> >::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEBA_KXZ ENDP ; std::allocator<Matrix<float,4,2,1> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEBA_KXZ PROC ; std::allocator<Matrix<float,4,4,1> >::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEBA_KXZ ENDP ; std::allocator<Matrix<float,4,4,1> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEBA_KXZ PROC ; std::allocator<Matrix<float,3,3,1> >::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 384307168202282325			; 0555555555555555H

; 750  : 		}

	ret	0
?max_size@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEBA_KXZ ENDP ; std::allocator<Matrix<float,3,3,1> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEBA_KXZ PROC ; std::allocator<Matrix<float,2,2,1> >::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEBA_KXZ ENDP ; std::allocator<Matrix<float,2,2,1> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MMM$0A@@?$Vector@M$02@@IEAAXHMMM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<scalars_0>$ = 32
<scalars_1>$ = 40
??$Assign@MMM$0A@@?$Vector@M$02@@IEAAXHMMM@Z PROC	; Vector<float,3>::Assign<float,float,float,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 844  : 		data[idx] = head;
; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@MMM$0A@@?$Vector@M$02@@IEAAXHMMM@Z ENDP	; Vector<float,3>::Assign<float,float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MMMM$0A@@?$Vector@M$03@@IEAAXHMMMM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<scalars_0>$ = 32
<scalars_1>$ = 40
<scalars_2>$ = 48
??$Assign@MMMM$0A@@?$Vector@M$03@@IEAAXHMMMM@Z PROC	; Vector<float,4>::Assign<float,float,float,float,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 844  : 		data[idx] = head;
; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@MMMM$0A@@?$Vector@M$03@@IEAAXHMMMM@Z ENDP	; Vector<float,4>::Assign<float,float,float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@V?$Vector@M$03@@V1@$0A@@?$Vector@M$07@@IEAAXHAEBV?$Vector@M$03@@0@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<mixed_0>$ = 32
??$Assign@V?$Vector@M$03@@V1@$0A@@?$Vector@M$07@@IEAAXHAEBV?$Vector@M$03@@0@Z PROC ; Vector<float,8>::Assign<Vector<float,4>,Vector<float,4>,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 851  : 		for (int i = 0; i < DimensionOf<Head>::value; ++i) {
; 852  : 			data[idx] = GetVectorElement<Head>::Get(head, i);
; 853  : 			++idx;
; 854  : 		}
; 855  : 		Assign(idx, mixed...);
; 856  : 	}

	ret	0
??$Assign@V?$Vector@M$03@@V1@$0A@@?$Vector@M$07@@IEAAXHAEBV?$Vector@M$03@@0@Z ENDP ; Vector<float,8>::Assign<Vector<float,4>,Vector<float,4>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
<scalars_3>$dead$ = 56
<scalars_4>$dead$ = 64
<scalars_5>$dead$ = 72
<scalars_6>$dead$ = 80
??$Assign@HHHHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHHHH@Z PROC ; Vector<float,8>::Assign<int,int,int,int,int,int,int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx], 1065353216		; 3f800000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+12], 1082130432		; 40800000H
	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@HHHHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHHHH@Z ENDP ; Vector<float,8>::Assign<int,int,int,int,int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@H$$V$0A@@?$Vector@M$02@@IEAAXHH@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
head$ = 24
??$Assign@H$$V$0A@@?$Vector@M$02@@IEAAXHH@Z PROC	; Vector<float,3>::Assign<int,0>, COMDAT

; 844  : 		data[idx] = head;

	movsxd	rax, edx
	movd	xmm0, r8d
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rcx+rax*4], xmm0

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@H$$V$0A@@?$Vector@M$02@@IEAAXHH@Z ENDP	; Vector<float,3>::Assign<int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@V?$Vector@M$02@@$$V$0A@@?$Vector@M$03@@IEAAXHAEBV?$Vector@M$02@@@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
head$ = 24
??$Assign@V?$Vector@M$02@@$$V$0A@@?$Vector@M$03@@IEAAXHAEBV?$Vector@M$02@@@Z PROC ; Vector<float,4>::Assign<Vector<float,3>,0>, COMDAT

; 851  : 		for (int i = 0; i < DimensionOf<Head>::value; ++i) {
; 852  : 			data[idx] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [r8]
	movsxd	r9, edx
	mov	DWORD PTR [rcx+r9*4], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+r9*4+4], eax
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+r9*4+8], eax

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 853  : 			++idx;
; 854  : 		}
; 855  : 		Assign(idx, mixed...);
; 856  : 	}

	ret	0
??$Assign@V?$Vector@M$02@@$$V$0A@@?$Vector@M$03@@IEAAXHAEBV?$Vector@M$02@@@Z ENDP ; Vector<float,4>::Assign<Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHH$0A@@?$Vector@M$02@@IEAAXHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
??$Assign@HHH$0A@@?$Vector@M$02@@IEAAXHHHH@Z PROC	; Vector<float,3>::Assign<int,int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx], 1065353216		; 3f800000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H
	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@HHH$0A@@?$Vector@M$02@@IEAAXHHHH@Z ENDP	; Vector<float,3>::Assign<int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@IEAAXHAEBMAEBV?$Vector@M$02@@@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<mixed_0>$ = 32
??$Assign@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@IEAAXHAEBMAEBV?$Vector@M$02@@@Z PROC ; Vector<float,4>::Assign<float,Vector<float,3>,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 851  : 		for (int i = 0; i < DimensionOf<Head>::value; ++i) {
; 852  : 			data[idx] = GetVectorElement<Head>::Get(head, i);
; 853  : 			++idx;
; 854  : 		}
; 855  : 		Assign(idx, mixed...);
; 856  : 	}

	ret	0
??$Assign@MV?$Vector@M$02@@$0A@@?$Vector@M$03@@IEAAXHAEBMAEBV?$Vector@M$02@@@Z ENDP ; Vector<float,4>::Assign<float,Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$?HM$03@@YA?AV?$Vector@M$03@@AEBV0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??$?HM$03@@YA?AV?$Vector@M$03@@AEBV0@0@Z PROC		; operator+<float,4>, COMDAT

; 888  : 	auto tmp = lhs;

	movaps	xmm1, XMMWORD PTR [rdx]

; 889  : 	tmp += rhs;
; 890  : 	return tmp;

	mov	rax, rcx
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rcx], xmm1

; 891  : }

	ret	0
??$?HM$03@@YA?AV?$Vector@M$03@@AEBV0@0@Z ENDP		; operator+<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?DMM$01$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV0@0@Z
_TEXT	SEGMENT
scalarMultiplier$ = 8
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??$?DMM$01$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV0@0@Z PROC ; operator*<float,float,2,2,2,1,1,float,void>, COMDAT

; 139  : 	using ResultT = Matrix<V, Columns2, Rows1, Order1>;
; 140  : 
; 141  : 	ResultT result;
; 142  : 
; 143  : 	VectorSpec<V, Columns2> scalarMultiplier;
; 144  : 	for (int y = 0; y < Rows1; ++y) {
; 145  : 		scalarMultiplier = rhs.stripes[0];

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR scalarMultiplier$[rsp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm0, DWORD PTR scalarMultiplier$[rsp]
	mulss	xmm0, DWORD PTR [rdx]

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rsp+4]
	mulss	xmm1, DWORD PTR [rdx]
	movss	DWORD PTR scalarMultiplier$[rsp], xmm0
	movss	DWORD PTR scalarMultiplier$[rsp+4], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	rax, QWORD PTR scalarMultiplier$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR scalarMultiplier$[rsp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 175  : 		this->y *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rsp+4]
	mulss	xmm1, DWORD PTR [rdx+8]
	movss	xmm0, DWORD PTR scalarMultiplier$[rsp]
	mulss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR scalarMultiplier$[rsp+4], xmm1
	movss	DWORD PTR scalarMultiplier$[rsp], xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	mov	rax, QWORD PTR scalarMultiplier$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 151  : 			scalarMultiplier = rhs.stripes[x];

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR scalarMultiplier$[rsp], rax
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rsp]
	mulss	xmm1, DWORD PTR [rdx+4]

; 175  : 		this->y *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$[rsp+4]
	mulss	xmm2, DWORD PTR [rdx+4]

; 164  : 		this->x += rhs.x;

	addss	xmm1, DWORD PTR [rcx]

; 165  : 		this->y += rhs.y;

	addss	xmm2, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 151  : 			scalarMultiplier = rhs.stripes[x];

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR scalarMultiplier$[rsp], rax

; 152  : 			scalarMultiplier.mul(lhs(x, y));
; 153  : 			static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]).add(scalarMultiplier);
; 154  : 		}
; 155  : 	}
; 156  : 
; 157  : 	return result;

	mov	rax, rcx
; File c:\home\programming\mathter\mathter\vector.hpp

; 174  : 		this->x *= rhs;

	movss	xmm1, DWORD PTR scalarMultiplier$[rsp]
	mulss	xmm1, DWORD PTR [rdx+12]

; 175  : 		this->y *= rhs;

	movss	xmm2, DWORD PTR scalarMultiplier$[rsp+4]
	mulss	xmm2, DWORD PTR [rdx+12]

; 164  : 		this->x += rhs.x;

	addss	xmm1, DWORD PTR [rcx+8]
	movss	DWORD PTR [rcx+8], xmm1

; 165  : 		this->y += rhs.y;

	addss	xmm2, DWORD PTR [rcx+12]
	movss	DWORD PTR [rcx+12], xmm2
; File c:\home\programming\mathter\mathter\matrix.hpp

; 158  : }

	ret	0
??$?DMM$01$01$01$00$00MX@@YA?AV?$Matrix@M$01$01$00@@AEBV0@0@Z ENDP ; operator*<float,float,2,2,2,1,1,float,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Left$ = 16
_Right$ = 24
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [r8]

; 116  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	QWORD PTR [rcx], rax

; 848  : 	return (_Left.time_since_epoch() - _Right.time_since_epoch());

	mov	rax, rcx

; 849  : 	}

	ret	0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Dur$ = 16
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000> >, COMDAT

; 552  : 	typedef ratio_divide<_Period, typename _To::period> _CF;
; 553  : 
; 554  : 	typedef typename _To::rep _ToRep;
; 555  : 	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
; 556  : 	return (_CF::num == 1 && _CF::den == 1

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 557  : 			? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 558  : 		: _CF::num != 1 && _CF::den == 1
; 559  : 			? static_cast<_To>(static_cast<_ToRep>(
; 560  : 				static_cast<_CR>(
; 561  : 					_Dur.count()) * static_cast<_CR>(_CF::num)))
; 562  : 		: _CF::num == 1 && _CF::den != 1
; 563  : 			? static_cast<_To>(static_cast<_ToRep>(
; 564  : 				static_cast<_CR>(_Dur.count())
; 565  : 					/ static_cast<_CR>(_CF::den)))
; 566  : 		: static_cast<_To>(static_cast<_ToRep>(
; 567  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 568  : 				/ static_cast<_CR>(_CF::den))));
; 569  : 	}

	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?DMM$03$02$02$00$00MX@@YA?AV?$Matrix@M$02$02$00@@AEBV?$Matrix@M$03$02$00@@AEBV?$Matrix@M$02$03$00@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??$?DMM$03$02$02$00$00MX@@YA?AV?$Matrix@M$02$02$00@@AEBV?$Matrix@M$03$02$00@@AEBV?$Matrix@M$02$03$00@@@Z PROC ; operator*<float,float,4,3,3,1,1,float,void>, COMDAT

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	mov	r10, rdx
	mov	r11, rcx
	sub	r10, rcx
	mov	rax, rcx
	mov	r9d, 3
$LL4@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm1, DWORD PTR [r10+rax]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR [rax+16]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm1, xmm1, 0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm0, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rax-16], xmm1
	sub	r9, 1
	jne	SHORT $LL4@operator

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR [rdx+4]
	mov	r10d, 3
	lea	rdx, QWORD PTR [r8+16]
	npad	1
$LL7@operator:

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	mov	rax, r11
	mov	rcx, r9
	mov	r8d, 3
	npad	4
$LL10@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 404  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	r8, 1
	jne	SHORT $LL10@operator

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	add	rdx, 16
	add	r9, 4
	sub	r10, 1
	jne	SHORT $LL7@operator

; 152  : 			scalarMultiplier.mul(lhs(x, y));
; 153  : 			static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]).add(scalarMultiplier);
; 154  : 		}
; 155  : 	}
; 156  : 
; 157  : 	return result;

	mov	rax, r11

; 158  : }

	ret	0
??$?DMM$03$02$02$00$00MX@@YA?AV?$Matrix@M$02$02$00@@AEBV?$Matrix@M$03$02$00@@AEBV?$Matrix@M$02$03$00@@@Z ENDP ; operator*<float,float,4,3,3,1,1,float,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??$?DMM$02$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV?$Matrix@M$02$03$00@@AEBV?$Matrix@M$03$02$00@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??$?DMM$02$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV?$Matrix@M$02$03$00@@AEBV?$Matrix@M$03$02$00@@@Z PROC ; operator*<float,float,3,4,4,1,1,float,void>, COMDAT

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	mov	r10, rdx
	mov	r11, rcx
	sub	r10, rcx
	mov	rax, rcx
	mov	r9d, 4
$LL4@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm1, DWORD PTR [r10+rax]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 144  : 	for (int y = 0; y < Rows1; ++y) {

	lea	rax, QWORD PTR [rax+16]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm1, xmm1, 0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 145  : 		scalarMultiplier = rhs.stripes[0];

	movups	xmm0, XMMWORD PTR [r8]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0
; File c:\home\programming\mathter\mathter\matrix.hpp

; 147  : 		static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]) = scalarMultiplier;

	movups	XMMWORD PTR [rax-16], xmm1
	sub	r9, 1
	jne	SHORT $LL4@operator

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	lea	r9, QWORD PTR [rdx+4]
	mov	r10d, 2
	lea	rdx, QWORD PTR [r8+16]
	npad	1
$LL7@operator:

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	mov	rax, r11
	mov	rcx, r9
	mov	r8d, 4
	npad	4
$LL10@operator:
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	movss	xmm0, DWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rcx, 16

; 151  : 			scalarMultiplier = rhs.stripes[x];

	movups	xmm1, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 37   : 		__m128 tmp = _mm_set1_ps(rhs);

	shufps	xmm0, xmm0, 0

; 38   : 		res.reg = _mm_mul_ps(lhs.reg, tmp);

	mulps	xmm1, xmm0

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm1, XMMWORD PTR [rax]
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rax], xmm1
; File c:\home\programming\mathter\mathter\matrix.hpp

; 150  : 		for (int y = 0; y < Rows1; ++y) {

	add	rax, 16
	sub	r8, 1
	jne	SHORT $LL10@operator

; 148  : 	}
; 149  : 	for (int x = 1; x < Match; ++x) {

	add	rdx, 16
	add	r9, 4
	sub	r10, 1
	jne	SHORT $LL7@operator

; 152  : 			scalarMultiplier.mul(lhs(x, y));
; 153  : 			static_cast<VectorSpec<V, Columns2>&>(result.stripes[y]).add(scalarMultiplier);
; 154  : 		}
; 155  : 	}
; 156  : 
; 157  : 	return result;

	mov	rax, r11

; 158  : }

	ret	0
??$?DMM$02$03$03$00$00MX@@YA?AV?$Matrix@M$03$03$00@@AEBV?$Matrix@M$02$03$00@@AEBV?$Matrix@M$03$02$00@@@Z ENDP ; operator*<float,float,3,4,4,1,1,float,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$02$03$00@@_KV?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$02$03$00@@_KV?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Matrix<float,3,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,4,1> > >, COMDAT

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	jmp	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$03$00@@_KV?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,3,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,4,1> > >
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$02$03$00@@_KV?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Matrix<float,3,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$02$00@@_KV?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$02$00@@_KV?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Matrix<float,4,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,3,1> > >, COMDAT

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	jmp	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$02$00@@_KV?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,4,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,3,1> > >
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$02$00@@_KV?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Matrix<float,4,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$01$03$00@@_KV?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$01$03$00@@_KV?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Matrix<float,2,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,4,1> > >, COMDAT

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	jmp	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$03$00@@_KV?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,2,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,4,1> > >
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$01$03$00@@_KV?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Matrix<float,2,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$01$00@@_KV?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$01$00@@_KV?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Matrix<float,4,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,2,1> > >, COMDAT

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	jmp	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$01$00@@_KV?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,4,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,2,1> > >
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$01$00@@_KV?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Matrix<float,4,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$03$00@@_KV?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$03$00@@_KV?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Matrix<float,4,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,4,1> > >, COMDAT

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	jmp	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$03$00@@_KV?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,4,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,4,1> > >
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$03$03$00@@_KV?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Matrix<float,4,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$02$02$00@@_KV?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$02$02$00@@_KV?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Matrix<float,3,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,3,1> > >, COMDAT

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	jmp	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$02$00@@_KV?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,3,1> > >
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$02$02$00@@_KV?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Matrix<float,3,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$01$01$00@@_KV?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$01$01$00@@_KV?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Matrix<float,2,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,2,1> > >, COMDAT

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	jmp	??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$01$00@@_KV?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<Matrix<float,2,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,2,1> > >
??$_Uninitialized_default_fill_n@PEAV?$Matrix@M$01$01$00@@_KV?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Matrix<float,2,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >,std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Matrix@M$02$03$00@@@std@@PEAV?$Matrix@M$02$03$00@@@std@@YAXPEAV?$Matrix@M$02$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@V?$Matrix@M$02$03$00@@@std@@PEAV?$Matrix@M$02$03$00@@@std@@YAXPEAV?$Matrix@M$02$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Matrix<float,3,4,1> >,Matrix<float,3,4,1> * __ptr64>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Matrix@M$02$03$00@@@std@@PEAV?$Matrix@M$02$03$00@@@std@@YAXPEAV?$Matrix@M$02$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Matrix<float,3,4,1> >,Matrix<float,3,4,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Matrix@M$03$02$00@@@std@@PEAV?$Matrix@M$03$02$00@@@std@@YAXPEAV?$Matrix@M$03$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@V?$Matrix@M$03$02$00@@@std@@PEAV?$Matrix@M$03$02$00@@@std@@YAXPEAV?$Matrix@M$03$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Matrix<float,4,3,1> >,Matrix<float,4,3,1> * __ptr64>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Matrix@M$03$02$00@@@std@@PEAV?$Matrix@M$03$02$00@@@std@@YAXPEAV?$Matrix@M$03$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Matrix<float,4,3,1> >,Matrix<float,4,3,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Matrix@M$01$03$00@@@std@@PEAV?$Matrix@M$01$03$00@@@std@@YAXPEAV?$Matrix@M$01$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@V?$Matrix@M$01$03$00@@@std@@PEAV?$Matrix@M$01$03$00@@@std@@YAXPEAV?$Matrix@M$01$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Matrix<float,2,4,1> >,Matrix<float,2,4,1> * __ptr64>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Matrix@M$01$03$00@@@std@@PEAV?$Matrix@M$01$03$00@@@std@@YAXPEAV?$Matrix@M$01$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Matrix<float,2,4,1> >,Matrix<float,2,4,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Matrix@M$03$01$00@@@std@@PEAV?$Matrix@M$03$01$00@@@std@@YAXPEAV?$Matrix@M$03$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@V?$Matrix@M$03$01$00@@@std@@PEAV?$Matrix@M$03$01$00@@@std@@YAXPEAV?$Matrix@M$03$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Matrix<float,4,2,1> >,Matrix<float,4,2,1> * __ptr64>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Matrix@M$03$01$00@@@std@@PEAV?$Matrix@M$03$01$00@@@std@@YAXPEAV?$Matrix@M$03$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Matrix<float,4,2,1> >,Matrix<float,4,2,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Matrix@M$03$03$00@@@std@@PEAV?$Matrix@M$03$03$00@@@std@@YAXPEAV?$Matrix@M$03$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@V?$Matrix@M$03$03$00@@@std@@PEAV?$Matrix@M$03$03$00@@@std@@YAXPEAV?$Matrix@M$03$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Matrix<float,4,4,1> >,Matrix<float,4,4,1> * __ptr64>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Matrix@M$03$03$00@@@std@@PEAV?$Matrix@M$03$03$00@@@std@@YAXPEAV?$Matrix@M$03$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Matrix<float,4,4,1> >,Matrix<float,4,4,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Matrix@M$02$02$00@@@std@@PEAV?$Matrix@M$02$02$00@@@std@@YAXPEAV?$Matrix@M$02$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@V?$Matrix@M$02$02$00@@@std@@PEAV?$Matrix@M$02$02$00@@@std@@YAXPEAV?$Matrix@M$02$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Matrix<float,3,3,1> >,Matrix<float,3,3,1> * __ptr64>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Matrix@M$02$02$00@@@std@@PEAV?$Matrix@M$02$02$00@@@std@@YAXPEAV?$Matrix@M$02$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Matrix<float,3,3,1> >,Matrix<float,3,3,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Matrix@M$01$01$00@@@std@@PEAV?$Matrix@M$01$01$00@@@std@@YAXPEAV?$Matrix@M$01$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@V?$Matrix@M$01$01$00@@@std@@PEAV?$Matrix@M$01$01$00@@@std@@YAXPEAV?$Matrix@M$01$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Matrix<float,2,2,1> >,Matrix<float,2,2,1> * __ptr64>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Matrix@M$01$01$00@@@std@@PEAV?$Matrix@M$01$01$00@@@std@@YAXPEAV?$Matrix@M$01$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Matrix<float,2,2,1> >,Matrix<float,2,2,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Get@?$GetVectorElement@M@?$Vector@M$03@@SAMAEBMH@Z
_TEXT	SEGMENT
u$ = 8
idx$dead$ = 16
?Get@?$GetVectorElement@M@?$Vector@M$03@@SAMAEBMH@Z PROC ; Vector<float,4>::GetVectorElement<float>::Get, COMDAT

; 833  : 		static U Get(const U& u, int idx) { return u; }

	movss	xmm0, DWORD PTR [rcx]
	ret	0
?Get@?$GetVectorElement@M@?$Vector@M$03@@SAMAEBMH@Z ENDP ; Vector<float,4>::GetVectorElement<float>::Get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Get@?$GetVectorElement@V?$Vector@M$02@@@?$Vector@M$03@@SAMAEBV?$Vector@M$02@@H@Z
_TEXT	SEGMENT
u$ = 8
idx$ = 16
?Get@?$GetVectorElement@V?$Vector@M$02@@@?$Vector@M$03@@SAMAEBV?$Vector@M$02@@H@Z PROC ; Vector<float,4>::GetVectorElement<Vector<float,3> >::Get, COMDAT

; 837  : 		static U Get(const Vector<U, E>& u, int idx) { return u.data[idx]; }

	movsxd	rax, edx
	movss	xmm0, DWORD PTR [rcx+rax*4]
	ret	0
?Get@?$GetVectorElement@V?$Vector@M$02@@@?$Vector@M$03@@SAMAEBV?$Vector@M$02@@H@Z ENDP ; Vector<float,4>::GetVectorElement<Vector<float,3> >::Get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Get@?$GetVectorElement@V?$Vector@M$03@@@?$Vector@M$07@@SAMAEBV?$Vector@M$03@@H@Z
_TEXT	SEGMENT
u$ = 8
idx$ = 16
?Get@?$GetVectorElement@V?$Vector@M$03@@@?$Vector@M$07@@SAMAEBV?$Vector@M$03@@H@Z PROC ; Vector<float,8>::GetVectorElement<Vector<float,4> >::Get, COMDAT

; 837  : 		static U Get(const Vector<U, E>& u, int idx) { return u.data[idx]; }

	movsxd	rax, edx
	movss	xmm0, DWORD PTR [rcx+rax*4]
	ret	0
?Get@?$GetVectorElement@V?$Vector@M$03@@@?$Vector@M$07@@SAMAEBV?$Vector@M$03@@H@Z ENDP ; Vector<float,8>::GetVectorElement<Vector<float,4> >::Get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 489  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >::_Vector_val<std::_Simple_types<Matrix<float,3,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >, COMDAT

; 937  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 489  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >::_Vector_val<std::_Simple_types<Matrix<float,4,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >, COMDAT

; 937  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$02$03$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$02$03$00@@QEBAMHH@Z PROC			; Matrix<float,3,4,1>::operator(), COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 110  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*4]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 111  : 	}

	ret	0
??R?$Matrix@M$02$03$00@@QEBAMHH@Z ENDP			; Matrix<float,3,4,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ??R?$Matrix@M$03$02$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
??R?$Matrix@M$03$02$00@@QEBAMHH@Z PROC			; Matrix<float,4,3,1>::operator(), COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 110  : 		return GetElement(col, row);

	lea	rdx, QWORD PTR [rax+r8*4]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 111  : 	}

	ret	0
??R?$Matrix@M$03$02$00@@QEBAMHH@Z ENDP			; Matrix<float,4,3,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 489  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >::_Vector_val<std::_Simple_types<Matrix<float,2,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >, COMDAT

; 937  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 489  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >::_Vector_val<std::_Simple_types<Matrix<float,4,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >, COMDAT

; 937  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 489  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >::_Vector_val<std::_Simple_types<Matrix<float,4,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >, COMDAT

; 937  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 489  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >::_Vector_val<std::_Simple_types<Matrix<float,3,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >, COMDAT

; 937  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 489  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >::_Vector_val<std::_Simple_types<Matrix<float,2,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >, COMDAT

; 937  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Assign@?$Vector@M$03@@IEAAXH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
?Assign@?$Vector@M$03@@IEAAXH@Z PROC			; Vector<float,4>::Assign, COMDAT

; 860  : 		for (idx = 0; idx < D; idx++) {
; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 862  : 		}
; 863  : 	}

	ret	0
?Assign@?$Vector@M$03@@IEAAXH@Z ENDP			; Vector<float,4>::Assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??Y?$Vector@M$03@@QEAAAEAV0@AEBV0@@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
??Y?$Vector@M$03@@QEAAAEAV0@AEBV0@@Z PROC		; Vector<float,4>::operator+=, COMDAT
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	movaps	xmm0, XMMWORD PTR [rdx]
; File c:\home\programming\mathter\mathter\vector.hpp

; 757  : 		return *this;

	mov	rax, rcx
; File c:\home\programming\mathter\mathter\simd4f_sse.hpp

; 25   : 		res.reg = _mm_add_ps(lhs.reg, rhs.reg);

	addps	xmm0, XMMWORD PTR [rcx]
; File c:\home\programming\mathter\mathter\vector.hpp

; 464  : 		simd = Simd4f::add(simd, rhs.simd);

	movaps	XMMWORD PTR [rcx], xmm0

; 758  : 	}

	ret	0
??Y?$Vector@M$03@@QEAAAEAV0@AEBV0@@Z ENDP		; Vector<float,4>::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT

; 258  : 		return (_MyDur);

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax
	mov	rax, rdx

; 259  : 		}

	ret	0
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Assign@?$Vector@M$02@@IEAAXH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
?Assign@?$Vector@M$02@@IEAAXH@Z PROC			; Vector<float,3>::Assign, COMDAT

; 860  : 		for (idx = 0; idx < D; idx++) {
; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 862  : 		}
; 863  : 	}

	ret	0
?Assign@?$Vector@M$02@@IEAAXH@Z ENDP			; Vector<float,3>::Assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAA@XZ PROC	; std::allocator<Matrix<float,3,4,1> >::allocator<Matrix<float,3,4,1> >, COMDAT

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAA@XZ ENDP	; std::allocator<Matrix<float,3,4,1> >::allocator<Matrix<float,3,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAA@XZ PROC	; std::allocator<Matrix<float,4,3,1> >::allocator<Matrix<float,4,3,1> >, COMDAT

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAA@XZ ENDP	; std::allocator<Matrix<float,4,3,1> >::allocator<Matrix<float,4,3,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$02$03$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$02$03$00@@QEBAMHH@Z PROC	; MatrixData<float,3,4,1>::GetElement, COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 45   : 		return stripes[row][col];

	lea	rdx, QWORD PTR [rax+r8*4]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 46   : 	}

	ret	0
?GetElement@?$MatrixData@M$02$03$00@@QEBAMHH@Z ENDP	; MatrixData<float,3,4,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\matrix.hpp
; File c:\home\programming\mathter\mathter\vector.hpp
; File c:\home\programming\mathter\mathter\matrix.hpp
;	COMDAT ?GetElement@?$MatrixData@M$03$02$00@@QEBAMHH@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
row$ = 24
?GetElement@?$MatrixData@M$03$02$00@@QEBAMHH@Z PROC	; MatrixData<float,4,3,1>::GetElement, COMDAT

; 45   : 		return stripes[row][col];

	movsxd	r8, r8d
; File c:\home\programming\mathter\mathter\vector.hpp

; 680  : 		return data[idx];

	movsxd	rax, edx
; File c:\home\programming\mathter\mathter\matrix.hpp

; 45   : 		return stripes[row][col];

	lea	rdx, QWORD PTR [rax+r8*4]
	movss	xmm0, DWORD PTR [rcx+rdx*4]

; 46   : 	}

	ret	0
?GetElement@?$MatrixData@M$03$02$00@@QEBAMHH@Z ENDP	; MatrixData<float,4,3,1>::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAA@XZ PROC	; std::allocator<Matrix<float,2,4,1> >::allocator<Matrix<float,2,4,1> >, COMDAT

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAA@XZ ENDP	; std::allocator<Matrix<float,2,4,1> >::allocator<Matrix<float,2,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAA@XZ PROC	; std::allocator<Matrix<float,4,2,1> >::allocator<Matrix<float,4,2,1> >, COMDAT

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAA@XZ ENDP	; std::allocator<Matrix<float,4,2,1> >::allocator<Matrix<float,4,2,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAA@XZ PROC	; std::allocator<Matrix<float,4,4,1> >::allocator<Matrix<float,4,4,1> >, COMDAT

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAA@XZ ENDP	; std::allocator<Matrix<float,4,4,1> >::allocator<Matrix<float,4,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAA@XZ PROC	; std::allocator<Matrix<float,3,3,1> >::allocator<Matrix<float,3,3,1> >, COMDAT

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAA@XZ ENDP	; std::allocator<Matrix<float,3,3,1> >::allocator<Matrix<float,3,3,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAA@XZ PROC	; std::allocator<Matrix<float,2,2,1> >::allocator<Matrix<float,2,2,1> >, COMDAT

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAA@XZ ENDP	; std::allocator<Matrix<float,2,2,1> >::allocator<Matrix<float,2,2,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MM$0A@@?$Vector@M$02@@IEAAXHMM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<scalars_0>$ = 32
??$Assign@MM$0A@@?$Vector@M$02@@IEAAXHMM@Z PROC		; Vector<float,3>::Assign<float,float,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 844  : 		data[idx] = head;
; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@MM$0A@@?$Vector@M$02@@IEAAXHMM@Z ENDP		; Vector<float,3>::Assign<float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MMM$0A@@?$Vector@M$03@@IEAAXHMMM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<scalars_0>$ = 32
<scalars_1>$ = 40
??$Assign@MMM$0A@@?$Vector@M$03@@IEAAXHMMM@Z PROC	; Vector<float,4>::Assign<float,float,float,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 844  : 		data[idx] = head;
; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@MMM$0A@@?$Vector@M$03@@IEAAXHMMM@Z ENDP	; Vector<float,4>::Assign<float,float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@V?$Vector@M$03@@$$V$0A@@?$Vector@M$07@@IEAAXHAEBV?$Vector@M$03@@@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
head$ = 24
??$Assign@V?$Vector@M$03@@$$V$0A@@?$Vector@M$07@@IEAAXHAEBV?$Vector@M$03@@@Z PROC ; Vector<float,8>::Assign<Vector<float,4>,0>, COMDAT

; 851  : 		for (int i = 0; i < DimensionOf<Head>::value; ++i) {
; 852  : 			data[idx] = GetVectorElement<Head>::Get(head, i);

	mov	eax, DWORD PTR [r8]
	movsxd	r9, edx
	mov	DWORD PTR [rcx+r9*4], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+r9*4+4], eax
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+r9*4+8], eax
	mov	eax, DWORD PTR [r8+12]
	mov	DWORD PTR [rcx+r9*4+12], eax

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 853  : 			++idx;
; 854  : 		}
; 855  : 		Assign(idx, mixed...);
; 856  : 	}

	ret	0
??$Assign@V?$Vector@M$03@@$$V$0A@@?$Vector@M$07@@IEAAXHAEBV?$Vector@M$03@@@Z ENDP ; Vector<float,8>::Assign<Vector<float,4>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
<scalars_3>$dead$ = 56
<scalars_4>$dead$ = 64
<scalars_5>$dead$ = 72
??$Assign@HHHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHHH@Z PROC ; Vector<float,8>::Assign<int,int,int,int,int,int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H
	mov	DWORD PTR [rcx+12], 1082130432		; 40800000H
	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@HHHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHHH@Z ENDP ; Vector<float,8>::Assign<int,int,int,int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HH$0A@@?$Vector@M$02@@IEAAXHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
??$Assign@HH$0A@@?$Vector@M$02@@IEAAXHHH@Z PROC		; Vector<float,3>::Assign<int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+4], 1073741824		; 40000000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@HH$0A@@?$Vector@M$02@@IEAAXHHH@Z ENDP		; Vector<float,3>::Assign<int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Left$ = 16
_Right$ = 24
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT

; 351  : 	typedef typename common_type<
; 352  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [r8]

; 116  : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	QWORD PTR [rcx], rax

; 351  : 	typedef typename common_type<
; 352  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 353  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	rax, rcx

; 354  : 	}

	ret	0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$03$00@@_KV?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$03$00@@_KV?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Matrix<float,3,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,4,1> > >, COMDAT

; 453  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	mov	eax, 100000				; 000186a0H
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN2@Uninitiali
	xor	edx, edx
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], rdx
	mov	QWORD PTR [rcx+24], rdx
	mov	QWORD PTR [rcx+32], rdx
	mov	QWORD PTR [rcx+40], rdx
	mov	QWORD PTR [rcx+48], rdx
	mov	QWORD PTR [rcx+56], rdx
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	rcx, 64					; 00000040H
	sub	rax, 1
	jne	SHORT $LL4@Uninitiali

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$03$00@@_KV?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Matrix<float,3,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$02$00@@_KV?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$02$00@@_KV?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Matrix<float,4,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,3,1> > >, COMDAT

; 453  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	mov	eax, 100000				; 000186a0H
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN2@Uninitiali
	xor	edx, edx
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], rdx
	mov	QWORD PTR [rcx+24], rdx
	mov	QWORD PTR [rcx+32], rdx
	mov	QWORD PTR [rcx+40], rdx
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	rcx, 48					; 00000030H
	sub	rax, 1
	jne	SHORT $LL4@Uninitiali

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$02$00@@_KV?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Matrix<float,4,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$03$00@@_KV?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$03$00@@_KV?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Matrix<float,2,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,4,1> > >, COMDAT

; 453  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	mov	eax, 100000				; 000186a0H
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN2@Uninitiali
	xor	edx, edx
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], rdx
	mov	QWORD PTR [rcx+24], rdx
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	rcx, 32					; 00000020H
	sub	rax, 1
	jne	SHORT $LL4@Uninitiali

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$03$00@@_KV?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Matrix<float,2,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$01$00@@_KV?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$01$00@@_KV?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Matrix<float,4,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,2,1> > >, COMDAT

; 453  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	mov	eax, 100000				; 000186a0H
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN2@Uninitiali
	xor	edx, edx
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], rdx
	mov	QWORD PTR [rcx+24], rdx
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	rcx, 32					; 00000020H
	sub	rax, 1
	jne	SHORT $LL4@Uninitiali

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$01$00@@_KV?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Matrix<float,4,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$03$00@@_KV?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$03$00@@_KV?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Matrix<float,4,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,4,1> > >, COMDAT

; 453  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	mov	eax, 100000				; 000186a0H
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN2@Uninitiali
	xor	edx, edx
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], rdx
	mov	QWORD PTR [rcx+24], rdx
	mov	QWORD PTR [rcx+32], rdx
	mov	QWORD PTR [rcx+40], rdx
	mov	QWORD PTR [rcx+48], rdx
	mov	QWORD PTR [rcx+56], rdx
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	rcx, 64					; 00000040H
	sub	rax, 1
	jne	SHORT $LL4@Uninitiali

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$03$03$00@@_KV?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@YAXPEAV?$Matrix@M$03$03$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Matrix<float,4,4,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,4,4,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$02$00@@_KV?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$02$00@@_KV?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,3,1> > >, COMDAT

; 453  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	mov	eax, 100000				; 000186a0H
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN2@Uninitiali
	xor	edx, edx
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], rdx
	mov	QWORD PTR [rcx+24], rdx
	mov	QWORD PTR [rcx+32], rdx
	mov	QWORD PTR [rcx+40], rdx
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	rcx, 48					; 00000030H
	sub	rax, 1
	jne	SHORT $LL4@Uninitiali

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$02$02$00@@_KV?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@YAXPEAV?$Matrix@M$02$02$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Matrix<float,3,3,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,3,3,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$01$00@@_KV?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$01$00@@_KV?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Matrix<float,2,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,2,1> > >, COMDAT

; 453  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	mov	eax, 100000				; 000186a0H
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	SHORT $LN2@Uninitiali
	xor	edx, edx
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], rdx
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	rcx, 16
	sub	rax, 1
	jne	SHORT $LL4@Uninitiali

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PEAV?$Matrix@M$01$01$00@@_KV?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@YAXPEAV?$Matrix@M$01$01$00@@_KAEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Matrix<float,2,2,1> * __ptr64,unsigned __int64,std::allocator<Matrix<float,2,2,1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$03$00@@@std@@PEAV?$Matrix@M$02$03$00@@@std@@YAXPEAV?$Matrix@M$02$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$03$00@@@std@@PEAV?$Matrix@M$02$03$00@@@std@@YAXPEAV?$Matrix@M$02$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Matrix<float,3,4,1> >,Matrix<float,3,4,1> * __ptr64>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$03$00@@@std@@PEAV?$Matrix@M$02$03$00@@@std@@YAXPEAV?$Matrix@M$02$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Matrix<float,3,4,1> >,Matrix<float,3,4,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$02$00@@@std@@PEAV?$Matrix@M$03$02$00@@@std@@YAXPEAV?$Matrix@M$03$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$02$00@@@std@@PEAV?$Matrix@M$03$02$00@@@std@@YAXPEAV?$Matrix@M$03$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Matrix<float,4,3,1> >,Matrix<float,4,3,1> * __ptr64>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$02$00@@@std@@PEAV?$Matrix@M$03$02$00@@@std@@YAXPEAV?$Matrix@M$03$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Matrix<float,4,3,1> >,Matrix<float,4,3,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$Matrix@M$01$03$00@@@std@@PEAV?$Matrix@M$01$03$00@@@std@@YAXPEAV?$Matrix@M$01$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range1@V?$allocator@V?$Matrix@M$01$03$00@@@std@@PEAV?$Matrix@M$01$03$00@@@std@@YAXPEAV?$Matrix@M$01$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Matrix<float,2,4,1> >,Matrix<float,2,4,1> * __ptr64>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$Matrix@M$01$03$00@@@std@@PEAV?$Matrix@M$01$03$00@@@std@@YAXPEAV?$Matrix@M$01$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Matrix<float,2,4,1> >,Matrix<float,2,4,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$01$00@@@std@@PEAV?$Matrix@M$03$01$00@@@std@@YAXPEAV?$Matrix@M$03$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$01$00@@@std@@PEAV?$Matrix@M$03$01$00@@@std@@YAXPEAV?$Matrix@M$03$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Matrix<float,4,2,1> >,Matrix<float,4,2,1> * __ptr64>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$01$00@@@std@@PEAV?$Matrix@M$03$01$00@@@std@@YAXPEAV?$Matrix@M$03$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Matrix<float,4,2,1> >,Matrix<float,4,2,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$03$00@@@std@@PEAV?$Matrix@M$03$03$00@@@std@@YAXPEAV?$Matrix@M$03$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$03$00@@@std@@PEAV?$Matrix@M$03$03$00@@@std@@YAXPEAV?$Matrix@M$03$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Matrix<float,4,4,1> >,Matrix<float,4,4,1> * __ptr64>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$Matrix@M$03$03$00@@@std@@PEAV?$Matrix@M$03$03$00@@@std@@YAXPEAV?$Matrix@M$03$03$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Matrix<float,4,4,1> >,Matrix<float,4,4,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$02$00@@@std@@PEAV?$Matrix@M$02$02$00@@@std@@YAXPEAV?$Matrix@M$02$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$02$00@@@std@@PEAV?$Matrix@M$02$02$00@@@std@@YAXPEAV?$Matrix@M$02$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Matrix<float,3,3,1> >,Matrix<float,3,3,1> * __ptr64>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$Matrix@M$02$02$00@@@std@@PEAV?$Matrix@M$02$02$00@@@std@@YAXPEAV?$Matrix@M$02$02$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Matrix<float,3,3,1> >,Matrix<float,3,3,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$Matrix@M$01$01$00@@@std@@PEAV?$Matrix@M$01$01$00@@@std@@YAXPEAV?$Matrix@M$01$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range1@V?$allocator@V?$Matrix@M$01$01$00@@@std@@PEAV?$Matrix@M$01$01$00@@@std@@YAXPEAV?$Matrix@M$01$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Matrix<float,2,2,1> >,Matrix<float,2,2,1> * __ptr64>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$Matrix@M$01$01$00@@@std@@PEAV?$Matrix@M$01$01$00@@@std@@YAXPEAV?$Matrix@M$01$01$00@@0AEAU?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Matrix<float,2,2,1> >,Matrix<float,2,2,1> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ?Assign@?$Vector@M$07@@IEAAXH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
?Assign@?$Vector@M$07@@IEAAXH@Z PROC			; Vector<float,8>::Assign, COMDAT

; 860  : 		for (idx = 0; idx < D; idx++) {
; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 862  : 		}
; 863  : 	}

	ret	0
?Assign@?$Vector@M$07@@IEAAXH@Z ENDP			; Vector<float,8>::Assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@V?$Matrix@M$02$03$00@@@std@@YAPEAV?$Matrix@M$02$03$00@@PEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$Matrix@M$02$03$00@@@std@@YAPEAV?$Matrix@M$02$03$00@@PEAV1@@Z PROC ; std::_Unfancy<Matrix<float,3,4,1> >, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@V?$Matrix@M$02$03$00@@@std@@YAPEAV?$Matrix@M$02$03$00@@PEAV1@@Z ENDP ; std::_Unfancy<Matrix<float,3,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@V?$Matrix@M$03$02$00@@@std@@YAPEAV?$Matrix@M$03$02$00@@PEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$Matrix@M$03$02$00@@@std@@YAPEAV?$Matrix@M$03$02$00@@PEAV1@@Z PROC ; std::_Unfancy<Matrix<float,4,3,1> >, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@V?$Matrix@M$03$02$00@@@std@@YAPEAV?$Matrix@M$03$02$00@@PEAV1@@Z ENDP ; std::_Unfancy<Matrix<float,4,3,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@V?$Matrix@M$01$03$00@@@std@@YAPEAV?$Matrix@M$01$03$00@@PEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$Matrix@M$01$03$00@@@std@@YAPEAV?$Matrix@M$01$03$00@@PEAV1@@Z PROC ; std::_Unfancy<Matrix<float,2,4,1> >, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@V?$Matrix@M$01$03$00@@@std@@YAPEAV?$Matrix@M$01$03$00@@PEAV1@@Z ENDP ; std::_Unfancy<Matrix<float,2,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@V?$Matrix@M$03$01$00@@@std@@YAPEAV?$Matrix@M$03$01$00@@PEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$Matrix@M$03$01$00@@@std@@YAPEAV?$Matrix@M$03$01$00@@PEAV1@@Z PROC ; std::_Unfancy<Matrix<float,4,2,1> >, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@V?$Matrix@M$03$01$00@@@std@@YAPEAV?$Matrix@M$03$01$00@@PEAV1@@Z ENDP ; std::_Unfancy<Matrix<float,4,2,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@V?$Matrix@M$03$03$00@@@std@@YAPEAV?$Matrix@M$03$03$00@@PEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$Matrix@M$03$03$00@@@std@@YAPEAV?$Matrix@M$03$03$00@@PEAV1@@Z PROC ; std::_Unfancy<Matrix<float,4,4,1> >, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@V?$Matrix@M$03$03$00@@@std@@YAPEAV?$Matrix@M$03$03$00@@PEAV1@@Z ENDP ; std::_Unfancy<Matrix<float,4,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@V?$Matrix@M$02$02$00@@@std@@YAPEAV?$Matrix@M$02$02$00@@PEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$Matrix@M$02$02$00@@@std@@YAPEAV?$Matrix@M$02$02$00@@PEAV1@@Z PROC ; std::_Unfancy<Matrix<float,3,3,1> >, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@V?$Matrix@M$02$02$00@@@std@@YAPEAV?$Matrix@M$02$02$00@@PEAV1@@Z ENDP ; std::_Unfancy<Matrix<float,3,3,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@V?$Matrix@M$01$01$00@@@std@@YAPEAV?$Matrix@M$01$01$00@@PEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$Matrix@M$01$01$00@@@std@@YAPEAV?$Matrix@M$01$01$00@@PEAV1@@Z PROC ; std::_Unfancy<Matrix<float,2,2,1> >, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@V?$Matrix@M$01$01$00@@@std@@YAPEAV?$Matrix@M$01$01$00@@PEAV1@@Z ENDP ; std::_Unfancy<Matrix<float,2,2,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@M$$V$0A@@?$Vector@M$02@@IEAAXHM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
??$Assign@M$$V$0A@@?$Vector@M$02@@IEAAXHM@Z PROC	; Vector<float,3>::Assign<float,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 844  : 		data[idx] = head;
; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@M$$V$0A@@?$Vector@M$02@@IEAAXHM@Z ENDP	; Vector<float,3>::Assign<float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@MM$0A@@?$Vector@M$03@@IEAAXHMM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
<scalars_0>$ = 32
??$Assign@MM$0A@@?$Vector@M$03@@IEAAXHMM@Z PROC		; Vector<float,4>::Assign<float,float,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 844  : 		data[idx] = head;
; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@MM$0A@@?$Vector@M$03@@IEAAXHMM@Z ENDP		; Vector<float,4>::Assign<float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
<scalars_3>$dead$ = 56
<scalars_4>$dead$ = 64
??$Assign@HHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHH@Z PROC	; Vector<float,8>::Assign<int,int,int,int,int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+8], 1077936128		; 40400000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+12], 1082130432		; 40800000H
	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@HHHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHHH@Z ENDP	; Vector<float,8>::Assign<int,int,int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$02$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::construct<Matrix<float,3,4,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
$LN7@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@V?$Matrix@M$02$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,4,1> > >::construct<Matrix<float,3,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$03$02$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$03$02$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::construct<Matrix<float,4,3,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
$LN7@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@V?$Matrix@M$03$02$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,3,1> > >::construct<Matrix<float,4,3,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$01$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$01$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::construct<Matrix<float,2,4,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
$LN7@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@V?$Matrix@M$01$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,2,4,1> > >::construct<Matrix<float,2,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$03$01$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$03$01$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::construct<Matrix<float,4,2,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
$LN7@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@V?$Matrix@M$03$01$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,2,1> > >::construct<Matrix<float,4,2,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$03$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$03$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::construct<Matrix<float,4,4,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
$LN7@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@V?$Matrix@M$03$03$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,4,4,1> > >::construct<Matrix<float,4,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$02$02$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::construct<Matrix<float,3,3,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
$LN7@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@V?$Matrix@M$02$02$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,3,3,1> > >::construct<Matrix<float,3,3,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$01$01$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$01$01$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@@Z PROC ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::construct<Matrix<float,2,2,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
$LN7@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@V?$Matrix@M$01$01$00@@$$V@?$_Wrap_alloc@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Matrix<float,2,2,1> > >::construct<Matrix<float,2,2,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@M$$V$0A@@?$Vector@M$03@@IEAAXHM@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$ = 24
??$Assign@M$$V$0A@@?$Vector@M$03@@IEAAXHM@Z PROC	; Vector<float,4>::Assign<float,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 844  : 		data[idx] = head;
; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@M$$V$0A@@?$Vector@M$03@@IEAAXHM@Z ENDP	; Vector<float,4>::Assign<float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
<scalars_3>$dead$ = 56
??$Assign@HHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHH@Z PROC	; Vector<float,8>::Assign<int,int,int,int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+12], 1082130432		; 40800000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H
	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@HHHHH$0A@@?$Vector@M$07@@IEAAXHHHHHH@Z ENDP	; Vector<float,8>::Assign<int,int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$02$03$00@@@1@PEAV?$Matrix@M$02$03$00@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$02$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$02$03$00@@@1@PEAV?$Matrix@M$02$03$00@@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,3,4,1> > >::construct<Matrix<float,3,4,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN5@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
$LN5@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@V?$Matrix@M$02$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$02$03$00@@@1@PEAV?$Matrix@M$02$03$00@@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,3,4,1> > >::construct<Matrix<float,3,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$03$02$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$02$00@@@1@PEAV?$Matrix@M$03$02$00@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$03$02$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$02$00@@@1@PEAV?$Matrix@M$03$02$00@@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,4,3,1> > >::construct<Matrix<float,4,3,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN5@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
$LN5@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@V?$Matrix@M$03$02$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$02$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$02$00@@@1@PEAV?$Matrix@M$03$02$00@@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,4,3,1> > >::construct<Matrix<float,4,3,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$01$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$01$03$00@@@1@PEAV?$Matrix@M$01$03$00@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$01$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$01$03$00@@@1@PEAV?$Matrix@M$01$03$00@@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,2,4,1> > >::construct<Matrix<float,2,4,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN5@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
$LN5@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@V?$Matrix@M$01$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$01$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$01$03$00@@@1@PEAV?$Matrix@M$01$03$00@@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,2,4,1> > >::construct<Matrix<float,2,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$03$01$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$01$00@@@1@PEAV?$Matrix@M$03$01$00@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$03$01$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$01$00@@@1@PEAV?$Matrix@M$03$01$00@@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,4,2,1> > >::construct<Matrix<float,4,2,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN5@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
$LN5@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@V?$Matrix@M$03$01$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$01$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$01$00@@@1@PEAV?$Matrix@M$03$01$00@@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,4,2,1> > >::construct<Matrix<float,4,2,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$03$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$03$00@@@1@PEAV?$Matrix@M$03$03$00@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$03$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$03$00@@@1@PEAV?$Matrix@M$03$03$00@@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,4,4,1> > >::construct<Matrix<float,4,4,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN5@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
$LN5@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@V?$Matrix@M$03$03$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$03$03$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$03$03$00@@@1@PEAV?$Matrix@M$03$03$00@@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,4,4,1> > >::construct<Matrix<float,4,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$02$02$00@@@1@PEAV?$Matrix@M$02$02$00@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$02$02$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$02$02$00@@@1@PEAV?$Matrix@M$02$02$00@@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,3,3,1> > >::construct<Matrix<float,3,3,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN5@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
$LN5@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@V?$Matrix@M$02$02$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$02$02$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$02$02$00@@@1@PEAV?$Matrix@M$02$02$00@@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,3,3,1> > >::construct<Matrix<float,3,3,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$01$01$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$01$01$00@@@1@PEAV?$Matrix@M$01$01$00@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$01$01$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$01$01$00@@@1@PEAV?$Matrix@M$01$01$00@@@Z PROC ; std::allocator_traits<std::allocator<Matrix<float,2,2,1> > >::construct<Matrix<float,2,2,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN5@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
$LN5@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@V?$Matrix@M$01$01$00@@$$V@?$allocator_traits@V?$allocator@V?$Matrix@M$01$01$00@@@std@@@std@@SAXAEAV?$allocator@V?$Matrix@M$01$01$00@@@1@PEAV?$Matrix@M$01$01$00@@@Z ENDP ; std::allocator_traits<std::allocator<Matrix<float,2,2,1> > >::construct<Matrix<float,2,2,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHHH$0A@@?$Vector@M$07@@IEAAXHHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
<scalars_2>$dead$ = 48
??$Assign@HHHH$0A@@?$Vector@M$07@@IEAAXHHHHH@Z PROC	; Vector<float,8>::Assign<int,int,int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+16], 1084227584		; 40a00000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H
	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@HHHH$0A@@?$Vector@M$07@@IEAAXHHHHH@Z ENDP	; Vector<float,8>::Assign<int,int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$03$00@@$$V@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$02$03$00@@$$V@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@@Z PROC ; std::allocator<Matrix<float,3,4,1> >::construct<Matrix<float,3,4,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@V?$Matrix@M$02$03$00@@$$V@?$allocator@V?$Matrix@M$02$03$00@@@std@@QEAAXPEAV?$Matrix@M$02$03$00@@@Z ENDP ; std::allocator<Matrix<float,3,4,1> >::construct<Matrix<float,3,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$03$02$00@@$$V@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$03$02$00@@$$V@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@@Z PROC ; std::allocator<Matrix<float,4,3,1> >::construct<Matrix<float,4,3,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@V?$Matrix@M$03$02$00@@$$V@?$allocator@V?$Matrix@M$03$02$00@@@std@@QEAAXPEAV?$Matrix@M$03$02$00@@@Z ENDP ; std::allocator<Matrix<float,4,3,1> >::construct<Matrix<float,4,3,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$01$03$00@@$$V@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$01$03$00@@$$V@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@@Z PROC ; std::allocator<Matrix<float,2,4,1> >::construct<Matrix<float,2,4,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@V?$Matrix@M$01$03$00@@$$V@?$allocator@V?$Matrix@M$01$03$00@@@std@@QEAAXPEAV?$Matrix@M$01$03$00@@@Z ENDP ; std::allocator<Matrix<float,2,4,1> >::construct<Matrix<float,2,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$03$01$00@@$$V@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$03$01$00@@$$V@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@@Z PROC ; std::allocator<Matrix<float,4,2,1> >::construct<Matrix<float,4,2,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@V?$Matrix@M$03$01$00@@$$V@?$allocator@V?$Matrix@M$03$01$00@@@std@@QEAAXPEAV?$Matrix@M$03$01$00@@@Z ENDP ; std::allocator<Matrix<float,4,2,1> >::construct<Matrix<float,4,2,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$03$03$00@@$$V@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$03$03$00@@$$V@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@@Z PROC ; std::allocator<Matrix<float,4,4,1> >::construct<Matrix<float,4,4,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@V?$Matrix@M$03$03$00@@$$V@?$allocator@V?$Matrix@M$03$03$00@@@std@@QEAAXPEAV?$Matrix@M$03$03$00@@@Z ENDP ; std::allocator<Matrix<float,4,4,1> >::construct<Matrix<float,4,4,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$02$02$00@@$$V@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$02$02$00@@$$V@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@@Z PROC ; std::allocator<Matrix<float,3,3,1> >::construct<Matrix<float,3,3,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@V?$Matrix@M$02$02$00@@$$V@?$allocator@V?$Matrix@M$02$02$00@@@std@@QEAAXPEAV?$Matrix@M$02$02$00@@@Z ENDP ; std::allocator<Matrix<float,3,3,1> >::construct<Matrix<float,3,3,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$Matrix@M$01$01$00@@$$V@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$construct@V?$Matrix@M$01$01$00@@$$V@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@@Z PROC ; std::allocator<Matrix<float,2,2,1> >::construct<Matrix<float,2,2,1> >, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@V?$Matrix@M$01$01$00@@$$V@?$allocator@V?$Matrix@M$01$01$00@@@std@@QEAAXPEAV?$Matrix@M$01$01$00@@@Z ENDP ; std::allocator<Matrix<float,2,2,1> >::construct<Matrix<float,2,2,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HHH$0A@@?$Vector@M$07@@IEAAXHHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
<scalars_1>$dead$ = 40
??$Assign@HHH$0A@@?$Vector@M$07@@IEAAXHHHH@Z PROC	; Vector<float,8>::Assign<int,int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+20], 1086324736		; 40c00000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H
	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@HHH$0A@@?$Vector@M$07@@IEAAXHHHH@Z ENDP	; Vector<float,8>::Assign<int,int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@HH$0A@@?$Vector@M$07@@IEAAXHHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
<scalars_0>$dead$ = 32
??$Assign@HH$0A@@?$Vector@M$07@@IEAAXHHH@Z PROC		; Vector<float,8>::Assign<int,int,0>, COMDAT

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+24], 1088421888		; 40e00000H

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@HH$0A@@?$Vector@M$07@@IEAAXHHH@Z ENDP		; Vector<float,8>::Assign<int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\home\programming\mathter\mathter\vector.hpp
;	COMDAT ??$Assign@H$$V$0A@@?$Vector@M$07@@IEAAXHH@Z
_TEXT	SEGMENT
this$ = 8
idx$dead$ = 16
head$dead$ = 24
??$Assign@H$$V$0A@@?$Vector@M$07@@IEAAXHH@Z PROC	; Vector<float,8>::Assign<int,0>, COMDAT

; 861  : 			data[idx] = T(0);

	xor	eax, eax

; 844  : 		data[idx] = head;

	mov	DWORD PTR [rcx+28], 1090519040		; 41000000H

; 861  : 			data[idx] = T(0);

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 845  : 		Assign(idx + 1, scalars...);
; 846  : 	}

	ret	0
??$Assign@H$$V$0A@@?$Vector@M$07@@IEAAXHH@Z ENDP	; Vector<float,8>::Assign<int,0>
_TEXT	ENDS
END
